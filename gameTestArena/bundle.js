/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Game": () => (/* binding */ Game)
/* harmony export */ });
/* harmony import */ var _library_managers_signalmanager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _library_utilities_settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _library_managers_texturemanager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);
/* harmony import */ var _library_managers_vertexbuffermanager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(42);
/* harmony import */ var _library_managers_shadermanager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(40);
/* harmony import */ var _state_testarenastate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(143);
/* harmony import */ var _library_system_device__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(9);
/* harmony import */ var _library_managers_eventmanager__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(30);
/* harmony import */ var _library_utilities_highresolutiontimer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(56);
/* harmony import */ var _data_settings_settings_json__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(170);

// 
//  FILE NAME: game.js
//  DESC:      CGame class
//









//import { TitleScreenState } from '../state/titlescreenstate';
//import { LoadState } from '../state/loadstate';
//import { Level1State } from '../state/level1state';
//import { SmartConfirmBtn } from '../smartGUI/smartconfirmbtn';



//import * as stateDefs from '../state/statedefs';
//import * as genFunc from '../../../library/utilities/genfunc';

// Load data from bundle


class Game
{
    constructor()
    {
    }
    
    // 
    //  DESC: Init the game
    //
    init()
    {
        // Load the settings
        _library_utilities_settings__WEBPACK_IMPORTED_MODULE_1__.settings.loadFromObj( _data_settings_settings_json__WEBPACK_IMPORTED_MODULE_9__ );

        // Create the OpenGL context
        let gl = _library_system_device__WEBPACK_IMPORTED_MODULE_6__.device.create();

        // Set the init shader callback
        _library_managers_signalmanager__WEBPACK_IMPORTED_MODULE_0__.signalManager.connect_initShader( this.initShaderCallBack.bind(this) );
        
        // Do we add stencil buffer
        if( _library_utilities_settings__WEBPACK_IMPORTED_MODULE_1__.settings.createStencilBuffer )
            gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
        
        // Depth testing is off by default. Enable it?
        if( _library_utilities_settings__WEBPACK_IMPORTED_MODULE_1__.settings.enableDepthBuffer )
            gl.enable(gl.DEPTH_TEST);
    
        // Init the clear color
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        
        // Init the stencil clear mask based on the bit size of the mask
        // Stencil buffer can only be 1 or 8 bits per pixel
        if( _library_utilities_settings__WEBPACK_IMPORTED_MODULE_1__.settings.stencilBufferBitSize === 1 )
        {
            gl.stencilFunc(gl.ALWAYS, 1, 0x1);
            gl.stencilMask(0x1);
        }
        else if( _library_utilities_settings__WEBPACK_IMPORTED_MODULE_1__.settings.stencilBufferBitSize === 8 )
        {
            gl.stencilFunc(gl.ALWAYS, 1, 0xFF);
            gl.stencilMask(0xff);
        }
        
        // Cull the back face
        gl.frontFace(gl.CCW);
        gl.cullFace(gl.BACK);
        gl.enable(gl.CULL_FACE);
        
        // Enable alpha blending
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

        // Make the zero texture the active texture
        gl.activeTexture(gl.TEXTURE0);
        
        // Init the clear buffer mask
        if( _library_utilities_settings__WEBPACK_IMPORTED_MODULE_1__.settings.clearTargetBuffer )
            this.clearBufferMask |= gl.COLOR_BUFFER_BIT;

        if( _library_utilities_settings__WEBPACK_IMPORTED_MODULE_1__.settings.enableDepthBuffer )
            this.clearBufferMask |= gl.DEPTH_BUFFER_BIT;

        if( _library_utilities_settings__WEBPACK_IMPORTED_MODULE_1__.settings.clearStencilBuffer )
            this.clearBufferMask |= gl.STENCIL_BUFFER_BIT;
        
        gl.clear( this.clearBufferMask );
        
        // Create the startup state
        this.gameState = new _state_testarenastate__WEBPACK_IMPORTED_MODULE_5__.TestArenaState( this.gameLoop.bind(this) );
    }
    
    // 
    //  DESC: Callback for shader init
    //
    initShaderCallBack( shaderId )
    {
        _library_managers_shadermanager__WEBPACK_IMPORTED_MODULE_4__.shaderManager.setShaderValue4fv( shaderId, 'additive', [1,1,1,1] );
    }
    
    // 
    //  DESC: Handle the state change
    //
    doStateChange()
    {
        return false;
    }
    
    //
    //  DESC: Poll for game events
    //
    pollEvents()
    {
        let event = null;
        
        // Handle events on the queue
        while( (event = _library_managers_eventmanager__WEBPACK_IMPORTED_MODULE_7__.eventManager.pollEvent()) )
            this.handleEvent( event );
    }
    
    // 
    //  DESC: Handle events
    //
    handleEvent( event )
    {
        this.gameState.handleEvent( event );
    }
    
    // 
    //  DESC: Main game loop
    //
    gameLoop()
    {
        // Break out of the game loop if the 
        // state needs to do some loading
        if( this.doStateChange() )
            return;
        
        // Poll the events
        this.pollEvents();
        
        // Get our elapsed time
        _library_utilities_highresolutiontimer__WEBPACK_IMPORTED_MODULE_8__.highResTimer.calcElapsedTime();
        
        // Handle the physics
        this.gameState.physics();
        
        // Update animations, Move sprites, Check for collision
        this.gameState.update();

        // Transform game objects
        this.gameState.transform();

        // Clear the back buffer
        _library_system_device__WEBPACK_IMPORTED_MODULE_6__.device.gl.clear( this.clearBufferMask );
        
        // Do the rendering
        this.gameState.render();
        
        // Apparently it's a good practice to do this at the end of a render cycle
        _library_managers_shadermanager__WEBPACK_IMPORTED_MODULE_4__.shaderManager.unbind();
        _library_managers_texturemanager__WEBPACK_IMPORTED_MODULE_2__.textureManager.unbind();
        _library_managers_vertexbuffermanager__WEBPACK_IMPORTED_MODULE_3__.vertexBufferManager.unbind();

        // Continues the loop
        requestAnimationFrame( this.gameLoop.bind(this) );
    }
}


/***/ }),
/* 2 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "signalManager": () => (/* binding */ signalManager)
/* harmony export */ });

// 
//  FILE NAME: signalmanager.js
//  DESC:      Class for handling messaging
//



class SignalManager
{
    constructor()
    {
        this.loadCompleteSignal = [];
        this.resolutionChangeSignal = [];
        this.initShaderSignal = [];
    }
    
    // 
    //  DESC: Connect to the load signal
    //
    connect_loadComplete( slot )
    {
        this.loadCompleteSignal.push( slot );
    }
    
    // 
    //  DESC: Connect to the resolution change signal
    //
    connect_resolutionChange( slot )
    {
        this.resolutionChangeSignal.push( slot );
    }

    // 
    //  DESC: Connect to the init shader signal
    //
    connect_initShader( slot )
    {
        this.initShaderSignal.push( slot );
    }

    // 
    //  DESC: Disconnect all to the load signal
    //
    clear_loadComplete()
    {
        this.loadCompleteSignal = [];
    }

    // 
    //  DESC: Disconnect all to resolution change
    //
    clear_resolutionChange()
    {
        this.resolutionChangeSignal = [];
    }

    // 
    //  DESC: Disconnect all to init shader
    //
    clear_initShader()
    {
        this.initShaderSignal = [];
    }
    
    // 
    //  DESC: Broadcast the load signal
    //
    broadcast_loadComplete()
    {
        for( let i = 0; i < this.loadCompleteSignal.length; ++i )
            this.loadCompleteSignal[i]();
    }
    
    // 
    //  DESC: Broadcast the resolution change
    //
    broadcast_resolutionChange()
    {
        for( let i = 0; i < this.resolutionChangeSignal.length; ++i )
            this.resolutionChangeSignal[i]();
    }

    // 
    //  DESC: Broadcast the init shader
    //
    broadcast_initShader( shaderId )
    {
        for( let i = 0; i < this.initShaderSignal.length; ++i )
            this.initShaderSignal[i](shaderId);
    }
}

var signalManager = new SignalManager;


/***/ }),
/* 3 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "settings": () => (/* binding */ settings)
/* harmony export */ });
/* harmony import */ var _common_size__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _utilities_localstorage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var _common_defs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6);

// 
//  FILE NAME: settings.js
//  DESC:      game settings singleton class
//






class Settings
{
    constructor()
    {
        this.size = new _common_size__WEBPACK_IMPORTED_MODULE_0__.Size(853, 480);
        this.initialSize = new _common_size__WEBPACK_IMPORTED_MODULE_0__.Size(this.size.w, this.size.h);
        this.size_half = new _common_size__WEBPACK_IMPORTED_MODULE_0__.Size;
        this.nativeSize = new _common_size__WEBPACK_IMPORTED_MODULE_0__.Size(1280, 720);
        this.nativeSize_half = new _common_size__WEBPACK_IMPORTED_MODULE_0__.Size;
        this.screenAspectRatio = new _common_size__WEBPACK_IMPORTED_MODULE_0__.Size;
        this.orthoAspectRatio = new _common_size__WEBPACK_IMPORTED_MODULE_0__.Size;
        this.defaultSize = new _common_size__WEBPACK_IMPORTED_MODULE_0__.Size(0, this.nativeSize.h);
        this.defaultSize_half = new _common_size__WEBPACK_IMPORTED_MODULE_0__.Size;
        
        this.enableDepthBuffer = false;
        this.createStencilBuffer = false;
        this.clearStencilBuffer = false;
        this.stencilBufferBitSize = 1;
        this.clearTargetBuffer = true;
        this.projectionType = _common_defs__WEBPACK_IMPORTED_MODULE_2__.EPT_ORTHOGRAPHIC;
        this.viewAngle = 45.0 * _common_defs__WEBPACK_IMPORTED_MODULE_2__.DEG_TO_RAD;
        this.minZdist = 5.0;
        this.maxZdist = 1000.5;

        this.allowGamepad = false;

        this.gameName = "Unnamed Game";
        this.gameId = "unnamedgame";

        this.user = {
            "stickDeadZone": 0.1,
            "soundEnabled": 1 };

        // Calculate the ratios
        this.calcRatio();
    }

    // 
    //  DESC: Load the Obj data
    //
    loadUserSettingsFromObj( obj )
    {
        if( obj )
        {
            this.user = obj;
            let savedUserSettings = _utilities_localstorage__WEBPACK_IMPORTED_MODULE_1__.localStorage.get( 'userSettings' );
            if( savedUserSettings )
                this.user = JSON.parse( savedUserSettings );
        }
    }

    // 
    //  DESC: Load the Obj data
    //
    loadFromObj( obj )
    {
        if( obj.display )
        {
            if( obj.display.resolution )
            {
                this.size.set( obj.display.resolution.width, obj.display.resolution.height );
                this.initialSize.set( this.size.w, this.size.h );
            }

            if( obj.display.default )
            {
                this.nativeSize.set( obj.display.default.width, obj.display.default.height );
                this.nativeSize_half.w = this.nativeSize.w / 2;
                this.nativeSize_half.h = this.nativeSize.h / 2;
                this.defaultSize.h = this.nativeSize.h;
            }
        }

        if( obj.device )
        {
            if( obj.device.projection )
            {
                if( obj.device.projection.projectType === 'perspective' )
                    this.projectionType = _common_defs__WEBPACK_IMPORTED_MODULE_2__.EPT_PERSPECTIVE;

                if( obj.device.projection.minZDist )
                    this.minZdist = obj.device.projection.minZDist;

                if( obj.device.projection.maxZDist )
                    this.maxZdist = obj.device.projection.maxZDist;

                if( obj.device.projection.viewAngle )
                    this.viewAngle = obj.device.projection.viewAngle * _common_defs__WEBPACK_IMPORTED_MODULE_2__.DEG_TO_RAD;
            }

            if( obj.device.depthStencilBuffer )
            {
                if( obj.device.depthStencilBuffer.enableDepthBuffer )
                    this.enableDepthBuffer = (obj.device.depthStencilBuffer.enableDepthBuffer === 'true');

                if( obj.device.depthStencilBuffer.createStencilBuffer )
                    this.createStencilBuffer = (obj.device.depthStencilBuffer.createStencilBuffer === 'true');

                if( obj.device.depthStencilBuffer.clearStencilBuffer )
                    this.clearStencilBuffer = (obj.device.depthStencilBuffer.clearStencilBuffer === 'true');

                if( obj.device.depthStencilBuffer.stencilBufferBitSize )
                    this.stencilBufferBitSize = obj.device.depthStencilBuffer.stencilBufferBitSize;
            }

            if( obj.device.targetBuffer )
            {
                if( obj.device.targetBuffer.clear )
                    this.clearTargetBuffer = (obj.device.targetBuffer.clear === 'true');
            }

            if( obj.device.gamepad )
            {
                if( obj.device.gamepad.allow )
                    this.allowGamepad = (obj.device.gamepad.allow === 'true');

                if( obj.device.gamepad.stickDeadZone )
                    this.stickDeadZone = obj.device.gamepad.stickDeadZone;
            }
        }

        if( obj.game )
        {
            if( obj.game.name )
                this.gameName = obj.game.name;
            
            if( obj.game.id )
                this.gameId = obj.game.id;
        }

        // Calculate the ratios
        this.calcRatio();
    }
    
    // 
    //  DESC: Calculate the ratios
    //
    calcRatio()
    {
        // Height and width screen ratio for perspective projection
        this.screenAspectRatio.w = this.size.w / this.size.h;
        this.screenAspectRatio.h = this.size.h / this.size.w;
        
        // NOTE: The default width is based on the current aspect ratio
        // NOTE: Make sure the width does not have a floating point component
        this.defaultSize.w = Math.floor((this.screenAspectRatio.w * this.defaultSize.h) + 0.5);
        
        // Get half the size for use with screen boundries
        this.defaultSize_half.w = this.defaultSize.w / 2;
        this.defaultSize_half.h = this.defaultSize.h / 2;

        // Screen size devided by two
        this.size_half.w = this.size.w / 2;
        this.size_half.h = this.size.h / 2;
        
        // Precalculate the aspect ratios for orthographic projection
        this.orthoAspectRatio.h = this.size.h / this.defaultSize.h;
        this.orthoAspectRatio.w = this.size.w / this.defaultSize.w;
    }
}

var settings = new Settings;


/***/ }),
/* 4 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Size": () => (/* binding */ Size)
/* harmony export */ });

// 
//  FILE NAME:  size.js
//  DESC:       size class
//



class Size
{
    constructor( w = 0, h = 0 )
    {
        this.w = w;
        this.h = h;
    }
    
    // 
    //  Copy the data
    //
    copy( obj )
    {
        this.w = obj.w;
        this.h = obj.h;
    }
    
    // 
    //  Set the size data
    //
    set( w = 0, h = 0 )
    {
        this.w = w;
        this.h = h;
    }
    
    // 
    //  DESC: Reset the data
    //
    reset()
    {
        this.w = 0;
        this.h = 0;
    }
    
    // 
    //  DESC: Does this size not have any data?
    //
    isEmpty()
    {
        if( (this.w == 0) && (this.h == 0) )
            return true;
        
        return false;
    }
    
    // 
    //  DESC: Round out the floating point number
    //
    round()
    {
        this.w = Math.round(this.w);
        this.h = Math.round(this.h);
    }

    // 
    //  DESC: Return a value for this class that can be compared
    //
    valueOf()
    {
        return Number(`${Math.trunc(this.w)}${Math.trunc(this.h)}`);
    }
    
    // 
    //  DESC: Access members as UV data
    //
    set u(value) { this.w = value; }
    get u() { return this.w; }
    
    set v(value) { this.h = value; }
    get v() { return this.h; }
}


/***/ }),
/* 5 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "localStorage": () => (/* binding */ localStorage)
/* harmony export */ });
/* harmony import */ var _utilities_settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);

// 
//  FILE NAME: localstorage.js
//  DESC:      local storage class
//





class LocalStorage
{
    constructor()
    {
        this.storage = null;

        try
        {
            this.storage = window.localStorage;
            const key = 'storage_test';
            const value = 'This is a test.';

            // Test that storage works
            this.storage.setItem( key, value );

            if( this.storage.getItem( key ) === value )
            {
                this.storage.removeItem( key );
                console.log('Local storage available.');
            }
            else
            {
                this.storage = {}; // Dummy storage if storage is not available
                console.log('Local storage NOT available.');
            }
        }
        catch (e)
        {
            console.log( `Local storage error: ${e}` );
            this.storage = {}; // Dummy storage if storage is not available
        }
    }

    // 
    //  DESC: Set the data to the storage object
    //
    set( key, value )
    {
        try
        {
            if( this.storage )
                this.storage.setItem( `${_utilities_settings__WEBPACK_IMPORTED_MODULE_0__.settings.gameId}_${key}`, value );
            else
                this.storage['key'] = value;
        }
        catch (e)
        {
            console.log( `Local storage set error: ${e}` );
        }
    }

    // 
    //  DESC: Get the data from the storage object
    //
    get( key )
    {
        try
        {
            if( this.storage )
                return this.storage.getItem( `${_utilities_settings__WEBPACK_IMPORTED_MODULE_0__.settings.gameId}_${key}` );
            else
                return this.storage['key'];
        }
        catch (e)
        {
            console.log( `Local storage get error: ${e}` );
        }
    }

    // 
    //  DESC: Free the data from the storage object
    //
    free( key )
    {
        try
        {
            if( this.storage )
                this.storage.removeItem( `${_utilities_settings__WEBPACK_IMPORTED_MODULE_0__.settings.gameId}_${key}` );
            else
                delete this.storage['key'];
        }
        catch (e)
        {
            console.log( `Local storage free error: ${e}` );
        }
    }

    // 
    //  DESC: Free the data from the storage object
    //
    clear()
    {
        try
        {
            if( this.storage )
                this.storage.clear();
            else
                this.storage = {};
        }
        catch (e)
        {
            console.log( `Local storage clear error: ${e}` );
        }
    }
}

var localStorage = new LocalStorage;

/***/ }),
/* 6 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DEG_TO_RAD": () => (/* binding */ DEG_TO_RAD),
/* harmony export */   "RAD_TO_DEG": () => (/* binding */ RAD_TO_DEG),
/* harmony export */   "EPSILON": () => (/* binding */ EPSILON),
/* harmony export */   "RGB_TO_DEC": () => (/* binding */ RGB_TO_DEC),
/* harmony export */   "M_PI": () => (/* binding */ M_PI),
/* harmony export */   "M_PI_2": () => (/* binding */ M_PI_2),
/* harmony export */   "M_PI_4": () => (/* binding */ M_PI_4),
/* harmony export */   "M_1_PI": () => (/* binding */ M_1_PI),
/* harmony export */   "M_2_PI": () => (/* binding */ M_2_PI),
/* harmony export */   "M_2_SQRTPI": () => (/* binding */ M_2_SQRTPI),
/* harmony export */   "M_SQRT2": () => (/* binding */ M_SQRT2),
/* harmony export */   "M_SQRT1_2": () => (/* binding */ M_SQRT1_2),
/* harmony export */   "DEFAULT_ID": () => (/* binding */ DEFAULT_ID),
/* harmony export */   "RESET_VELOCITY": () => (/* binding */ RESET_VELOCITY),
/* harmony export */   "EGT_NULL": () => (/* binding */ EGT_NULL),
/* harmony export */   "EGT_QUAD": () => (/* binding */ EGT_QUAD),
/* harmony export */   "EGT_SPRITE_SHEET": () => (/* binding */ EGT_SPRITE_SHEET),
/* harmony export */   "EGT_SCALED_FRAME": () => (/* binding */ EGT_SCALED_FRAME),
/* harmony export */   "EGT_MESH_FILE": () => (/* binding */ EGT_MESH_FILE),
/* harmony export */   "EGT_FONT": () => (/* binding */ EGT_FONT),
/* harmony export */   "EPT_NULL": () => (/* binding */ EPT_NULL),
/* harmony export */   "EPT_PERSPECTIVE": () => (/* binding */ EPT_PERSPECTIVE),
/* harmony export */   "EPT_ORTHOGRAPHIC": () => (/* binding */ EPT_ORTHOGRAPHIC),
/* harmony export */   "EHA_HORZ_LEFT": () => (/* binding */ EHA_HORZ_LEFT),
/* harmony export */   "EHA_HORZ_CENTER": () => (/* binding */ EHA_HORZ_CENTER),
/* harmony export */   "EHA_HORZ_RIGHT": () => (/* binding */ EHA_HORZ_RIGHT),
/* harmony export */   "EVA_VERT_TOP": () => (/* binding */ EVA_VERT_TOP),
/* harmony export */   "EVA_VERT_CENTER": () => (/* binding */ EVA_VERT_CENTER),
/* harmony export */   "EVA_VERT_BOTTOM": () => (/* binding */ EVA_VERT_BOTTOM),
/* harmony export */   "CHAR_CODE_SPACE": () => (/* binding */ CHAR_CODE_SPACE),
/* harmony export */   "CHAR_CODE_PIPE": () => (/* binding */ CHAR_CODE_PIPE),
/* harmony export */   "EAP_IDLE": () => (/* binding */ EAP_IDLE),
/* harmony export */   "EAP_DOWN": () => (/* binding */ EAP_DOWN),
/* harmony export */   "EAP_UP": () => (/* binding */ EAP_UP),
/* harmony export */   "DEVICE_NULL": () => (/* binding */ DEVICE_NULL),
/* harmony export */   "KEYBOARD": () => (/* binding */ KEYBOARD),
/* harmony export */   "MOUSE": () => (/* binding */ MOUSE),
/* harmony export */   "GAMEPAD": () => (/* binding */ GAMEPAD),
/* harmony export */   "TRANSLATE": () => (/* binding */ TRANSLATE),
/* harmony export */   "ROTATE": () => (/* binding */ ROTATE),
/* harmony export */   "SCALE": () => (/* binding */ SCALE),
/* harmony export */   "CENTER_POINT": () => (/* binding */ CENTER_POINT),
/* harmony export */   "CROP_OFFSET": () => (/* binding */ CROP_OFFSET),
/* harmony export */   "TRANSFORM": () => (/* binding */ TRANSFORM),
/* harmony export */   "WAS_TRANSFORMED": () => (/* binding */ WAS_TRANSFORMED),
/* harmony export */   "MATRIX_ROTATION": () => (/* binding */ MATRIX_ROTATION),
/* harmony export */   "VISIBLE": () => (/* binding */ VISIBLE),
/* harmony export */   "ENT_NULL": () => (/* binding */ ENT_NULL),
/* harmony export */   "ENT_OBJECT": () => (/* binding */ ENT_OBJECT),
/* harmony export */   "ENT_SPRITE": () => (/* binding */ ENT_SPRITE),
/* harmony export */   "ENT_UI_CONTROL": () => (/* binding */ ENT_UI_CONTROL),
/* harmony export */   "ESMA_PRESS_TYPE": () => (/* binding */ ESMA_PRESS_TYPE),
/* harmony export */   "ESMA_DEVICE_TYPE": () => (/* binding */ ESMA_DEVICE_TYPE),
/* harmony export */   "ESMA_MOUSE_X": () => (/* binding */ ESMA_MOUSE_X),
/* harmony export */   "ESMA_MOUSE_Y": () => (/* binding */ ESMA_MOUSE_Y),
/* harmony export */   "EMSC_STATE": () => (/* binding */ EMSC_STATE),
/* harmony export */   "EMSC_CONTROL": () => (/* binding */ EMSC_CONTROL),
/* harmony export */   "EDO_NULL": () => (/* binding */ EDO_NULL),
/* harmony export */   "EDO_LEFT": () => (/* binding */ EDO_LEFT),
/* harmony export */   "EDO_RIGHT": () => (/* binding */ EDO_RIGHT),
/* harmony export */   "EDO_HORZ_CENTER": () => (/* binding */ EDO_HORZ_CENTER),
/* harmony export */   "EDO_TOP": () => (/* binding */ EDO_TOP),
/* harmony export */   "EDO_BOTTOM": () => (/* binding */ EDO_BOTTOM),
/* harmony export */   "EDO_VERT_CENTER": () => (/* binding */ EDO_VERT_CENTER),
/* harmony export */   "ENAV_NODE_UP": () => (/* binding */ ENAV_NODE_UP),
/* harmony export */   "ENAV_NODE_DOWN": () => (/* binding */ ENAV_NODE_DOWN),
/* harmony export */   "ENAV_NODE_LEFT": () => (/* binding */ ENAV_NODE_LEFT),
/* harmony export */   "ENAV_NODE_RIGHT": () => (/* binding */ ENAV_NODE_RIGHT),
/* harmony export */   "TOGGLE_STATE_ON": () => (/* binding */ TOGGLE_STATE_ON),
/* harmony export */   "TOGGLE_STATE_OFF": () => (/* binding */ TOGGLE_STATE_OFF),
/* harmony export */   "NO_ACTIVE_CONTROL": () => (/* binding */ NO_ACTIVE_CONTROL),
/* harmony export */   "ECSF_ON_ACTIVE": () => (/* binding */ ECSF_ON_ACTIVE),
/* harmony export */   "ECSF_ON_SELECTED": () => (/* binding */ ECSF_ON_SELECTED),
/* harmony export */   "EO_HORIZONTAL": () => (/* binding */ EO_HORIZONTAL),
/* harmony export */   "EO_VERTICAL": () => (/* binding */ EO_VERTICAL),
/* harmony export */   "EM_NULL": () => (/* binding */ EM_NULL),
/* harmony export */   "EM_HORIZONTAL": () => (/* binding */ EM_HORIZONTAL),
/* harmony export */   "EM_VERTICAL": () => (/* binding */ EM_VERTICAL),
/* harmony export */   "EM_HORIZONTAL_VERTICAL": () => (/* binding */ EM_HORIZONTAL_VERTICAL)
/* harmony export */ });

// 
//  FILE NAME: defs.js
//  DESC:      misc defines
//



const DEG_TO_RAD = 0.0174532925199432957,
             RAD_TO_DEG = 57.29577951308232,
             EPSILON    = 8.854187817e-12,
             RGB_TO_DEC = 0.00390625,
             M_PI       = 3.14159265358979323846, // pi
             M_PI_2     = 1.57079632679489661923, // pi/2
             M_PI_4     = 0.78539816339744830962, // pi/4
             M_1_PI     = 0.31830988618379067154, // 1/pi
             M_2_PI     = 0.63661977236758134308, // 2/pi
             M_2_SQRTPI = 1.12837916709551257390, // 2/sqrt(pi)
             M_SQRT2    = 1.41421356237309504880, // sqrt(2)
             M_SQRT1_2  = 0.70710678118654752440; // 1/sqrt(2)
     
const DEFAULT_ID = -1;

const RESET_VELOCITY = true;

// EGenerationType
const EGT_NULL         = 0,
             EGT_QUAD         = 1,
             EGT_SPRITE_SHEET = 2,
             EGT_SCALED_FRAME = 3,
             EGT_MESH_FILE    = 4,
             EGT_FONT         = 5;

// EProjectionType
const EPT_NULL         = 0,
             EPT_PERSPECTIVE  = 1,
             EPT_ORTHOGRAPHIC = 2;

// EHorzAlignment
const EHA_HORZ_LEFT    = 0,
             EHA_HORZ_CENTER  = 1,
             EHA_HORZ_RIGHT   = 2;

// EVertAlignment
const EVA_VERT_TOP     = 0,
             EVA_VERT_CENTER  = 1,
             EVA_VERT_BOTTOM  = 2;

// Character codes
const CHAR_CODE_SPACE = 32,
             CHAR_CODE_PIPE  = 124;

// EActionPress
const EAP_IDLE = 0,
             EAP_DOWN = 1,
             EAP_UP   = 2;

// EDeviceId
const DEVICE_NULL = -1,
             KEYBOARD    = 0,
             MOUSE       = 1,
             GAMEPAD     = 2;

// Sprite transform Bitmask

// Transform parameters
const TRANSLATE	  = 0x01,
             ROTATE       = 0x02,
             SCALE        = 0x04,
             CENTER_POINT = 0x08,
             CROP_OFFSET  = 0x10;

// Translate parameters
const TRANSFORM       = 0x20,
             WAS_TRANSFORMED = 0x40;

// Matrix rotation
const MATRIX_ROTATION = 0x80;

// Visible bit
const VISIBLE         = 0x100;
     
// ENodeType
const ENT_NULL       = 0,
             ENT_OBJECT     = 1,
             ENT_SPRITE     = 2,
             ENT_UI_CONTROL = 3;

// ESelection Message Arguments
const ESMA_PRESS_TYPE  = 0,
             ESMA_DEVICE_TYPE = 1,
             ESMA_MOUSE_X     = 2,
             ESMA_MOUSE_Y     = 3;

// EMenu State Change Arguments
const EMSC_STATE   = 0,
             EMSC_CONTROL = 1;

// EDynamicOffset
const EDO_NULL        = 0,
             EDO_LEFT        = 1,
             EDO_RIGHT       = 2,
             EDO_HORZ_CENTER = 4,
             EDO_TOP         = 8,
             EDO_BOTTOM      = 16,
             EDO_VERT_CENTER = 32;

// ENavNode
const ENAV_NODE_UP    = 0,
             ENAV_NODE_DOWN  = 1,
             ENAV_NODE_LEFT  = 2,
             ENAV_NODE_RIGHT = 3;

const TOGGLE_STATE_ON  = true,
             TOGGLE_STATE_OFF = false;

// Value for no active control
const NO_ACTIVE_CONTROL = -1;

// EControlScriptFunctions
const ECSF_ON_ACTIVE   = 0,
             ECSF_ON_SELECTED = 1;

// EOrientation
const EO_HORIZONTAL = 0,
             EO_VERTICAL   = 1;
     
// EMirror
const EM_NULL                = 0,
             EM_HORIZONTAL          = 1,
             EM_VERTICAL            = 2,
             EM_HORIZONTAL_VERTICAL = 3;
     

/***/ }),
/* 7 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "textureManager": () => (/* binding */ textureManager)
/* harmony export */ });
/* harmony import */ var _common_texture__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(8);
/* harmony import */ var _system_device__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);

//
//  FILE NAME: texturemanager.js
//  DESC:      texture class singleton
//





class TextureManager
{
    constructor()
    {
        // Map containing a group of texture handles
        this.textureForMapMap = new Map;

        // Current texture
        this.currentTexture = null;
    }

    //
    //  DESC: Load the image file as a texture
    //
    load( group, filePath, image )
    {
        let gl = _system_device__WEBPACK_IMPORTED_MODULE_1__.device.gl;

        if( !image.complete )
            throw new Error( `Image file not completely loaded! (${group}, ${filePath}).` );

        // Create the group map if it doesn't already exist
        let groupMap = this.textureForMapMap.get( group );
        if( groupMap === undefined )
        {
            groupMap = new Map;
            this.textureForMapMap.set( group, groupMap );
        }

        let texture = groupMap.get( filePath );
        if( texture === undefined || texture === -1 )
        {
            texture = new _common_texture__WEBPACK_IMPORTED_MODULE_0__.Texture;
            texture.id = gl.createTexture();
            texture.size.w = image.width;
            texture.size.h = image.height;

            gl.bindTexture( gl.TEXTURE_2D, texture.id );
            gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
            gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
            gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR );
            gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR );
            gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image );
            gl.bindTexture( gl.TEXTURE_2D, null );

            groupMap.set( filePath, texture );
        }
        
        return texture;
    }

    // 
    //  DESC: Set a place holder that this data is scheduled to be loaded
    //
    allowLoad( group, filePath )
    {
        let groupMap = this.textureForMapMap.get( group );
        if( groupMap === undefined )
        {
            groupMap = new Map;
            this.textureForMapMap.set( group, groupMap );
        }
        
        let texture = groupMap.get( filePath );
        if( texture === undefined )
        {
            // Add an entry to the map as a 
            // place holder for future checks
            groupMap.set( filePath, -1 );

            return true;
        }

        return false;
    }

    //
    //  DESC: Delete the group of textures
    //
    deleteGroup( group )
    {
        let groupMap = this.textureForMapMap.get( group );
        if( groupMap !== undefined )
        {
            let gl = _system_device__WEBPACK_IMPORTED_MODULE_1__.device.gl;

            for( let texture of groupMap.values() )
                gl.deleteTexture( texture.id );
            
            this.textureForMapMap.delete( group );
        }
    }

    //
    //  DESC: Get the 2D texture class
    //
    get( group, filePath )
    {
        let groupMap = this.textureForMapMap.get( group );
        if( groupMap === undefined )
            throw new Error( `Texture group does not exists! (${group}, ${filePath}).` );

        let texture = groupMap.get( filePath );
        if( texture === undefined || texture === -1 )
            throw new Error( `Texture does not exists! (${group}, ${filePath}).` );
        
        return texture;
    }

    //
    //  DESC: Create OpenGL objects from data
    //
    bind( textureId )
    {
        if( this.currentTexture != textureId )
        {
            let gl = _system_device__WEBPACK_IMPORTED_MODULE_1__.device.gl;

            // save the current binding
            this.currentTexture = textureId;

            // Have OpenGL bind this texture now
            gl.bindTexture(gl.TEXTURE_2D, textureId);
        }
    }

    //
    //  DESC: Unbind the texture and reset the flag
    //
    unbind()
    {
        let gl = _system_device__WEBPACK_IMPORTED_MODULE_1__.device.gl;
        
        this.currentTexture = null;
        gl.bindTexture(gl.TEXTURE_2D, null);
    }
}

var textureManager = new TextureManager;


/***/ }),
/* 8 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Texture": () => (/* binding */ Texture)
/* harmony export */ });
/* harmony import */ var _size__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);

//
//  FILE NAME: texture.js
//  DESC:      Class for holding texture data
//





class Texture
{
    constructor()
    {
        // OpenGL texture ID
        this.id = 0;
        
        // Texture type (diffuse, normal, specular, displacement, etc)
        this.type = 0;

        // Texture size - mostly needed for 2D
        this.size = new _size__WEBPACK_IMPORTED_MODULE_0__.Size;
    }
}


/***/ }),
/* 9 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "device": () => (/* binding */ device)
/* harmony export */ });
/* harmony import */ var _utilities_settings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
/* harmony import */ var _managers_cameramanager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);
/* harmony import */ var _gui_menumanager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(24);

// 
//  FILE NAME: device.js
//  DESC:      Singleton class used for openGL management
//







class Device
{
    constructor()
    {
        this._canvas = null;
        this._glContext = null;
    }
    
    // 
    //  DESC: Create the OpenGL context
    //
    create()
    {
        let parm = {premultipliedAlpha: false, alpha: false, stencil:true, preserveDrawingBuffer: true};
        
        document.body.style.width = `${_utilities_settings__WEBPACK_IMPORTED_MODULE_0__.settings.size.w}px`;
        document.body.style.height = `${_utilities_settings__WEBPACK_IMPORTED_MODULE_0__.settings.size.h}px`;
        this._canvas = document.getElementById('game-surface');
        this._canvas.width = _utilities_settings__WEBPACK_IMPORTED_MODULE_0__.settings.size.w;
        this._canvas.height = _utilities_settings__WEBPACK_IMPORTED_MODULE_0__.settings.size.h;

        this._glContext =
            this._canvas.getContext('webgl2', parm) ||
            this._canvas.getContext('webgl', parm) ||
            this._canvas.getContext('experimental-webgl', parm);
        
        if( !this._glContext )
            alert('Your browser does not support WebGL');

        return this._glContext;
    }

    //
    //  DESC: Handle the resolution change
    //
    handleResolutionChange( width, height )
    {
        _utilities_settings__WEBPACK_IMPORTED_MODULE_0__.settings.size.set( width, height );
        _utilities_settings__WEBPACK_IMPORTED_MODULE_0__.settings.calcRatio();
        _gui_menumanager__WEBPACK_IMPORTED_MODULE_2__.menuManager.resetTransform();
        _gui_menumanager__WEBPACK_IMPORTED_MODULE_2__.menuManager.resetDynamicOffset();
        _managers_cameramanager__WEBPACK_IMPORTED_MODULE_1__.cameraManager.rebuild();
        this._canvas.width = width
        this._canvas.height = height;
        this._glContext.viewport(0, 0, width, height);
        //console.log( `Canvas size: ${width} x ${height}; DPR: ${window.devicePixelRatio}` );
    }

    // 
    //  DESC: Get the canvas
    //
    get canvas()
    {
        return this._canvas;
    }

    // 
    //  DESC: Create the OpenGL context
    //
    get gl()
    {
        return this._glContext;
    }
}

var device = new Device;


/***/ }),
/* 10 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "cameraManager": () => (/* binding */ cameraManager)
/* harmony export */ });
/* harmony import */ var _common_camera__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11);

// 
//  FILE NAME: cameramanager.js
//  DESC:      CameraManager class
//





class CameraManager
{
    constructor()
    {        
        // Camera map
        this.cameraMap = new Map;
        
        // Transform array
        this.transformAry = [];

        // The default camera
        this.defaultCamera = null;
    }
    
    // 
    //  DESC: Load the camera data from node
    //
    loadFromNode( xmlNode )
    {
        if( xmlNode )
        {
            this.defaultCamera = new _common_camera__WEBPACK_IMPORTED_MODULE_0__.Camera();

            // Get the default camera
            let defCamera = xmlNode.getElementsByTagName('default');

            // Init the default camera
            if( defCamera.length )
            {
                this.defaultCamera.initFromXml( defCamera[0] );
            }
            else
            {
                this.defaultCamera.setPosXYZ( 0, 0, 100 );
            }
            
            let cameraLst = xmlNode.getElementsByTagName('camera');
            for( let i = 0; i < cameraLst.length; ++i )
            {
                let id = cameraLst[i].getAttribute('id');

                if( id == null )
                    throw new Error( `Camera does not have a id!` );

                // Check for duplicate Id's
                if( this.cameraMap.has( id ) )
                    throw new Error( `Duplicate camera id (${id})!` );

                // Create camera and init
                let camera = new _common_camera__WEBPACK_IMPORTED_MODULE_0__.Camera();
                camera.initFromXml( cameraLst[i] );

                this.cameraMap.set( id, camera );
            }
        }
    }
    
    // 
    //  DESC: Get the default camera
    //
    getDefault()
    {
        return this.defaultCamera;
    }
    
    // 
    //  DESC: Get the camera
    //
    get( cameraId )
    {
        if( !this.cameraMap.has( cameraId ) )
        {
            console.log( `Camera id is not defined (${cameraId})! Using default camera instead.` );
            return this.defaultCamera;
        }
        
        return this.cameraMap.get( cameraId );
    }
    
    // 
    //  DESC: Add camera to the transform array
    //
    addToTransform( cameraId )
    {
        let camera = this.cameraMap.get( cameraId );
        if( camera )
        {
            let index = this.transformAry.findIndex( (obj) => obj === camera );
            if( index !== -1 )
                console.log( `Camera is already being transformed (${cameraId})!` );
            else
                this.transformAry.push( camera );
        }
        else
            throw new Error( `Camera id is not defined (${cameraId})!` );
    }
    
    // 
    //  DESC: Remove camera from the transform array
    //
    removeFromTransform( cameraId )
    {
        let camera = this.cameraMap.get( cameraId );
        if( camera )
        {
            let index = this.transformAry.findIndex( (obj) => obj === camera );
            if( index === -1 )
                console.log( `Camera is not being transformed (${cameraId})!` );
            else
                this.transformAry.splice(index, 1);
        }
        else
            throw new Error( `Camera id is not defined (${cameraId})!` );
    }
    
    //
    //  DESC: Transform the cameras
    //
    transform()
    {
        for( let i = 0; i < this.transformAry.length; i++ )
            this.transformAry[i].transform();
    }
    
    //
    //  DESC: Clear out all the cameras
    //
    clear()
    {
        this.defaultCamera = null;
        this.cameraMap = new Map;
        
        this.transformAry = [];
    }
    
    //
    //  DESC: Clear the transform array
    //
    clearTransAry()
    {
        this.transformAry = [];
    }

    //
    //  DESC: Rebuild all camera's projection matrixes
    //
    rebuild()
    {
        this.defaultCamera.setup();

        for( let camera of this.cameraMap.values() )
            camera.setup();
    }
}

var cameraManager = new CameraManager;



/***/ }),
/* 11 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Camera": () => (/* binding */ Camera)
/* harmony export */ });
/* harmony import */ var _utilities_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/* harmony import */ var _common_object__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13);
/* harmony import */ var _utilities_settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
/* harmony import */ var _defs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6);

// 
//  FILE NAME: camera.js
//  DESC:      class that holds the camera position and rotation
//








class Camera extends _common_object__WEBPACK_IMPORTED_MODULE_1__.Object
{
    constructor()
    {
        super();
        
        // Custom projection matrix
        this.projectionMatrix = new _utilities_matrix__WEBPACK_IMPORTED_MODULE_0__.Matrix;

        // Custom projection matrix
        this.finalMatrix = new _utilities_matrix__WEBPACK_IMPORTED_MODULE_0__.Matrix;

        // Matrix for rotations only, used for normal calculations
        this.rotMatrix = new _utilities_matrix__WEBPACK_IMPORTED_MODULE_0__.Matrix;
        
        this.projType = _utilities_settings__WEBPACK_IMPORTED_MODULE_2__.settings.projectionType;
        this.minZDist = _utilities_settings__WEBPACK_IMPORTED_MODULE_2__.settings.minZdist;
        this.maxZDist = _utilities_settings__WEBPACK_IMPORTED_MODULE_2__.settings.maxZdist;
        this.angle = _utilities_settings__WEBPACK_IMPORTED_MODULE_2__.settings.viewAngle;

        // Setup the camera
        this.setup();
    }
    
    //
    //  DESC: Init the camera from XML
    //
    initFromXml( xmlNode )
    {
        let attr = xmlNode.getAttribute('projectType');
        if( attr )
        {
            if( attr === 'orthographic' )
                this.projType = _defs__WEBPACK_IMPORTED_MODULE_3__.EPT_ORTHOGRAPHIC;
            else
                this.projType = _defs__WEBPACK_IMPORTED_MODULE_3__.EPT_PERSPECTIVE;
        }
        
        attr = xmlNode.getAttribute('minZDist');
        if( attr )
            this.minZDist = Number(attr);

        attr = xmlNode.getAttribute('maxZDist');
        if( attr )
            this.maxZDist = Number(attr);

        attr = xmlNode.getAttribute('view_angle');
        if( attr )
            this.angle = Number(attr) * _defs__WEBPACK_IMPORTED_MODULE_3__.DEG_TO_RAD;
        
        // Load the transform data from node
        this.loadTransFromNode( xmlNode );

        // Load the script functions from node
        this.scriptComponent.initScriptIds( xmlNode );
        
        // Setup the camera
        this.setup();

        // Prepare any script functions that are flagged to prepareOnInit
        this.scriptComponent.prepareOnInit( this );
    }
    
    //
    //  DESC: Create the projection matrix
    //
    init( projType, minZDist, maxZDist, angle )
    {
        this.projType = projType;
        this.minZDist = minZDist;
        this.maxZDist = maxZDist;
        this.angle = angle;
        
        // Setup the camera
        this.setup();
    }

    //
    //  DESC: Setup the camera
    //
    setup()
    {
        // Create the projection matrix
        this.createProjectionMatrix();
        
        // Do the initial transform
        super.transform();
        
        // Calculate the final matrix
        this.calcFinalMatrix();
    }
    
    //
    //  DESC: Create the projection matrix
    //
    createProjectionMatrix()
    {
        if( this.projType == _defs__WEBPACK_IMPORTED_MODULE_3__.EPT_PERSPECTIVE )
        {
            this.projectionMatrix.perspectiveFovRH(
                this.angle,
                _utilities_settings__WEBPACK_IMPORTED_MODULE_2__.settings.screenAspectRatio.w,
                this.minZDist,
                this.maxZDist );
        }
        else
        {
            this.projectionMatrix.orthographicRH(
                _utilities_settings__WEBPACK_IMPORTED_MODULE_2__.settings.defaultSize.w,
                _utilities_settings__WEBPACK_IMPORTED_MODULE_2__.settings.defaultSize.h,
                this.minZDist,
                this.maxZDist );
        }
    }
    
    //
    //  DESC: Set the object's position
    //
    setPos( pos )
    {
        super.setPosXYZ( -pos.x, -pos.y, -pos.z );
    }
    
    setPosXYZ( x = 0, y = 0, z = 0 )
    {
        super.setPosXYZ( -x, -y, -z );
    }
    
    incPos( pos )
    {
        super.incPosXYZ( -pos.x, -pos.y, -pos.z );
    }
    
    incPosXYZ( x = 0, y = 0, z = 0 )
    {
        super.incPosXYZ( -x, -y, -z );
    }
    
    //
    //  DESC: Transform
    //
    transform()
    {
        let wasTransformed = this.parameters.isSet( _defs__WEBPACK_IMPORTED_MODULE_3__.TRANSFORM );
    
        super.transform();

        if( wasTransformed )
            this.calcFinalMatrix();
    }
    
    //
    //  DESC: Calculate the final matrix
    //
    calcFinalMatrix()
    {
        this.finalMatrix.initilizeMatrix();
        this.finalMatrix.mergeMatrix( this.matrix.matrix );
        this.finalMatrix.mergeMatrix( this.projectionMatrix.matrix );
    }

    //
    //  DESC: Apply the rotation
    //
    applyRotation( matrix )
    {
        this.rotMatrix.initilizeMatrix();
        this.rotMatrix.rotate( this.rot );

        // Since the rotation has already been done, multiply it into the matrix
        matrix.multiply3x3( this.rotMatrix.matrix );
    }
}

/***/ }),
/* 12 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Matrix": () => (/* binding */ Matrix)
/* harmony export */ });

// 
//  FILE NAME:  matrix.js
//  DESC:       4x4 Matrix math class
//



const NO_ROT = 0;
const ROT_Z  = 1;
const ROT_Y  = 2;
const ROT_X  = 4;

// Global temp matrix to be reused so that an object
// specific one doesn't have to be created each time
var gTempMatrix = new Float32Array(16);
var gTempMergeMatrix = new Float32Array(16);
var gSwap = null;

class Matrix
{
    constructor( matrix = null )
    {
        this.matrix = new Float32Array(16);
        
        if( matrix === null )
            this.initilizeMatrix();
        else
            this.copy( matrix );
    }
    
    copy( obj )
    {
        let i = this.matrix.length;
        
        while( i-- )
            this.matrix[i] = obj.matrix[i];  
    }
    
    //
    //  DESC: Init the matrix to the identity matrix
    //
    initilizeMatrix()
    {
        this.initIdentityMatrix( this.matrix );
    }
    
    initIdentityMatrix( mat )
    {
        // Initializes a specific matrix to the identity matrix:
        mat[0]  = 1.0;   mat[1] = 0.0;   mat[2]  = 0.0;   mat[3] = 0.0;
        mat[4]  = 0.0;   mat[5] = 1.0;   mat[6]  = 0.0;   mat[7] = 0.0;
        mat[8]  = 0.0;   mat[9] = 0.0;   mat[10] = 1.0;  mat[11] = 0.0;
        mat[12] = 0.0;  mat[13] = 0.0;   mat[14] = 0.0;  mat[15] = 1.0;
    }
    
    //
    //  DESC: Merge matrix into master matrix
    //  
    mergeMatrix( matrix )
    {
        for( let i = 0; i < 4; ++i )
        {
            for( let j = 0; j < 4; ++j )
            { 
                gTempMergeMatrix[(i*4)+j] = (this.matrix[i*4] * matrix[j])
                + (this.matrix[(i*4)+1] * matrix[4+j])
                + (this.matrix[(i*4)+2] * matrix[8+j])
                + (this.matrix[(i*4)+3] * matrix[12+j]);
            }
        }

        // Swap matricies so that there's no garbage collection
        gSwap = this.matrix;
        this.matrix = gTempMergeMatrix;
        gTempMergeMatrix = gSwap;
    }
    
    //
    //  DESC: Generate 3D rotation matrix
    //
    rotate( point )
    {
        let flags = NO_ROT;
        
        // init the rotation matrix
        this.initIdentityMatrix( gTempMatrix );

        // Apply Z rotation
        if( !point.isZEmpty() )
        {
            this.rotateZRad( gTempMatrix, point.z, flags );
            flags |= ROT_Z;
        }

        // Apply Y rotation
        if( !point.isYEmpty() )
        {
            this.rotateYRad( gTempMatrix, point.y, flags );
            flags |= ROT_Y;
        }

        // Apply X rotation
        if( !point.isXEmpty() )
        {
            this.rotateXRad( gTempMatrix, point.x, flags );
            flags |= ROT_X;
        }

        // Merg the rotation into the master matrix
        this.mergeMatrix( gTempMatrix );
    }
     
    //
    //  DESC: Rotate the matrix along the z axis
    //
    rotateZRad( dest, value )
    {
        let cos = Math.cos(value);
        let sin = Math.sin(value);

        dest[0] = cos;
        dest[1] = sin;
        dest[4] = -sin;
        dest[5] = cos;
    }
 
    //
    //  DESC: Rotate the matrix along the y axis
    //
    rotateYRad( dest, value, rotFlags )
    {
        let cos = Math.cos(value);
        let sin = Math.sin(value);

        switch( rotFlags )
        {
            case ROT_Z:
            {
                let tmp0, tmp1, tmp8, tmp9;
                tmp0 = dest[0] * cos;
                tmp1 = dest[1] * cos;
                tmp8 = dest[0] * sin;
                tmp9 = dest[1] * sin;
                dest[0] = tmp0;
                dest[1] = tmp1;
                dest[2] = -sin;
                dest[8] = tmp8;
                dest[9] = tmp9;
                dest[10] = cos;
                break;
            }
            case NO_ROT:
            {
                dest[0]  =  cos;
                dest[2]  = -sin;
                dest[8]  =  sin;
                dest[10] =  cos;
                break;
            }
        }
    }
  
    //
    //  DESC: Rotate the matrix along the x axis
    //
    rotateXRad( dest, value, rotFlags )
    {
        let cos = Math.cos(value);
        let sin = Math.sin(value);

        switch( rotFlags )
        {
            case ROT_Z:
            {
                let tmp4, tmp5, tmp8, tmp9;
                tmp4 = dest[4] * cos;
                tmp5 = dest[5] * cos;
                tmp8 = dest[4] * -sin;
                tmp9 = dest[5] * -sin;
                dest[4] = tmp4;
                dest[5] = tmp5;
                dest[6] = sin;
                dest[8] = tmp8;
                dest[9] = tmp9;
                dest[10] = cos;
                break;
            }

            case ROT_Y:
            {
                let tmp4, tmp6, tmp8, tmp10;
                tmp4 = dest[8] * sin;
                tmp6 = dest[10] * sin;
                tmp8 = dest[8] * cos;
                tmp10 = dest[10] * cos;
                dest[4] = tmp4;
                dest[5] = cos;
                dest[6] = tmp6;
                dest[8] = tmp8;
                dest[9] = -sin;
                dest[10] = tmp10;
                break;
            }

            case ROT_Z | ROT_Y:
            {
                let tmp4, tmp5, tmp6, tmp8, tmp9, tmp10;
                tmp4 = ( dest[4] * cos ) + ( dest[8] * sin );
                tmp5 = ( dest[5] * cos ) + ( dest[9] * sin );
                tmp6 = dest[10] * sin;
                tmp8 = ( dest[4] * -sin ) + ( dest[8] * cos );
                tmp9 = ( dest[5] * -sin ) + ( dest[9] * cos );
                tmp10 = dest[10] * cos;
                dest[4] = tmp4;
                dest[5] = tmp5;
                dest[6] = tmp6;
                dest[8] = tmp8;
                dest[9] = tmp9;
                dest[10] = tmp10;
                break;
            }

            case NO_ROT:
            {
                dest[5]  =  cos;
                dest[6]  =  sin;
                dest[9]  = -sin;
                dest[10] =  cos;
                break;
            }
        }
    }
    
    //
    //  DESC: Translate the point
    //
    translate( point )
    {
        this.matrix[12] += point.x;
        this.matrix[13] += point.y;
        this.matrix[14] += point.z;
    }
    
    translateSize( size )
    {
        this.matrix[12] += size.w;
        this.matrix[13] += size.h;
    }
    
    //
    //  DESC: Transform the type
    //
    transformPoint( dest, source )
    {
        dest.x = ( source.x * this.matrix[ 0 ] )
               + ( source.y * this.matrix[ 4 ] )
               + ( source.z * this.matrix[ 8 ] )
               + this.matrix[ 12 ];

        dest.y = ( source.x * this.matrix[ 1 ] )
               + ( source.y * this.matrix[ 5 ] )
               + ( source.z * this.matrix[ 9 ] )
               + this.matrix[ 13 ];

        dest.z = ( source.x * this.matrix[ 2 ] )
               + ( source.y * this.matrix[ 6 ] )
               + ( source.z * this.matrix[ 10 ] )
               + this.matrix[ 14 ];
    }
    
    transformRect( dest, source )
    {
        // Transform vertex by master matrix:
        dest.x1 = ( source.x1 * this.matrix[ 0 ] )
                + ( source.y1 * this.matrix[ 4 ] )
                + this.matrix[ 12 ];

        dest.y1 = ( source.x1 * this.matrix[ 1 ] )
                + ( source.y1 * this.matrix[ 5 ] )
                + this.matrix[ 13 ];

        dest.x2 = ( source.x2 * this.matrix[ 0 ] )
                + ( source.y2 * this.matrix[ 4 ] )
                + this.matrix[ 12 ];

        dest.y2 = ( source.x2 * this.matrix[ 1 ] )
                + ( source.y2 * this.matrix[ 5 ] )
                + this.matrix[ 13 ];
    }
    
    transformQuad( dest, source )
    {
        for( let i = 0; i < 4; ++i )
            this.transformPoint( dest.point[i], source.point[i] );
    }
    
    //
    //  DESC: Set the scale to the master matrix
    //
    setScaleFromPoint( point )
    {
        // Initialize scaling matrix:
        this.matrix[0]  *= point.x;
        this.matrix[5]  *= point.y;
        this.matrix[10] *= point.z;
    }
    
    setScaleFromSize( size )
    {
        // Initialize scaling matrix:
        this.matrix[0]  *= size.w;
        this.matrix[5]  *= size.h;
        this.matrix[10] *= 1.0;
    }
    
    setScaleFromValue( scale )
    {
        // Initialize scaling matrix:
        this.matrix[0]  *= scale;
        this.matrix[5]  *= scale;
        this.matrix[10] *= 1.0;
    }
    
    //
    //  DESC: Set the scale to the master matrix
    //
    scaleFromPoint( point )
    {
        this.mergeScale( point.x, point.y, point.z );
    }
    
    scaleFromSize( size )
    {
        this.mergeScale( size.w, size.h, 1.0 );
    }
    
    scaleFromValue( scale )
    {
        this.mergeScale( scale, scale, scale );
    }
    
    //
    //  DESC: scale and merge 
    //
    mergeScale( x, y, z )
    {
        // init the matrix
        this.initIdentityMatrix( gTempMatrix );

        // Initialize scaling matrix:
        gTempMatrix[0]  = x;
        gTempMatrix[5]  = y;
        gTempMatrix[10] = z;

        // Merge the scale into the master matrix
        this.mergeMatrix( gTempMatrix );
    }
    
    //
    //  DESC: Calulate an orthographic matrix 
    //
    orthographicRH( w, h, zn, zf )
    {
        // Formula for a right handed orthographic matrix
        //  2/w  0    0           0
        //  0    2/h  0           0
        //  0    0    1/(zn-zf)   0
        //  0    0    zn/(zn-zf)  1

        this.matrix[0] = 2 / w;
        this.matrix[5] = 2 / h;
        this.matrix[10] = 1 / (zn-zf);
        this.matrix[14] = zn / (zn-zf);
    }
    
    //
    //  DESC: Calulate an perspective matrix 
    //
    perspectiveFovRH( fovy, aspect, zn, zf )
    {
        // Formula for a right handed perspective matrix
        //  yScale = cot(fovY/2)
        //  xScale = yScale / aspect ratio
        //  xScale     0          0              0
        //  0        yScale       0              0
        //  0        0        zf/(zn-zf)        -1
        //  0        0        zn*zf/(zn-zf)      0

        let yScale = 1 / Math.tan(fovy/2);
        let xScale = yScale / aspect;

        this.matrix[0] = xScale;
        this.matrix[5] = yScale;
        this.matrix[10] = zf / (zn-zf);
        this.matrix[11] = -1;
        this.matrix[14] = zn * zf / (zn-zf);
    }
    
    //
    //  DESC: Inverse the X 
    //
    invertX()
    {
        this.matrix[12] = -this.matrix[12];
    }

    //
    //  DESC: Inverse the Y 
    //
    invertY()
    {
        this.matrix[13] = -this.matrix[13];
    }

    //
    //  DESC: Inverse the Z 
    //
    invertZ()
    {
        this.matrix[14] = -this.matrix[14];
    }

    //
    //  DESC: Inverse the Z 
    //
    multiply3x3( matrix )
    {
        this.initIdentityMatrix( gTempMergeMatrix );

        for( let i = 0; i < 3; ++i )
        {
            for( let j = 0; j < 3; ++j )
            { 
                gTempMergeMatrix[(i*4)+j] = (this.matrix[i*4] * matrix[j])
                + (this.matrix[(i*4)+1] * matrix[4+j])
                + (this.matrix[(i*4)+2] * matrix[8+j]);
            }
        }

        // Swap matricies so that there's no garbage collection
        gSwap = this.matrix;
        this.matrix = gTempMergeMatrix;
        gTempMergeMatrix = gSwap;
    }
}


/***/ }),
/* 13 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Object": () => (/* binding */ Object)
/* harmony export */ });
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14);
/* harmony import */ var _size__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4);
/* harmony import */ var _utilities_bitmask__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(15);
/* harmony import */ var _utilities_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(12);
/* harmony import */ var _script_scriptcomponent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(16);
/* harmony import */ var _utilities_xmlparsehelper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(19);
/* harmony import */ var _common_defs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6);

// 
//  FILE NAME:  object.js
//  DESC:       object class
//










var gDummyPoint = new _point__WEBPACK_IMPORTED_MODULE_0__.Point;

class Object
{
    constructor()
    {
        // local matrix
        this.matrix = new _utilities_matrix__WEBPACK_IMPORTED_MODULE_3__.Matrix;

        // Bitmask settings to record if the object needs to be transformed
        this.parameters = new _utilities_bitmask__WEBPACK_IMPORTED_MODULE_2__.BitMask(_common_defs__WEBPACK_IMPORTED_MODULE_6__.VISIBLE);
    
        // Local position
        this.pos = new _point__WEBPACK_IMPORTED_MODULE_0__.Point;

        // Local Rotation in radians
        this.rot = new _point__WEBPACK_IMPORTED_MODULE_0__.Point;

        // Local scale
        this.scale = new _point__WEBPACK_IMPORTED_MODULE_0__.Point( 1, 1, 1 );

        // The center point. Point of rotation
        // This is used for defining a different center point
        this.centerPos = new _point__WEBPACK_IMPORTED_MODULE_0__.Point;

        // Offset due to a sprite sheet crop.
        this.cropOffset = new _size__WEBPACK_IMPORTED_MODULE_1__.Size;

        // Translated position
        this.transPos = new _point__WEBPACK_IMPORTED_MODULE_0__.Point;

        // The script part of the sprite
        this.scriptComponent = new _script_scriptcomponent__WEBPACK_IMPORTED_MODULE_4__.ScriptComponent;
    }

    //
    //  DESC: Set the object's position
    //
    setPos( pos )
    {
        this.parameters.add( _common_defs__WEBPACK_IMPORTED_MODULE_6__.TRANSLATE | _common_defs__WEBPACK_IMPORTED_MODULE_6__.TRANSFORM );

        this.pos.set( pos );
    }
    
    setPosXYZ( x = 0, y = 0, z = 0 )
    {
        this.parameters.add( _common_defs__WEBPACK_IMPORTED_MODULE_6__.TRANSLATE | _common_defs__WEBPACK_IMPORTED_MODULE_6__.TRANSFORM );

        this.pos.setXYZ( x, y, z );
    }
    
    incPos( pos )
    {
        this.parameters.add( _common_defs__WEBPACK_IMPORTED_MODULE_6__.TRANSLATE | _common_defs__WEBPACK_IMPORTED_MODULE_6__.TRANSFORM );

        this.pos.inc( pos );
    }
    
    incPosXYZ( x = 0, y = 0, z = 0 )
    {
        this.parameters.add( _common_defs__WEBPACK_IMPORTED_MODULE_6__.TRANSLATE | _common_defs__WEBPACK_IMPORTED_MODULE_6__.TRANSFORM );

        this.pos.incXYZ( x, y, z );
    }
    
    //
    //  DESC: Set the pre-translation matrix
    //
    setRot( rot, convertToRadians = true )
    {
        this.parameters.add( _common_defs__WEBPACK_IMPORTED_MODULE_6__.ROTATE | _common_defs__WEBPACK_IMPORTED_MODULE_6__.TRANSFORM );
        
        if( convertToRadians )
            this.rot.setXYZ( rot.x * _common_defs__WEBPACK_IMPORTED_MODULE_6__.DEG_TO_RAD, rot.y * _common_defs__WEBPACK_IMPORTED_MODULE_6__.DEG_TO_RAD, rot.z * _common_defs__WEBPACK_IMPORTED_MODULE_6__.DEG_TO_RAD );
        else
            this.rot.set( rot );
    }
    
    setRotXYZ( x = 0, y = 0, z = 0, convertToRadians = true )
    {
        this.parameters.add( _common_defs__WEBPACK_IMPORTED_MODULE_6__.ROTATE | _common_defs__WEBPACK_IMPORTED_MODULE_6__.TRANSFORM );

        if( convertToRadians )
            this.rot.setXYZ( x * _common_defs__WEBPACK_IMPORTED_MODULE_6__.DEG_TO_RAD, y * _common_defs__WEBPACK_IMPORTED_MODULE_6__.DEG_TO_RAD, z * _common_defs__WEBPACK_IMPORTED_MODULE_6__.DEG_TO_RAD );
        else
            this.rot.setXYZ( x, y, z );
    }
    
    incRot( rot, convertToRadians = true )
    {
        this.parameters.add( _common_defs__WEBPACK_IMPORTED_MODULE_6__.ROTATE | _common_defs__WEBPACK_IMPORTED_MODULE_6__.TRANSFORM );

        if( convertToRadians )
            this.rot.incXYZ( rot.x * _common_defs__WEBPACK_IMPORTED_MODULE_6__.DEG_TO_RAD, rot.y * _common_defs__WEBPACK_IMPORTED_MODULE_6__.DEG_TO_RAD, rot.z * _common_defs__WEBPACK_IMPORTED_MODULE_6__.DEG_TO_RAD );
        else
            this.rot.inc( rot );
        
        this.rot.cap( 360 * _common_defs__WEBPACK_IMPORTED_MODULE_6__.DEG_TO_RAD );
    }
    
    incRotXYZ( x = 0, y = 0, z = 0, convertToRadians = true )
    {
        this.parameters.add( _common_defs__WEBPACK_IMPORTED_MODULE_6__.ROTATE | _common_defs__WEBPACK_IMPORTED_MODULE_6__.TRANSFORM );

        if( convertToRadians )
            this.rot.incXYZ( x * _common_defs__WEBPACK_IMPORTED_MODULE_6__.DEG_TO_RAD, y * _common_defs__WEBPACK_IMPORTED_MODULE_6__.DEG_TO_RAD, z * _common_defs__WEBPACK_IMPORTED_MODULE_6__.DEG_TO_RAD );
        else
            this.rot.incXYZ( x, y, z );
        
        this.rot.cap( 360 * _common_defs__WEBPACK_IMPORTED_MODULE_6__.DEG_TO_RAD );
    }
    
    //
    //  DESC: Set the pre-translation matrix
    //
    setScale( scale )
    {
        this.parameters.add( _common_defs__WEBPACK_IMPORTED_MODULE_6__.SCALE | _common_defs__WEBPACK_IMPORTED_MODULE_6__.TRANSFORM );

        this.scale.set( scale );
    }
    
    setScaleXYZ( x = 1, y = 1, z = 1 )
    {
        this.parameters.add( _common_defs__WEBPACK_IMPORTED_MODULE_6__.SCALE | _common_defs__WEBPACK_IMPORTED_MODULE_6__.TRANSFORM );

        this.scale.setXYZ( x, y, z );
    }
    
    incScale( scale )
    {
        this.parameters.add( _common_defs__WEBPACK_IMPORTED_MODULE_6__.SCALE | _common_defs__WEBPACK_IMPORTED_MODULE_6__.TRANSFORM );

        this.scale.inc( scale );
    }
    
    incScaleXYZ( x = 1, y = 1, z = 1 )
    {
        this.parameters.add( _common_defs__WEBPACK_IMPORTED_MODULE_6__.SCALE | _common_defs__WEBPACK_IMPORTED_MODULE_6__.TRANSFORM );

        this.scale.incXYZ( x, y, z );
    }
    
    //
    //  DESC: Set the object's center position
    //
    setCenterPos( pos )
    {
        this.parameters.add( _common_defs__WEBPACK_IMPORTED_MODULE_6__.CENTER_POINT | _common_defs__WEBPACK_IMPORTED_MODULE_6__.TRANSFORM );

        this.centerPos = pos;
    }
    
    setCenterPosXYZ( x = 0, y = 0, z = 0 )
    {
        this.parameters.add( _common_defs__WEBPACK_IMPORTED_MODULE_6__.CENTER_POINT | _common_defs__WEBPACK_IMPORTED_MODULE_6__.TRANSFORM );

        this.centerPos.setXYZ( x, y, z );
    }

    //
    //  DESC: Set the object's crop offset
    //
    setCropOffset( offset )
    {
        if( !this.centerPos.isEmpty() || ((offset !== null) && (!offset.isEmpty())) )
        {
            this.parameters.add( _common_defs__WEBPACK_IMPORTED_MODULE_6__.CROP_OFFSET | _common_defs__WEBPACK_IMPORTED_MODULE_6__.TRANSFORM );

            this.cropOffset = offset;
        }
    }

    //
    //  DESC: Set the object visible
    //
    setVisible( value )
    {
        if( value )
            this.parameters.add( _common_defs__WEBPACK_IMPORTED_MODULE_6__.VISIBLE );
        else
            this.parameters.remove( _common_defs__WEBPACK_IMPORTED_MODULE_6__.VISIBLE );
    }

    //
    //  DESC: Is the object visible
    //
    isVisible()
    {
        return this.parameters.isSet( _common_defs__WEBPACK_IMPORTED_MODULE_6__.VISIBLE );
    }
    
    //
    //  DESC: Copy the transform to the passed in object
    //
    copyTransform( object )
    {
        if( object.parameters.isSet( _common_defs__WEBPACK_IMPORTED_MODULE_6__.TRANSLATE ) )
            this.setPos( object.pos );

        if( object.parameters.isSet( _common_defs__WEBPACK_IMPORTED_MODULE_6__.ROTATE ) )
            this.setRot( object.rot );

        if( object.parameters.isSet( _common_defs__WEBPACK_IMPORTED_MODULE_6__.SCALE ) )
            this.setScale( object.scale );

        if( object.parameters.isSet( _common_defs__WEBPACK_IMPORTED_MODULE_6__.CENTER_POINT ) )
            this.setCenterPos( object.centerPos );

        if( object.parameters.isSet( _common_defs__WEBPACK_IMPORTED_MODULE_6__.CROP_OFFSET ) )
            this.setCropOffset( object.cropOffset );
    }
    
    //
    //  DESC: Load the transform data from xmlNode
    //
    loadTransFromNode( xmlNode )
    {
        // Set if visible. Is visible by default
        let attr = xmlNode.getAttribute( 'visible' );
        if( attr )
            this.setVisible( attr === 'true' );

        let pos = _utilities_xmlparsehelper__WEBPACK_IMPORTED_MODULE_5__.loadPosition( xmlNode );
        if( pos )
            this.setPos( pos );

        let rot = _utilities_xmlparsehelper__WEBPACK_IMPORTED_MODULE_5__.loadRotation( xmlNode );
        if( rot )
            this.setRot( rot );

        let scale = _utilities_xmlparsehelper__WEBPACK_IMPORTED_MODULE_5__.loadScale( xmlNode );
        if( scale )
            this.setScale( scale );

        let centerPos = _utilities_xmlparsehelper__WEBPACK_IMPORTED_MODULE_5__.loadCenterPos( xmlNode );
        if( centerPos )
            this.setCenterPos( centerPos );
    }

    //
    //  DESC: Transform the object in local space
    //
    transformLocal( matrix )
    {
        // Reset the matrices
        matrix.initilizeMatrix();

        // Apply the crop offset
        if( this.parameters.isSet( _common_defs__WEBPACK_IMPORTED_MODULE_6__.CROP_OFFSET ) )
            matrix.translateSize( this.cropOffset );

        // Apply the scale
        if( this.parameters.isSet( _common_defs__WEBPACK_IMPORTED_MODULE_6__.SCALE ) )
            this.applyScale();

        // Apply the rotation
        if( this.parameters.isSet( _common_defs__WEBPACK_IMPORTED_MODULE_6__.ROTATE ) )
            this.applyRotation( matrix );

        // Apply the translation
        if( this.parameters.isSet( _common_defs__WEBPACK_IMPORTED_MODULE_6__.TRANSLATE ) )
            matrix.translate( this.pos );

        // Clear the check parameter
        this.parameters.remove( _common_defs__WEBPACK_IMPORTED_MODULE_6__.TRANSFORM );

        // Indicate that translation was done
        this.parameters.add( _common_defs__WEBPACK_IMPORTED_MODULE_6__.WAS_TRANSFORMED );
    }
    
    //
    //  DESC: Transform
    //  
    //  NOTE: Child objects that are intermittenly transformed
    //        will need a transform even if it's just 0, 0, 0
    //        to force a transfor with it's parent
    //
    transform( object = null )
    {
        this.parameters.remove( _common_defs__WEBPACK_IMPORTED_MODULE_6__.WAS_TRANSFORMED );
        
        if( object )
        {
            if( this.parameters.isSet( _common_defs__WEBPACK_IMPORTED_MODULE_6__.TRANSFORM ) || object.wasWorldPosTranformed() )
            {
                this.transformLocal( this.matrix );
                this.matrix.mergeMatrix( object.matrix.matrix );
                this.matrix.transformPoint( this.transPos, gDummyPoint );
            }
        }
        else
        {
            if( this.parameters.isSet( _common_defs__WEBPACK_IMPORTED_MODULE_6__.TRANSFORM ) )
            {
                this.transformLocal( this.matrix );
                this.transPos.copy( this.pos );
            }
        }
    }

    //
    //  DESC: Apply the scale
    //
    applyScale()
    {
        this.matrix.setScaleFromPoint( this.scale );
    }

    //
    //  DESC: Apply the scale
    //
    applyRotation( /*matrix*/ )
    {
        // Add in the center point prior to rotation
        if( this.parameters.isSet( _common_defs__WEBPACK_IMPORTED_MODULE_6__.CENTER_POINT ) )
            this.matrix.translate( this.centerPos );

        this.matrix.rotate( this.rot );

        // Subtract the center point after rotation to put back in original position
        // Doing two inverts keeps us from having to new up a point that would be garbage collected
        if( this.parameters.isSet( _common_defs__WEBPACK_IMPORTED_MODULE_6__.CENTER_POINT ) )
        {
            this.centerPos.invert();
            this.matrix.translate( this.centerPos );
            this.centerPos.invert();
        }
    }

    //
    //  DESC: Was the world position transformed?
    //
    wasWorldPosTranformed()
    {
        return this.parameters.isSet( _common_defs__WEBPACK_IMPORTED_MODULE_6__.WAS_TRANSFORMED );
    }

    //
    //  DESC: Was the world position transformed?
    //
    forceTransform()
    {
        this.parameters.add( _common_defs__WEBPACK_IMPORTED_MODULE_6__.TRANSFORM );
    }
}


/***/ }),
/* 14 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Point": () => (/* binding */ Point)
/* harmony export */ });
/* harmony import */ var _common_defs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);

// 
//  FILE NAME:  point.js
//  DESC:       Point class
//





class Point
{
    constructor( x = 0, y = 0, z = 0 )
    {
        this.data = new Float32Array([x,y,z]);
    }
    
    set x(value) { this.data[0] = value; }
    get x() { return this.data[0]; }
    
    set y(value) { this.data[1] = value; }
    get y() { return this.data[1]; }
    
    set z(value) { this.data[2] = value; }
    get z() { return this.data[2]; }
    
    copy( obj )
    {
        this.data[0] = obj.data[0];
        this.data[1] = obj.data[1];
        this.data[2] = obj.data[2];
    }
    
    convertToRads()
    {
        this.x *= _common_defs__WEBPACK_IMPORTED_MODULE_0__.DEG_TO_RAD;
        this.y *= _common_defs__WEBPACK_IMPORTED_MODULE_0__.DEG_TO_RAD;
        this.z *= _common_defs__WEBPACK_IMPORTED_MODULE_0__.DEG_TO_RAD;
    }
    
    setXYZ( x = 0, y = 0, z = 0 )
    {
        this.data[0] = x;
        this.data[1] = y;
        this.data[2] = z;
    }
    
    set( point )
    {
        this.data[0] = point.data[0];
        this.data[1] = point.data[1];
        this.data[2] = point.data[2];
    }
    
    incXYZ( x = 0, y = 0, z = 0 )
    {
        this.data[0] += x;
        this.data[1] += y;
        this.data[2] += z;
    }
    
    inc( point )
    {
        this.data[0] += point.data[0];
        this.data[1] += point.data[1];
        this.data[2] += point.data[2];
    }

    cap( value )
    {
        if( value > 0 )
        {
            if( this.x > value )
            {
                this.x -= value;
            }
            else if ( this.x < 0 )
            {
                this.x += value;
            }

            if( this.y > value )
            {
                this.y -= value;
            }
            else if ( this.y < 0 )
            {
                this.y += value;
            }

            if( this.z > value )
            {
                this.z -= value;
            }
            else if ( this.z < 0 )
            {
                this.z += value;
            }
        }
        else
        {
            if( this.x > value )
            {
                this.x += value;
            }
            else if ( this.x < 0 )
            {
                this.x -= value;
            }

            if( this.y > value )
            {
                this.y += value;
            }
            else if ( this.y < 0 )
            {
                this.y -= value;
            }

            if( this.z > value )
            {
                this.z += value;
            }
            else if ( this.z < 0 )
            {
                this.z -= value;
            }
        }
    }
    
    getInvert()
    {
        return new Point(-this.data[0], -this.data[1], -this.data[2]);
    }
    
    invert()
    {
        this.data[0] = -this.data[0];
        this.data[1] = -this.data[1];
        this.data[2] = -this.data[2];
    }
    
    isEmpty()
    {
        if( (this.x == 0) && (this.y == 0) && (this.z == 0) )
            return true;
        
        return false;
    }
    
    isXEmpty()
    {
        return (0 === this.x);
    }

    isYEmpty()
    {
        return (0 === this.y);
    }

    isZEmpty()
    {
        return (0 === this.z);
    }
    
    isEquilXYZ( x, y, z )
    {
        if( this.data[0] === x )
        {
            if( this.data[1] === y )
            {
                if( this.data[2] === z )
                {
                    return true;
                }
            }
        }
        
        return false;
    }
}


/***/ }),
/* 15 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BitMask": () => (/* binding */ BitMask)
/* harmony export */ });

// 
//  FILE NAME: bitmask.js
//  DESC:      Class to handle a bit mask
//



class BitMask
{
    constructor( value = 0 )
    {
        this.bitmask = value;
    }
    
    // 
    //  DESC: Add the parameters to the bitmask
    //
    add( args )
    {
        this.bitmask |= args;
    }

    // 
    //  DESC: Remove the parameters from the bitmask
    //
    remove( args )
    {
        this.bitmask &= args ^ -1;
    }

    // 
    //  DESC: Remove all parameters except for the ones passed in
    //
    removeAllExcept( args )
    {
        this.bitmask &= args;
    }

    // 
    //  DESC: Set the bitmask to zero
    //
    clear()
    {
        this.bitmask = 0;
    }
    
    // 
    //  DESC: Check if all of the parameters are set
    //
    isEmpty()
    {
        return (this.bitmask === 0);
    }

    // 
    //  DESC: Check if one of the parameters is set
    //
    isSet( args )
    {
        return (this.bitmask & args) !== 0;
    }

    // 
    //  DESC: Check if all of the parameters are set
    //
    areAllSet( args )
    {
        return (this.bitmask & args) === args;
    }

    // 
    //  DESC: Get a copy of the bitmask including the parameters
    //
    getIncluding( args )
    {
        return this.bitmask | args;
    }

    // 
    //  DESC: Get a copy of the bitmask excluding the parameters
    //
    getExcluding( args )
    {
        return this.bitmask & (args ^ -1);
    }
}
    




/***/ }),
/* 16 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ScriptComponent": () => (/* binding */ ScriptComponent)
/* harmony export */ });
/* harmony import */ var _script_scriptmanager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17);
/* harmony import */ var _script_scriptpreparefunc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(18);

//
//  FILE NAME: scriptcomponent.js
//  DESC:      Class for handling game scripting
//





class ScriptComponent
{
    constructor()
    {
        this.scriptAry = [];

        // Script object map. Prepare scripts by name
        this.scriptFactoryMap = null;
    }

    // 
    //  DESC: Init the script Ids and add them to the map
    //        This loads the attribute info reguardless of what it is
    //
    initScriptIds( xmlNode )
    {
        // Check for scripting
        let scriptNode = xmlNode.getElementsByTagName( 'script' );

        if( !this.scriptFactoryMap && scriptNode.length )
            this.scriptFactoryMap = new Map;

        for( let i = 0; i < scriptNode.length; ++i )
        {
            let prepareOnInit = false;
            let forceUpdate = false;
            let attr = scriptNode[i].getAttribute( 'prepareOnInit' );
            if( attr !== null )
                prepareOnInit = (attr === 'true')

            attr = scriptNode[i].getAttribute( 'forceUpdate' );
            if( attr !== null )
                forceUpdate = (attr === 'true')

            attr = scriptNode[i].attributes[0];
            if( attr )
                // This allocates the script to the map
                this.scriptFactoryMap.set( attr.name, new _script_scriptpreparefunc__WEBPACK_IMPORTED_MODULE_1__.CScriptPrepareFunc(attr.value, prepareOnInit, forceUpdate) );
        }
    }

    // 
    //  DESC: Prepare a script to run
    //  NOTE: Function uses arguments object to handle multiple parameters
    //        The last parameter will be the script Id so that it is ignored by the calling function
    //
    prepare(...args)
    {
        if( this.scriptFactoryMap && typeof args[0] === 'string' )
        {
            let scriptPrepareFunc = this.scriptFactoryMap.get( args[0] );
            if( scriptPrepareFunc )
            {
                let script = _script_scriptmanager__WEBPACK_IMPORTED_MODULE_0__.scriptManager.get( scriptPrepareFunc.funcName );
                if( script )
                {
                    switch(args.length)
                    {
                        case 1:
                            this.scriptAry.push( script() );
                        break;
                        case 2:
                            this.scriptAry.push( script(args[1]) );
                        break;
                        case 3:
                            this.scriptAry.push( script(args[1],args[2]) );
                        break;
                        case 4:
                            this.scriptAry.push( script(args[1],args[2],args[3]) );
                        break;
                        case 5:
                            this.scriptAry.push( script(args[1],args[2],args[3],args[4]) );
                        break;
                        case 6:
                            this.scriptAry.push( script(args[1],args[2],args[3],args[4],args[5]) );
                        break;
                    }

                    if( scriptPrepareFunc.forceUpdate )
                        this.update();
                    
                    return true;
                }
            }
        }
        else if( typeof args[0] === 'object' )
        {
            this.scriptAry.push( args[0] );

            if( args.length > 1 && args[1] )
                this.update();
        }

        return false;
    }

    // 
    //  DESC: Update the script
    //
    prepareOnInit( object )
    {
        if( this.scriptFactoryMap )
        {
            for( let scriptPrepareFunc of this.scriptFactoryMap.values() )
            {
                if( scriptPrepareFunc.prepareOnInit )
                {
                    let script = _script_scriptmanager__WEBPACK_IMPORTED_MODULE_0__.scriptManager.get( scriptPrepareFunc.funcName );
                    if( script )
                    {
                        this.scriptAry.push( script(object) );
                        if( scriptPrepareFunc.forceUpdate )
                            this.update();
                    }
                }
            }
        }
    }

    // 
    //  DESC: Update the script
    //
    update()
    {
        // Call the active scripts
        for( let i = this.scriptAry.length - 1; i > -1; --i )
        {
            // If the script is finished, remove it
            if( this.scriptAry[i].execute() )
                this.scriptAry.splice( i, 1 );
        }
    }
    
    // 
    //  DESC: Is this component active?
    //
    isActive()
    {
        return (this.scriptAry.length > 0);
    }
    
    // 
    //  DESC: clear out the scripts
    //
    reset()
    {
        this.scriptAry = [];
    }
}


/***/ }),
/* 17 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "scriptManager": () => (/* binding */ scriptManager)
/* harmony export */ });

//
//  FILE NAME: scriptmanager.js
//  DESC:      Class for managing game scripts
//



class ScriptManager
{
    constructor()
    {
        this.scriptMap = new Map;
    }
    
    //
    //  DESC: Set the script by name
    //
    set( name, factory )
    {
        // Sanity check to make sure the script has not already been added in
        if( this.scriptMap.has( name ) )
            throw new Error( `Script name has already been added (${name}).` );
        
        this.scriptMap.set( name, factory );
    }

    //
    //  DESC: Delete the script by name
    //
    delete( name )
    {
        this.scriptMap.delete( name );
    }
    
    //
    //  DESC: Get the script by name
    //
    get( name )
    {
        let scriptFactory = this.scriptMap.get( name );
        
        if( scriptFactory === undefined )
            throw new Error( `Script name could not be found! (${name})` );
        
        return scriptFactory;
    }
}

var scriptManager = new ScriptManager;


/***/ }),
/* 18 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CScriptPrepareFunc": () => (/* binding */ CScriptPrepareFunc)
/* harmony export */ });

//
//  FILE NAME: scriptpreparefunc.js
//  DESC:      Class for holding script attributes
//



class CScriptPrepareFunc
{
    constructor(funcName, prepareOnInit = false, forceUpdate = false)
    {
        // Function Id
        this.funcName = funcName;

        // Prepare on Init flag
        this.prepareOnInit = prepareOnInit;

        // Force Update flag
        this.forceUpdate = forceUpdate;
    }
}

/***/ }),
/* 19 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "loadVertex2d": () => (/* binding */ loadVertex2d),
/* harmony export */   "loadPosition": () => (/* binding */ loadPosition),
/* harmony export */   "loadRotation": () => (/* binding */ loadRotation),
/* harmony export */   "loadScale": () => (/* binding */ loadScale),
/* harmony export */   "loadCenterPos": () => (/* binding */ loadCenterPos),
/* harmony export */   "loadXYZ": () => (/* binding */ loadXYZ),
/* harmony export */   "loadColor": () => (/* binding */ loadColor),
/* harmony export */   "loadSize": () => (/* binding */ loadSize),
/* harmony export */   "loadRect": () => (/* binding */ loadRect),
/* harmony export */   "loadRectFromChild": () => (/* binding */ loadRectFromChild),
/* harmony export */   "loadHorzAlignment": () => (/* binding */ loadHorzAlignment),
/* harmony export */   "loadVertAlignment": () => (/* binding */ loadVertAlignment),
/* harmony export */   "loadDynamicOffset": () => (/* binding */ loadDynamicOffset)
/* harmony export */ });
/* harmony import */ var _common_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20);
/* harmony import */ var _common_size__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4);
/* harmony import */ var _common_point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(14);
/* harmony import */ var _common_rect__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(21);
/* harmony import */ var _common_vertex2d__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(22);
/* harmony import */ var _common_dynamicoffset__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(23);
/* harmony import */ var _common_defs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6);

// 
//  FILE NAME: xmlparsehelper.js
//  DESC:      General xml parse helper functions
//             NOTE: Nonexistant attributes return null
//










// 
//  DESC: Load the 2d vertex
//
function loadVertex2d( xmlNode )
{
    if( xmlNode )
    {
        let vert2d = new _common_vertex2d__WEBPACK_IMPORTED_MODULE_4__.Vertex2d;
        
        let attr = xmlNode.getAttribute('x');
        if( attr )
            vert2d.x = Number( attr );

        attr = xmlNode.getAttribute('y');
        if( attr )
            vert2d.y = Number( attr );

        attr = xmlNode.getAttribute('z');
        if( attr )
            vert2d.z = Number( attr );

        attr = xmlNode.getAttribute('u');
        if( attr )
            vert2d.u = Number( attr );

        attr = xmlNode.getAttribute('v');
        if( attr )
            vert2d.v = Number( attr );
        
        return vert2d;
    }

    return null;
}

// 
//  DESC: Load the position
//
function loadPosition( xmlNode )
{
    let positionNode = xmlNode.getElementsByTagName( 'position' );

    if( positionNode.length )
    {
        let point = new _common_point__WEBPACK_IMPORTED_MODULE_2__.Point;
        
        let attr = positionNode[0].getAttribute( 'x' );
        if( attr )
            point.x = Number( attr );
        
        attr = positionNode[0].getAttribute( 'y' );
        if( attr )
            point.y = Number( attr );
        
        attr = positionNode[0].getAttribute( 'z' );
        if( attr )
            point.z = Number( attr );
        
        return point;
    }

    return null;
}

// 
//  DESC: Load the position
//
function loadRotation( xmlNode )
{
    let rotationNode = xmlNode.getElementsByTagName( 'rotation' );

    if( rotationNode.length )
    {
        let rotation = new _common_point__WEBPACK_IMPORTED_MODULE_2__.Point;
        
        let attr = rotationNode[0].getAttribute( 'x' );
        if( attr )
            rotation.x = Number( attr );
        
        attr = rotationNode[0].getAttribute( 'y' );
        if( attr )
            rotation.y = Number( attr );
        
        attr = rotationNode[0].getAttribute( 'z' );
        if( attr )
            rotation.z = Number( attr );
        
        return rotation;
    }

    return null;
}

// 
//  DESC: Load the scale
//
function loadScale( xmlNode )
{
    let scaleNode = xmlNode.getElementsByTagName( 'scale' );

    if( scaleNode.length )
    {
        let scale = new _common_point__WEBPACK_IMPORTED_MODULE_2__.Point;
        
        let attr = scaleNode[0].getAttribute( 'x' );
        if( attr )
            scale.x = Number( attr );
        
        attr = scaleNode[0].getAttribute( 'y' );
        if( attr )
            scale.y = Number( attr );
        
        attr = scaleNode[0].getAttribute( 'z' );
        if( attr )
            scale.z = Number( attr );
        
        return scale;
    }

    return null;
}

// 
//  DESC: Load the center position
//
function loadCenterPos( xmlNode )
{
    let centerPosNode = xmlNode.getElementsByTagName( 'centerPos' );

    if( centerPosNode.length )
    {
        let centerPos = new _common_point__WEBPACK_IMPORTED_MODULE_2__.Point;
        
        let attr = centerPosNode[0].getAttribute( 'x' );
        if( attr )
            centerPos.x = Number( attr );
        
        attr = centerPosNode[0].getAttribute( 'y' );
        if( attr )
            centerPos.y = Number( attr );
    
        attr = centerPosNode[0].getAttribute( 'z' );
        if( attr )
            centerPos.z = Number( attr );
        
        return centerPos;
    }

    return null;
}

// 
//  DESC: Load the generic x, y, z values
//
function loadXYZ( xmlNode )
{
    let point = new _common_point__WEBPACK_IMPORTED_MODULE_2__.Point;

    let attr = xmlNode.getAttribute('x');
    if( attr )
        point.x = Number( attr );

    attr = xmlNode.getAttribute('y');
    if( attr )
        point.y = Number( attr );

    attr = xmlNode.getAttribute('z');
    if( attr )
        point.z = Number( attr );

    return point;

}   // LoadScale

// 
//  DESC: Load the color
//
function loadColor( xmlNode, currentColor = null )
{
    let color = new _common_color__WEBPACK_IMPORTED_MODULE_0__.Color;
    
    if( currentColor )
        color.copy( currentColor );

    let colorNode = xmlNode.getElementsByTagName( 'color' );
    if( colorNode.length )
    {
        let attr = colorNode[0].getAttribute('r');
        if( attr )
            color.r = Number(attr);

        attr = colorNode[0].getAttribute('g');
        if( attr )
            color.g = Number(attr);

        attr = colorNode[0].getAttribute('b');
        if( attr )
            color.b = Number(attr);

        attr = colorNode[0].getAttribute('a');
        if( attr )
            color.a = Number(attr);

        // Convert if in RGBA format
        color.convert();
    }

    return color;
}

// 
//  DESC: Load the size
//
function loadSize( xmlNode, currentSize = null )
{
    let size = new _common_size__WEBPACK_IMPORTED_MODULE_1__.Size;
    
    if( currentSize )
        size.copy( currentSize );

    let sizeNode = xmlNode.getElementsByTagName( 'size' );
    if( sizeNode.length )
    {
        let attr = sizeNode[0].getAttribute('width');
        if( attr )
            size.w = Number(attr);

        attr = sizeNode[0].getAttribute('height');
        if( attr )
            size.h = Number(attr);
    }

    return size;
}

// 
//  DESC: Load the rect
//
function loadRect( xmlNode )
{
    let rectNode = xmlNode.getElementsByTagName( 'rect' );
    
    if( rectNode.length )
        return loadRectFromChild( rectNode[0] );

    return new _common_rect__WEBPACK_IMPORTED_MODULE_3__.Rect;
}

function loadRectFromChild( xmlNode )
{
    let rect = new _common_rect__WEBPACK_IMPORTED_MODULE_3__.Rect;
    
    let attr = xmlNode.getAttribute('x1');
        if( attr )
            rect.x1 = Number(attr);
        
    attr = xmlNode.getAttribute('y1');
        if( attr )
            rect.y1 = Number(attr);
        
    attr = xmlNode.getAttribute('x2');
        if( attr )
            rect.x2 = Number(attr);

    attr = xmlNode.getAttribute('y2');
        if( attr )
            rect.y2 = Number(attr);

    return rect;
}

// 
//  DESC: Load the horizontal alignment
//
function loadHorzAlignment( xmlNode, aHorzAlign )
{
    let horzAlign = aHorzAlign;

    let horzAlignAttr = xmlNode.getAttribute( 'horzAlign' );
    if( horzAlignAttr )
    {
        if( horzAlignAttr === 'left' )
            horzAlign = _common_defs__WEBPACK_IMPORTED_MODULE_6__.EHA_HORZ_LEFT;

        else if( horzAlignAttr === 'center' )
            horzAlign = _common_defs__WEBPACK_IMPORTED_MODULE_6__.EHA_HORZ_CENTER;

        else if( horzAlignAttr === 'right' )
            horzAlign = _common_defs__WEBPACK_IMPORTED_MODULE_6__.EHA_HORZ_RIGHT;
    }

    return horzAlign;
}

// 
//  DESC: Load the vertical alignment
//
function loadVertAlignment( xmlNode, aVertAlign )
{
    let vertAlign = aVertAlign;

    let vertAlignAttr = xmlNode.getAttribute( 'vertAlign' );
    if( vertAlignAttr )
    {
        if( vertAlignAttr === 'top' )
            vertAlign = _common_defs__WEBPACK_IMPORTED_MODULE_6__.EVA_VERT_TOP;

        else if( vertAlignAttr === 'center' )
            vertAlign = _common_defs__WEBPACK_IMPORTED_MODULE_6__.EVA_VERT_CENTER;

        else if( vertAlignAttr === 'bottom' )
            vertAlign = _common_defs__WEBPACK_IMPORTED_MODULE_6__.EVA_VERT_BOTTOM;
    }

    return vertAlign;
}

// 
//  DESC: Load the dynamic offset
//
function loadDynamicOffset( xmlNode )
{
    let dynamicOffsetNode = xmlNode.getElementsByTagName( 'dynamicOffset' );

    if( dynamicOffsetNode.length )
    {
        let dynamicOffset = new _common_dynamicoffset__WEBPACK_IMPORTED_MODULE_5__.DynamicOffset;
        
        let attr = dynamicOffsetNode[0].getAttribute('left');
        if( attr )
        {
            dynamicOffset.add( _common_defs__WEBPACK_IMPORTED_MODULE_6__.EDO_LEFT );
            dynamicOffset.setX( Number( attr ) );
        }
        else
        {
            attr = dynamicOffsetNode[0].getAttribute('right');
            if( attr )
            {
                dynamicOffset.add( _common_defs__WEBPACK_IMPORTED_MODULE_6__.EDO_RIGHT );
                dynamicOffset.setX( Number( attr ) );
            }
            else
            {
                attr = dynamicOffsetNode[0].getAttribute('horzCenter');
                if( attr )
                {
                    dynamicOffset.add( _common_defs__WEBPACK_IMPORTED_MODULE_6__.EDO_HORZ_CENTER );
                    dynamicOffset.setX( Number( attr ) );
                }
            }
        }
        
        attr = dynamicOffsetNode[0].getAttribute('top');
        if( attr )
        {
            dynamicOffset.add( _common_defs__WEBPACK_IMPORTED_MODULE_6__.EDO_TOP );
            dynamicOffset.setY( Number( attr ) );
        }
        else
        {
            attr = dynamicOffsetNode[0].getAttribute('bottom');
            if( attr )
            {
                dynamicOffset.add( _common_defs__WEBPACK_IMPORTED_MODULE_6__.EDO_BOTTOM );
                dynamicOffset.setY( Number( attr ) );
            }
            else
            {
                attr = dynamicOffsetNode[0].getAttribute('vertCenter');
                if( attr )
                {
                    dynamicOffset.add( _common_defs__WEBPACK_IMPORTED_MODULE_6__.EDO_VERT_CENTER );
                    dynamicOffset.setX( Number( attr ) );
                }
            }
        }
        
        return dynamicOffset;
    }

    return null;
}


/***/ }),
/* 20 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Color": () => (/* binding */ Color)
/* harmony export */ });
/* harmony import */ var _defs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);

// 
//  FILE NAME:  color.js
//  DESC:       color class
//




class Color
{
    constructor( r = 1, g = 1, b = 1, a = 1 )
    {
        this.data = new Float32Array([r,g,b,a]);
    }
    
    set( r = 1, g = 1, b = 1, a = 1 )
    {
        if( r > 1.5 )
            this.data[0] = r * _defs__WEBPACK_IMPORTED_MODULE_0__.RGB_TO_DEC;
        else
            this.data[0] = r;
        
        if( g > 1.5 )
            this.data[1] = g * _defs__WEBPACK_IMPORTED_MODULE_0__.RGB_TO_DEC;
        else
            this.data[1] = g;
        
        if( b > 1.5 )
            this.data[2] = b * _defs__WEBPACK_IMPORTED_MODULE_0__.RGB_TO_DEC;
        else
            this.data[2] = b;
        
        if( a > 1.5 )
            this.data[3] = a * _defs__WEBPACK_IMPORTED_MODULE_0__.RGB_TO_DEC;
        else
            this.data[3] = a;
    }
    
    copy( obj )
    {
        this.data[0] = obj.data[0];
        this.data[1] = obj.data[1];
        this.data[2] = obj.data[2];
        this.data[3] = obj.data[3];
    }
    
    set r(value)
    {
        if( value > 1.5 )
            value *= _defs__WEBPACK_IMPORTED_MODULE_0__.RGB_TO_DEC;
        
        this.data[0] = value;
    }
    get r() { return this.data[0]; }
    
    set g(value)
    {
        if( value > 1.5 )
            value *= _defs__WEBPACK_IMPORTED_MODULE_0__.RGB_TO_DEC;
        
        this.data[1] = value;
    }
    get g() { return this.data[1]; }
    
    set b(value)
    {
        if( value > 1.5 )
            value *= _defs__WEBPACK_IMPORTED_MODULE_0__.RGB_TO_DEC;
        
        this.data[2] = value;
    }
    get b() { return this.data[2]; }
    
    set a(value)
    {
        if( value > 1.5 )
            value *= _defs__WEBPACK_IMPORTED_MODULE_0__.RGB_TO_DEC;
        
        this.data[3] = value;
    }
    get a() { return this.data[3]; }
    
    // 
    //  DESC: Convert from integer to decimal
    //
    convert()
    {
        // 0.00390625f = 1 / 256;
        if( this.r > 1.5 )
            this.r *= _defs__WEBPACK_IMPORTED_MODULE_0__.RGB_TO_DEC;

        if( this.g > 1.5 )
            this.g *= _defs__WEBPACK_IMPORTED_MODULE_0__.RGB_TO_DEC;

        if( this.b > 1.5 )
            this.b *= _defs__WEBPACK_IMPORTED_MODULE_0__.RGB_TO_DEC;

        if( this.a > 1.5 )
            this.a *= _defs__WEBPACK_IMPORTED_MODULE_0__.RGB_TO_DEC;
    }
    
    // 
    //  DESC: HSV transformation
    //  
    //  param: type hue - hue shift (in degrees)
    //  param: type sat - saturation multiplier (scalar)
    //  param: type val - value multiplier (scalar)
    //
    transformHSV( hue, sat, val )
    {
        let VSU = val * sat * Math.cos(hue * _defs__WEBPACK_IMPORTED_MODULE_0__.DEG_TO_RAD);
        let VSW = val * sat * Math.sin(hue * _defs__WEBPACK_IMPORTED_MODULE_0__.DEG_TO_RAD);

        let _r = this.data[0], _g = this.data[1], _b = this.data[2];

        this.data[0] = (.299 * val + .701 * VSU + .168 * VSW) * _r
                     + (.587 * val - .587 * VSU + .330 * VSW) * _g
                     + (.114 * val - .114 * VSU - .497 * VSW) * _b;
        this.data[1] = (.299 * val - .299 * VSU - .328 * VSW) * _r
                     + (.587 * val + .413 * VSU + .035 * VSW) * _g
                     + (.114 * val - .114 * VSU + .292 * VSW) * _b;
        this.data[2] = (.299 * val - .3   * VSU + 1.25 * VSW) * _r
                     + (.587 * val - .588 * VSU - 1.05 * VSW) * _g
                     + (.114 * val + .886 * VSU - .203 * VSW) * _b;
    }
}


/***/ }),
/* 21 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Rect": () => (/* binding */ Rect)
/* harmony export */ });

// 
//  FILE NAME:  rect.js
//  DESC:       rect class
//



class Rect
{
    constructor( x1 = 0, y1 = 0, x2 = 0, y2 = 0 )
    {
        this.data = new Float32Array([x1,y1,x2,y2]);
    }
    
    set( x1 = 0, y1 = 0, x2 = 0, y2 = 0 )
    {
        this.data[0] = x1;
        this.data[1] = y1;
        this.data[2] = x2;
        this.data[3] = y2;
    }
    
    set x1(value) { this.data[0] = value; }
    get x1() { return this.data[0]; }
    
    set y1(value) { this.data[1] = value; }
    get y1() { return this.data[1]; }
    
    set x2(value) { this.data[2] = value; }
    get x2() { return this.data[2]; }
    
    set y2(value) { this.data[3] = value; }
    get y2() { return this.data[3]; }
}


/***/ }),
/* 22 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Vertex2d": () => (/* binding */ Vertex2d)
/* harmony export */ });

// 
//  FILE NAME:  vertex2d.js
//  DESC:       vertex 2d class
//



class Vertex2d
{
    constructor( x = 0, y = 0, z = 0, u = 0, v = 0 )
    {
        this.data = [x,y,z,u,v];
    }
    
    set x(value) { this.data[0] = value; }
    get x() { return this.data[0]; }
    
    set y(value) { this.data[1] = value; }
    get y() { return this.data[1]; }
    
    set z(value) { this.data[2] = value; }
    get z() { return this.data[2]; }
    
    set u(value) { this.data[3] = value; }
    get u() { return this.data[3]; }
    
    set v(value) { this.data[4] = value; }
    get v() { return this.data[4]; }
}


/***/ }),
/* 23 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DynamicOffset": () => (/* binding */ DynamicOffset)
/* harmony export */ });
/* harmony import */ var _utilities_bitmask__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);
/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14);
/* harmony import */ var _size__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony import */ var _common_defs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6);
// 
//  FILE NAME: dynamicoffset.js
//  DESC:      Dynamic Offset class
//







class DynamicOffset
{
    constructor()
    {
        // bit mask parameters
        this.parameters = new _utilities_bitmask__WEBPACK_IMPORTED_MODULE_0__.BitMask;

        // offset
        this.point = new _point__WEBPACK_IMPORTED_MODULE_1__.Point;
    }
    
    // 
    //  DESC: Add to the bit mask
    //
    add( value )
    {
        this.parameters.add( value );
    }

    // 
    //  Set/Get X
    //
    setX( value )
    {
        this.point.x = value;
    }

    setY( value )
    {
        this.point.y = value;
    }
    
    // 
    //  DESC: Is the dynamic offset being used
    //
    isEmpty()
    {
        return this.parameters.isEmpty();
    }
    
    // 
    //  DESC: Get the dynamic position
    //
    getPos( defaultHalfSize )
    {
        let pos = new _point__WEBPACK_IMPORTED_MODULE_1__.Point;
        
        let halfSize = new _size__WEBPACK_IMPORTED_MODULE_2__.Size( defaultHalfSize.w, defaultHalfSize.h );
        
        // Strip out any fractional component for correct rendering
        halfSize.round();

        if( this.parameters.isSet( _common_defs__WEBPACK_IMPORTED_MODULE_3__.EDO_LEFT ) )
            pos.x = -(halfSize.w - this.point.x);

        else if( this.parameters.isSet( _common_defs__WEBPACK_IMPORTED_MODULE_3__.EDO_RIGHT ) )
            pos.x = halfSize.w - this.point.x;

        else if( this.parameters.isSet( _common_defs__WEBPACK_IMPORTED_MODULE_3__.EDO_HORZ_CENTER ) )
            pos.x = this.point.x;

        if( this.parameters.isSet( _common_defs__WEBPACK_IMPORTED_MODULE_3__.EDO_TOP ) )
            pos.y = halfSize.h - this.point.y;
            
        else if( this.parameters.isSet( _common_defs__WEBPACK_IMPORTED_MODULE_3__.EDO_BOTTOM ) )
            pos.y = -(halfSize.h - this.point.y);

        else if( this.parameters.isSet( _common_defs__WEBPACK_IMPORTED_MODULE_3__.EDO_VERT_CENTER ) )
            pos.y = this.point.y;

        return pos;
    }
}


/***/ }),
/* 24 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "menuManager": () => (/* binding */ menuManager)
/* harmony export */ });
/* harmony import */ var _managers_managerbase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(25);
/* harmony import */ var _managers_actionmanager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(27);
/* harmony import */ var _managers_eventmanager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30);
/* harmony import */ var _utilities_assetholder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(33);
/* harmony import */ var _gui_menu__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(34);
/* harmony import */ var _gui_menutree__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(142);
/* harmony import */ var _managers_cameramanager__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(10);
/* harmony import */ var _common_genericevent__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(31);
/* harmony import */ var _common_gamepadevent__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(29);
/* harmony import */ var _utilities_genfunc__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(26);
/* harmony import */ var _gui_menudefs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(36);
/* harmony import */ var _common_defs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(6);

// 
//  FILE NAME: menumanager.js
//  DESC:      menu manager class singleton
//
















class MenuManager extends _managers_managerbase__WEBPACK_IMPORTED_MODULE_0__.ManagerBase
{
    constructor()
    {
        super();
        
        // NOTE: Only simple allocation that don't 
        //       require Settings to be loaded
        
        // Map map of menu trees
        this.menuTreeMapMap = new Map;

        // Map of the menus
        this.menuMapMap = new Map;

        // Array of active menu trees
        this.activeMenuTreeAry = [];

        // Array of active interface trees
        this.activeInterTreeAry = [];

        // menu manager state
        this.active = false;

        // Actions
        this.backAction;
        this.toggleAction;
        this.escapeAction;
        this.selectAction;
        this.upAction;
        this.downAction;
        this.leftAction;
        this.rightAction;
        this.tabLeft;
        this.tabRight;
        this.defaultTree;

        // scroll timer Id
        this.scrollTimerId = 0;

        // Allow message processing
        this.allow = false;
    }
    
    //
    //  DESC: Set the default camera
    //
    setDefaultCamera()
    {
        // Default camera
        this.camera = _managers_cameramanager__WEBPACK_IMPORTED_MODULE_6__.cameraManager.getDefault();
    }
    
    // 
    //  DESC: Set the camera
    //
    setCamera( cameraId )
    {
        this.camera = _managers_cameramanager__WEBPACK_IMPORTED_MODULE_6__.cameraManager.get( cameraId );
    }
    
    // 
    //  DESC: Load the menu group
    //
    loadGroupXML( groupAry )
    {
        let promiseAry = [];

        for( let grp = 0; grp < groupAry.length; ++grp )
        {
            let group = groupAry[grp];
            
            // Make sure the group we are looking for has been defined in the list table file
            let pathAry = this.listTableMap.get( group );
            if( pathAry !== undefined )
            {
                // Load the group data if it doesn't already exist
                if( this.menuMapMap.get( group ) === undefined )
                {
                    // Create a new group map inside of our maps
                    this.menuMapMap.set( group, new Map );
                    this.menuTreeMapMap.set( group, new Map );

                    for( let i = 0; i < pathAry.length; ++i )
                    {
                        let filePath = pathAry[i];

                        promiseAry.push( 
                            _utilities_genfunc__WEBPACK_IMPORTED_MODULE_9__.downloadFile( 'xml', filePath )
                                .then(( xmlNode ) => this.loadFromNode( group, xmlNode ))
                                .catch(( error ) => { console.error(error.stack); throw error; }));
                    }
                }
                else
                {
                    throw new Error( `Menu group has alread been loaded (${group})!` );
                }
            }
            else
            {
                throw new Error( `Menu Manager list group name can't be found (${group})!` );
            }
        }

        return Promise.all( promiseAry );
    }
    
    //
    //  DESC: Load all object information from an xml node
    //
    loadFromNode( group, xmlNode )
    {
        // Load the menus from node
        return this.loadMenuFromNode( group, xmlNode )

            // Load the trees from node
            .then(() => this.loadTreesFromNode( group, xmlNode ))
    }
    
    //
    //  DESC: preload all object information from an xml node
    //
    loadMenuFromNode( group, xmlNode )
    {
        let promiseAry = [];

        // Get the menu group map
        let groupMap = this.menuMapMap.get( group );
        
        let menuNode = xmlNode.getElementsByTagName('menu');

        for( let i = 0; i < menuNode.length; ++i )
        {
            // Get the name of the menu
            let name = menuNode[i].getAttribute( 'name' );

            // Get the menu file path
            let filePath = menuNode[i].getAttribute( 'file' );

            // Check for duplicates
            if( groupMap.get( name ) !== undefined )
                throw new Error( `Duplicate menu name! (${name}).` );

            // Allocate a new menu
            let menu = new _gui_menu__WEBPACK_IMPORTED_MODULE_4__.Menu( name, group, filePath );

            // Insert the menu into the group map
            groupMap.set( name, menu );

            // Load the transform from node
            menu.loadTransFromNode( menuNode[i] );

            // Load the dynamic offset from node
            menu.loadDynamicOffsetFromNode( menuNode[i] );

            // Check if this file has already been loaded
            if( _utilities_assetholder__WEBPACK_IMPORTED_MODULE_3__.assetHolder.allowLoad( group, filePath ) )
            {
                // Load the menu XML file
                promiseAry.push( 
                    _utilities_genfunc__WEBPACK_IMPORTED_MODULE_9__.downloadFile( 'xml', filePath )
                        .then(( node ) => 
                        {
                            // Store the preloaded XML file
                            _utilities_assetholder__WEBPACK_IMPORTED_MODULE_3__.assetHolder.set( group, filePath, node );

                            // Recurse back until all XML files are loaded
                            return this.loadControlFromNode( group, node );
                        })
                        .catch(( error ) => { console.error(error.stack); throw error; }));
            }
        }

        return Promise.all( promiseAry );
    }
    
    //
    //  DESC: Load the trees from node
    //
    loadTreesFromNode( group, node )
    {
        // Get the menu group map
        let menuGroupMap = this.menuMapMap.get( group );
        
        // Get the tree group map
        let treeGroupMap = this.menuTreeMapMap.get( group );
        
        // Get the node to the list of trees
        let treeNode = node.getElementsByTagName('tree');

        for( let i = 0; i < treeNode.length; ++i )
        {
            // Get the name
            let name = treeNode[i].getAttribute( 'name' );

            // Get the root menu
            let rootMenu = treeNode[i].getAttribute( 'root' );

            // Get the default menu
            let defaultMenu = treeNode[i].getAttribute( 'default' );

            // Is this menu an interface menu?
            let interfaceMenu = (treeNode[i].getAttribute( 'interfaceMenu' ) === 'true');

            // Check for duplicate names
            if( treeGroupMap.get( name ) !== undefined )
                throw new Error( `Duplicate tree name! (${name}).` );

            // Add the tree data to the map
            treeGroupMap.set( name, new _gui_menutree__WEBPACK_IMPORTED_MODULE_5__.MenuTree( name, menuGroupMap, rootMenu, defaultMenu, interfaceMenu ) );

            // Check that the root menu exists
            if( rootMenu !== '' )
            {
                if( menuGroupMap.get( rootMenu ) === undefined )
                    throw new Error( `Root menu doesn't exist! (${name}).` );
            }
            else if( defaultMenu !== '' )
            {
                if( menuGroupMap.get( defaultMenu ) === undefined )
                    throw new Error( `Default menu doesn't exist! (${name}).` );
            }
        }
    }
    
    //
    //  DESC: load the menu controls from menu node
    //        NOTE: Promise using recursive function
    //
    loadControlFromNode( group, xmlNode )
    {
        let promiseAry = [];
        let controlLst = ['staticMenuControls', 'mouseOnlyControls', 'menuControls', 'subControlList', 'scrollBoxControlList'];
        
        // Load the control XML files
        for( let i = 0; i < controlLst.length; ++i )
        {
            let nodeLst = xmlNode.getElementsByTagName( controlLst[i] );
            if( nodeLst.length )
            {
                let controlNode = nodeLst[0].getElementsByTagName( 'control' );

                for( let j = 0; j < controlNode.length; ++j )
                {
                    let filePathNode = controlNode[j].getElementsByTagName( 'filePath' );
                    if( filePathNode.length )
                    {
                        let filePath = filePathNode[0].getAttribute('file');
                        if( filePath )
                        {
                            // Check if this file has already been scheduled for loading
                            if( _utilities_assetholder__WEBPACK_IMPORTED_MODULE_3__.assetHolder.allowLoad( group, filePath ) )
                            {
                                promiseAry.push(
                                    _utilities_genfunc__WEBPACK_IMPORTED_MODULE_9__.downloadFile( 'xml', filePath )
                                    .then(( node ) => 
                                    {
                                        // Store the preloaded XML file
                                        _utilities_assetholder__WEBPACK_IMPORTED_MODULE_3__.assetHolder.set( group, filePath, node );
            
                                        // Recurse back until all XML files are loaded
                                        return this.loadControlFromNode( group, node );
                                    })
                                    .catch(( error ) => { console.error(error.stack); throw error; }));
                            }
                        }
                    }
                }
            }
        }

        return Promise.all( promiseAry );
    }
    
    //
    //  DESC: Create menu objects from loaded xml data
    //
    createFromData( groupAry )
    {
        for( let grp = 0; grp < groupAry.length; ++grp )
        {
            let group = groupAry[grp];
            
            // Get the menu group map
            let groupMap = this.menuMapMap.get( group );
            if( groupMap === undefined )
                throw new Error( `Group map can't be found! (${group}).` );

            for( let menu of groupMap.values() )
            {
                // Get the menu XML node
                let xmlNode = _utilities_assetholder__WEBPACK_IMPORTED_MODULE_3__.assetHolder.get( group, menu.filePath );

                // Have the menu load it's share
                menu.loadFromNode( xmlNode );
            }

            this.initGroup( group );
        }

        return 0;
    }

    //
    //  DESC: Free the menu group
    //
    freeGroup( groupAry )
    {
        for( let grp = 0; grp < groupAry.length; ++grp )
        {
            let group = groupAry[grp];
            
            // Make sure the group we are looking for exists
            if( this.listTableMap.get( group ) === undefined )
                throw new Error( `Object data list group name can't be found (${group})!` );

            // Get the group map
            let groupMap = this.menuTreeMapMap.get( group );
            if( groupMap !== undefined )
            {
                // Remove it from the tree vectors if it is there
                for( let menuTree of groupMap.values() )
                {
                    if( menuTree.interfaceMenu )
                    {
                        let index = this.activeInterTreeAry.indexOf( menuTree );

                        if( index > -1 )
                            this.activeInterTreeAry.splice( index, 1 );
                    }
                    else
                    {
                        let index = this.activeMenuTreeAry.indexOf( menuTree );

                        if( index > -1 )
                            this.activeMenuTreeAry.splice( index, 1 );
                    }
                }

                // Free the menu group
                this.menuTreeMapMap.delete( group );
                this.menuMapMap.delete( group );
            }
        }
    }
    
    // 
    //  DESC: Init a menu group
    //  NOTE: This allows certain actions to be done after the group load
    //
    initGroup( group )
    {
        let groupMap = this.menuMapMap.get( group );
        if( groupMap !== undefined )
        {
            for( let menu of groupMap.values() )
                menu.init();
        }
        else
        {
            throw new Error( `Menu group name can't be found to init (${group})!` );
        }
    }

    // 
    //  DESC: Clean up a menu group
    //  NOTE: This allows certain actions to be done after the group load
    //
    cleanUpGroup( group )
    {
        let groupMap = this.menuMapMap.get( group );
        if( groupMap !== undefined )
        {
            for( let menu of groupMap.values() )
                menu.cleanUp();
        }
        else
        {
            throw new Error( `Menu group name can't be found to clean up (${group})!` );
        }
    }
    
    // 
    //  DESC: Load the menu action list from XML
    //
    loadMenuAction( filePath )
    {
        return _utilities_genfunc__WEBPACK_IMPORTED_MODULE_9__.downloadFile( 'xml', filePath,
            ( xmlNode ) => this.loadMenuActionFromNode( xmlNode ));
    }

    // 
    //  DESC: Load the menu action list from JSON
    //
    loadMenuActionFromObj( obj )
    {
        this.backAction = obj.backAction;
        this.toggleAction = obj.toggleAction;
        this.escapeAction = obj.escapeAction;
        this.selectAction = obj.selectAction;
        this.upAction = obj.upAction;
        this.downAction = obj.downAction;
        this.leftAction = obj.leftAction;
        this.rightAction = obj.rightAction;
        this.tabLeft = obj.tabLeft;
        this.tabRight = obj.tabRight;
        this.defaultTree = obj.defaultTree;
    }
    
    // 
    //  DESC: Activate a tree to be used by tree name only
    //        NOTE: Assumes unique tree names
    //
    activateTree( treeAry )
    {
        for( let tree = 0; tree < treeAry.length; ++tree )
        {
            let treeStr = treeAry[tree];
            let found = false;
            
            for( let [ groupKey, groupMap ] of this.menuTreeMapMap.entries() )
            {
                for( let key of groupMap.keys() )
                {
                    if( key === treeStr )
                    {
                        this.activateTreeGroup( groupKey, key );
                        found = true;
                        break;
                    }
                }
                
                if( found )
                    break;
            }

            // If you got this far, it's a problem
            if( !found )
                throw new Error( `Menu tree doesn't exist (${treeStr})!` );
        }
    }
    
    // 
    //  DESC: Activate a tree to be used based on group
    //
    activateTreeGroup( group, treeStr )
    {
        let groupMap = this.menuTreeMapMap.get( group );
        if( groupMap !== undefined )
        {
            // Find the tree in the map
            let tree = groupMap.get( treeStr );
            if( tree !== undefined )
            {
                if( tree.interfaceMenu )
                {
                    if( this.activeInterTreeAry.indexOf( tree ) !== -1 )
                        throw new Error( `Menu tree already active (${group} - ${treeStr})!` );

                    this.activeInterTreeAry.push( tree );
                }
                else
                {
                    if( this.activeMenuTreeAry.indexOf( tree ) !== -1 )
                        throw new Error( `Menu tree already active (${group} - ${treeStr})!` );

                    this.activeMenuTreeAry.push( tree );
                }

                // Init the tree for use
                tree.init();
            }
            else
            {
                throw new Error( `Menu tree doesn't exist (${group} - ${treeStr})!` );
            }
        }
        else
        {
            throw new Error( `Menu tree group doesn't exist (${group} - ${treeStr})!` );
        }

        // See if we are active
        this.setActiveState();
    }
    
    // 
    //  DESC: Deactivate a tree to be used by tree name only
    //        NOTE: Assumes unique tree names
    //
    deactivateTree( treeStr )
    {
        for( let [ groupKey, groupMap ] of this.menuTreeMapMap.entries() )
        {
            for( let key of groupMap.keys() )
            {
                if( key === treeStr )
                {
                    this.deactivateTreeGroup( groupKey, key );
                    return;
                }
            }
        }

        // If you got this far, it's a problem
        throw new Error( `Menu tree doesn't exist (${treeStr})!` );
    }

    // 
    //  DESC: Deactivate a tree that's in use
    //
    deactivateTreeGroup( group, treeStr )
    {
        let groupMap = this.menuTreeMapMap.get( group );
        if( groupMap !== undefined )
        {
            // Find the tree in the map
            let tree = groupMap.get( treeStr );
            if( tree !== undefined )
            {
                // Remove the tree from the vector
                if( tree.interfaceMenu )
                {
                    let index = this.activeInterTreeAry.indexOf( tree );
                    if( index > -1 )
                        this.activeInterTreeAry.splice( index, 1 );
                }
                else
                {
                    let index = this.activeMenuTreeAry.indexOf( tree );
                    if( index > -1 )
                        this.activeMenuTreeAry.splice( index, 1 );
                }
            }
            else
            {
                throw new Error( `Menu tree doesn't exist (${group} - ${treeStr})!` );
            }
        }
        else
        {
            throw new Error( `Menu tree group doesn't exist (${group} - ${treeStr})!` );
        }

        // See if we are still active
        this.setActiveState();
    }
    
    // 
    //  DESC: Clear the active trees
    //
    clearActiveTrees()
    {
        this.active = false;
        
        if( this.scrollTimerId !== 0 )
            clearInterval( this.scrollTimerId );

        this.activeMenuTreeAry = [];
        this.activeInterTreeAry = [];
    }
    
    // 
    //  DESC: Handle input events and dispatch menu events
    //
    handleEvent( event )
    {
        if( this.allow )
        {
            // Convert keyboard, mouse and controller messages in action type messages
            if( event instanceof _common_genericevent__WEBPACK_IMPORTED_MODULE_7__.GenericEvent )
            {
                // Are we doing menu actions? May need to do some scrolling
                if( (event.type >= _gui_menudefs__WEBPACK_IMPORTED_MODULE_10__.EGE_MENU_UP_ACTION) && (event.type <= _gui_menudefs__WEBPACK_IMPORTED_MODULE_10__.EGE_MENU_RIGHT_ACTION) )
                {
                    // Free a timer if one happens to be running
                    if( this.scrollTimerId != 0 )
                        clearTimeout( this.scrollTimerId );
                    
                    this.scrollTimerId = 0;

                    if( event.arg[0] === _common_defs__WEBPACK_IMPORTED_MODULE_11__.EAP_DOWN )
                        this.handleEventForScrolling( event );
                }
                
                this.handleEventForTrees( event );

                // Set the active state
                this.setActiveState();
            }
            else
            {
                // Only the default tree can execute an escape or toggle when none are active.
                if( _managers_actionmanager__WEBPACK_IMPORTED_MODULE_1__.actionManager.wasActionPress( event, this.escapeAction, _common_defs__WEBPACK_IMPORTED_MODULE_11__.EAP_DOWN ) )
                {
                    let tree = this.getActiveTree();

                    if( tree === null )
                        _managers_eventmanager__WEBPACK_IMPORTED_MODULE_2__.eventManager.dispatchEvent( _gui_menudefs__WEBPACK_IMPORTED_MODULE_10__.EGE_MENU_ESCAPE_ACTION, this.defaultTree );
                    else
                        _managers_eventmanager__WEBPACK_IMPORTED_MODULE_2__.eventManager.dispatchEvent( _gui_menudefs__WEBPACK_IMPORTED_MODULE_10__.EGE_MENU_ESCAPE_ACTION, tree.name );
                }
                else if( _managers_actionmanager__WEBPACK_IMPORTED_MODULE_1__.actionManager.wasActionPress( event, this.toggleAction, _common_defs__WEBPACK_IMPORTED_MODULE_11__.EAP_DOWN ) )
                {
                    let tree = this.getActiveTree();

                    if( tree === null )
                        _managers_eventmanager__WEBPACK_IMPORTED_MODULE_2__.eventManager.dispatchEvent( _gui_menudefs__WEBPACK_IMPORTED_MODULE_10__.EGE_MENU_TOGGLE_ACTION, this.defaultTree );
                    else
                        _managers_eventmanager__WEBPACK_IMPORTED_MODULE_2__.eventManager.dispatchEvent( _gui_menudefs__WEBPACK_IMPORTED_MODULE_10__.EGE_MENU_TOGGLE_ACTION, tree.name );
                }
                else if( this.active )
                {
                    let pressType;

                    // common and can result in many messages which is why it's specifically defined here
                    if( event.type === 'mousemove' || event.type === 'wheel' )
                    {
                        // Allow the mouse move message to get eaten when action handling is disabled.
                        this.handleEventForTrees( event );
                    }
                    // Select action based on input device
                    else if( (pressType = _managers_actionmanager__WEBPACK_IMPORTED_MODULE_1__.actionManager.wasAction( event, this.selectAction )) > _common_defs__WEBPACK_IMPORTED_MODULE_11__.EAP_IDLE )
                    {
                        if( event instanceof KeyboardEvent )
                        {
                            _managers_eventmanager__WEBPACK_IMPORTED_MODULE_2__.eventManager.dispatchEvent( _gui_menudefs__WEBPACK_IMPORTED_MODULE_10__.EGE_MENU_SELECT_ACTION, pressType, _common_defs__WEBPACK_IMPORTED_MODULE_11__.KEYBOARD );
                        }
                        else if( event instanceof MouseEvent )
                        {
                            _managers_eventmanager__WEBPACK_IMPORTED_MODULE_2__.eventManager.dispatchEvent(
                                _gui_menudefs__WEBPACK_IMPORTED_MODULE_10__.EGE_MENU_SELECT_ACTION,
                                pressType,
                                _common_defs__WEBPACK_IMPORTED_MODULE_11__.MOUSE,
                                event.gameAdjustedMouseX,
                                event.gameAdjustedMouseY );
                        }
                        else if( event instanceof _common_gamepadevent__WEBPACK_IMPORTED_MODULE_8__.GamepadEvent )
                        {
                            _managers_eventmanager__WEBPACK_IMPORTED_MODULE_2__.eventManager.dispatchEvent( _gui_menudefs__WEBPACK_IMPORTED_MODULE_10__.EGE_MENU_SELECT_ACTION, pressType, _common_defs__WEBPACK_IMPORTED_MODULE_11__.GAMEPAD );
                        }
                    }
                    else if( _managers_actionmanager__WEBPACK_IMPORTED_MODULE_1__.actionManager.wasActionPress( event, this.backAction, _common_defs__WEBPACK_IMPORTED_MODULE_11__.EAP_DOWN ) )
                        _managers_eventmanager__WEBPACK_IMPORTED_MODULE_2__.eventManager.dispatchEvent( _gui_menudefs__WEBPACK_IMPORTED_MODULE_10__.EGE_MENU_BACK_ACTION );

                    else if( (pressType = _managers_actionmanager__WEBPACK_IMPORTED_MODULE_1__.actionManager.wasAction( event, this.upAction )) > _common_defs__WEBPACK_IMPORTED_MODULE_11__.EAP_IDLE )
                        _managers_eventmanager__WEBPACK_IMPORTED_MODULE_2__.eventManager.dispatchEvent( _gui_menudefs__WEBPACK_IMPORTED_MODULE_10__.EGE_MENU_UP_ACTION, pressType );

                    else if( (pressType = _managers_actionmanager__WEBPACK_IMPORTED_MODULE_1__.actionManager.wasAction( event, this.downAction )) > _common_defs__WEBPACK_IMPORTED_MODULE_11__.EAP_IDLE )
                        _managers_eventmanager__WEBPACK_IMPORTED_MODULE_2__.eventManager.dispatchEvent( _gui_menudefs__WEBPACK_IMPORTED_MODULE_10__.EGE_MENU_DOWN_ACTION, pressType );

                    else if( (pressType = _managers_actionmanager__WEBPACK_IMPORTED_MODULE_1__.actionManager.wasAction( event, this.leftAction )) > _common_defs__WEBPACK_IMPORTED_MODULE_11__.EAP_IDLE )
                        _managers_eventmanager__WEBPACK_IMPORTED_MODULE_2__.eventManager.dispatchEvent( _gui_menudefs__WEBPACK_IMPORTED_MODULE_10__.EGE_MENU_LEFT_ACTION, pressType );

                    else if( (pressType = _managers_actionmanager__WEBPACK_IMPORTED_MODULE_1__.actionManager.wasAction( event, this.rightAction )) > _common_defs__WEBPACK_IMPORTED_MODULE_11__.EAP_IDLE )
                        _managers_eventmanager__WEBPACK_IMPORTED_MODULE_2__.eventManager.dispatchEvent( _gui_menudefs__WEBPACK_IMPORTED_MODULE_10__.EGE_MENU_RIGHT_ACTION, pressType );

                    else if( (pressType = _managers_actionmanager__WEBPACK_IMPORTED_MODULE_1__.actionManager.wasAction( event, this.tabLeft )) > _common_defs__WEBPACK_IMPORTED_MODULE_11__.EAP_IDLE )
                        _managers_eventmanager__WEBPACK_IMPORTED_MODULE_2__.eventManager.dispatchEvent( _gui_menudefs__WEBPACK_IMPORTED_MODULE_10__.EGE_MENU_TAB_LEFT, pressType );

                    else if( (pressType = _managers_actionmanager__WEBPACK_IMPORTED_MODULE_1__.actionManager.wasAction( event, this.tabRight )) > _common_defs__WEBPACK_IMPORTED_MODULE_11__.EAP_IDLE )
                        _managers_eventmanager__WEBPACK_IMPORTED_MODULE_2__.eventManager.dispatchEvent( _gui_menudefs__WEBPACK_IMPORTED_MODULE_10__.EGE_MENU_TAB_RIGHT, pressType );

                    // If none of the predefined actions have been hit, just send the message for processing
                    else
                    {
                        this.handleEventForTrees( event );
                    }
                }
            }
        }
    }
    
    // 
    //  DESC: Handle input events depending on if this is a menu or interface tree
    //
    handleEventForTrees( event )
    {
        let menuActive = false;

        for( let i = 0; i < this.activeMenuTreeAry.length; ++i )
        {
            // See if there's an active tree
            menuActive |= this.activeMenuTreeAry[i].isActive();

            // Even if a menu tree is not active, it needs to receive events to become active
            this.activeMenuTreeAry[i].handleEvent( event );
        }

        // Only allow event handling for interface menus when regular menus are not active
        if( !menuActive )
        {
            for( let i = 0; i < this.activeInterTreeAry.length; ++i )
            {
                if( this.activeInterTreeAry[i].isActive() )
                    this.activeInterTreeAry[i].handleEvent( event );
            }
        }
    }
    
    // 
    //  DESC: Handle input events depending on if this is a menu or interface tree
    //
    handleEventForScrolling( event )
    {
        if( this.active )
        {
            if( !this.handleMenuScrolling( event, this.activeMenuTreeAry ) )
            {
                // Only allow event handling for interface menus when regular menus are not active
                this.handleMenuScrolling( event, this.activeInterTreeAry );
            }
        }
    }
    
    // 
    //  DESC: Handle input events for menu scrolling
    //
    handleMenuScrolling( event, activeTreeAry )
    {
        let menuActive = false;

        for( let i = 0; i < activeTreeAry.length; ++i )
        {
            // See if there's an active menu
            if( activeTreeAry[i].isActive() )
            {
                menuActive = true;

                let scrollParam = activeTreeAry[i].getScrollParam( event.type );

                // If scrolling is allowed, start the timer
                if( scrollParam.canScroll( event.type ) )
                {
                    this.scrollTimerId = setTimeout(
                        () =>
                        {
                            this.scrollTimerId = setInterval(
                                () => _managers_eventmanager__WEBPACK_IMPORTED_MODULE_2__.eventManager.dispatchEvent( scrollParam.msg ),
                                scrollParam.scrollDelay );
                                
                            _managers_eventmanager__WEBPACK_IMPORTED_MODULE_2__.eventManager.dispatchEvent( scrollParam.msg );
                        }, 
                        scrollParam.startDelay );
                        
                    break;
                }
            }
        }

        return menuActive;
    }
    
    // 
    //  DESC: Update the menu
    //
    update()
    {
        if( this.active )
        {
            if( !this.updateMenu( this.activeMenuTreeAry ) )
            {
                // Only allow Updating for interface menus when regular menus are not active
                this.updateMenu( this.activeInterTreeAry );
            }
        }
    }

    // 
    //  DESC: Update the menu
    //
    updateMenu( activeTreeAry )
    {
        let menuActive = false;

        for( let i = 0; i < activeTreeAry.length; ++i )
        {
            // See if there's an active menu
            if( activeTreeAry[i].isActive() )
            {
                menuActive = true;
                activeTreeAry[i].update();
            }
        }

        return menuActive;
    }
    
    // 
    //  DESC: Transform the menu
    //
    transform()
    {
        if( this.active )
        {
            if( !this.transformMenu( this.activeMenuTreeAry ) )
            {
                // Only allow Updating for interface menus when regular menus are not active
                this.transformMenu( this.activeInterTreeAry );
            }
        }

    }

    // 
    //  DESC: Transform the menu
    //
    transformMenu( activeTreeAry )
    {
        let menuActive = false;

        for( let i = 0; i < activeTreeAry.length; ++i )
        {
            // See if there's an active menu
            if( activeTreeAry[i].isActive() )
            {
                menuActive = true;
                activeTreeAry[i].transform();
            }
        }

        return menuActive;
    }
    
    // 
    //  DESC: Render menus
    //
    render()
    {
        if( this.active )
        {
            for( let i = 0; i < this.activeMenuTreeAry.length; ++i )
                if( this.activeMenuTreeAry[i].isActive() )
                    this.activeMenuTreeAry[i].render( this.camera );
        }
    }

    // 
    //  DESC: Render interface menus
    //
    renderInterface( matrix )
    {
        if( this.active )
        {
            for( let i = 0; i < this.activeInterTreeAry.length; ++i )
                if( this.activeInterTreeAry[i].isActive() )
                    this.activeInterTreeAry[i].render( matrix );
        }
    }
    
    // 
    //  DESC: Is this standard menu system active?
    //
    isMenuActive()
    {
        if( this.active )
            for( let i = 0; i < this.activeMenuTreeAry.length; ++i )
                if( this.activeMenuTreeAry[i].isActive() )
                    return true;

        return false;
    }

    // 
    //  Is a menu item active
    //
    isMenuItemActive()
    {
        let result = false;

        if( this.active )
        {
            for( let i = 0; i < this.activeMenuTreeAry.length; ++i )
            {
                if( this.activeMenuTreeAry[i].isActive() )
                {
                    result = this.activeMenuTreeAry[i].isMenuItemActive();

                    break;
                }
            }
        }

        return result;
    }

    // 
    //  Is a interface item active
    //
    isInterfaceItemActive()
    {
        let result = false;

        if( this.active )
        {
            for( let i = 0; i < this.activeInterTreeAry.length; ++i )
            {
                if( this.activeInterTreeAry[i].isActive() )
                {
                    result = this.activeInterTreeAry[i].isMenuItemActive();

                    break;
                }
            }
        }

        return result;
    }

    // 
    //  Set the active state
    //
    setActiveState()
    {
        this.active = false;

        for( let i = 0; i < this.activeMenuTreeAry.length; ++i )
        {
            if( this.activeMenuTreeAry[i].isActive() )
            {
                this.active = true;
                break;
            }
        }

        if( !this.active )
        {
            for( let i = 0; i < this.activeInterTreeAry.length; ++i )
            {
                if( this.activeInterTreeAry[i].isActive() )
                {
                    this.active = true;
                    break;
                }
            }
        }
    }
    
    // 
    //  Get the menu in question
    //
    getMenu( name )
    {
        for( let groupMap of this.menuMapMap.values() )
        {
            let menu = groupMap.get( name );
            if( menu !== undefined )
                return menu;
        }

        throw new Error( `Menu being asked for is missing (${name})!` );
    }
    
    // 
    //  Get the reference to the control in question
    //
    getMenuControl( name, controlName )
    {
        let menu = this.getMenu( name );
        let control = menu.getControl( controlName );
        
        if( control === null )
            throw new Error( `Menu control being asked for is missing (${name})!` );

        return control;
    }

    // 
    //  Get the pointer to the active control - can return null
    //
    getActiveControl( name )
    {
        let menu = this.getMenu(name);
        return menu.GetActiveControl();
    }

    // 
    //  Get the first active menu
    //  NOTE: Only call this function if you are certain it will not fail
    //
    getActiveMenu()
    {
        let menu = null;

        for( let i = 0; i < this.activeMenuTreeAry.length; ++i )
        {
            if( this.activeMenuTreeAry[i].isActive() )
            {
                menu = this.activeMenuTreeAry[i].getActiveMenu();
                break;
            }
        }

        if( menu === null )
            throw new Error( 'There is no active menu!' );

        return menu;
    }
    
    // 
    //  Get a reference to the tree
    //
    getTree( treeStr )
    {
        for( let groupMap of this.menuTreeMapMap.values() )
        {
            for( let [ key, tree ] of groupMap.entries() )
            {
                if( key === treeStr )
                    return tree;
            }
        }

        // If you got this far, it's a problem
        throw new Error( `Menu tree doesn't exist (${treeStr})!` );
    }
    
    // 
    //  Get a reference to the tree based on group
    //
    getTreeGroup( group, treeStr )
    {
        let groupMap = this.menuTreeMapMap.get( group );
        if( groupMap !== undefined )
        {
            // Find the tree in the map
            let tree = groupMap.get( treeStr );
            if( tree !== undefined )
                return tree;
            
            throw new Error( `Menu tree doesn't exist (${group} - ${treeStr})!` );
        }
        
        throw new Error( `Menu tree group doesn't exist (${group} - ${treeStr})!` );
    }

    // 
    //  Get a reference to the active tree
    //
    getActiveTree()
    {
        let tree = null;

        for( let i = 0; i < this.activeMenuTreeAry.length; ++i )
        {
            if( this.activeMenuTreeAry[i].isActive() )
            {
                tree = this.activeMenuTreeAry[i];
                break;
            }
        }

        return tree;
    }
    
    // 
    //  DESC: See if the tree is in the active list
    //
    isTreeInActivelist( treeStr )
    {
        for( let groupMap of this.menuTreeMapMap.values() )
        {
            for( let [ key, tree ] of groupMap.entries() )
            {
                if( key === treeStr )
                {
                    if( tree.interfaceMenu )
                    {
                        let index = this.activeInterTreeAry.indexOf( tree );
                        if( index > -1 )
                            return true;
                    }
                    else
                    {
                        let index = this.activeMenuTreeAry.indexOf( tree );
                        if( index > -1 )
                            return true;
                    }
                }
            }
        }
        
        return false;
    }

    // 
    //  Reset the transform
    //
    resetTransform()
    {
        for( let groupMap of this.menuMapMap.values() )
            for( let menu of groupMap.values() )
                menu.forceTransform();
    }

    // 
    //  Reset the dynamic positions of menus
    //
    resetDynamicOffset()
    {
        for( let groupMap of this.menuMapMap.values() )
            for( let menu of groupMap.values() )
                menu.resetDynamicPos();
    }
    
    // 
    //  DESC: allow event handling access function
    //
    get allowEventHandling() { return this.allow; }
    set allowEventHandling( value ) { this.allow = value; }

}

var menuManager = new MenuManager;


/***/ }),
/* 25 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ManagerBase": () => (/* binding */ ManagerBase)
/* harmony export */ });
/* harmony import */ var _utilities_genfunc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(26);

//
//  FILE NAME: managerbase.js
//  DESC:      Base class for common manager behaviors
//





class ManagerBase
{
    constructor()
    {
        this.listTableMap = new Map;
    }
    
    // 
    //  DESC: Load the data list tables from file path
    //
    loadListTable( filePath )
    {
        return _utilities_genfunc__WEBPACK_IMPORTED_MODULE_0__.downloadFile( 'xml', filePath,
            ( xmlNode ) => this.loadListTableFromNode( xmlNode ));
    }

    // 
    //  DESC: Load the data list tables from obj
    //
    loadListTableFromObj( obj )
    {
        for( const [ key, value ] of Object.entries(obj) )
            this.listTableMap.set( key, value );
    }
    
    // 
    //  DESC: Load the data list tables from node
    //
    loadListTableFromNode( xmlNode )
    {
        if( xmlNode )
        {
            let groupLst = xmlNode.getElementsByTagName('groupList');
            
            for( let i = 0; i < groupLst.length; ++i )
            {
                let groupName = groupLst[i].getAttribute('groupName');

                let fileLst = groupLst[i].getElementsByTagName('file');
                if( fileLst.length )
                {
                    let pathAry = [];
                    for( let j = 0; j < fileLst.length; ++j )
                        pathAry.push( fileLst[j].getAttribute('path') );

                    this.listTableMap.set( groupName, pathAry );
                }
            }
        }
    }
    
    //
    //  DESC: Load the group array
    //
    loadGroupAry( groupNameStr, groupMapMap, groupAry )
    {
        let promiseAry = [];

        for( let grp = 0; grp < groupAry.length; ++grp )
        {
            let group = groupAry[grp];
            
            // Make sure the group we are looking for has been defined in the list table file
            let pathAry = this.listTableMap.get( group );
            if( pathAry !== undefined )
            {
                // Load the group data if it doesn't already exist
                if( groupMapMap.get( group ) === undefined )
                {
                    // Create a new group map inside of our map
                    groupMapMap.set( group, new Map );

                    promiseAry.push( this.load( group ) );
                }
                else
                {
                    throw new Error( `${groupNameStr} group has alread been loaded (${group})!` );
                }
            }
            else
            {
                throw new Error( `${groupNameStr} group name can't be found (${group})!` );
            }
        }

        return Promise.all( promiseAry );
    }

    //
    //  DESC: Load the group
    //
    load( group, allowError = true )
    {
        let promiseAry = [];

        // Make sure the group we are looking for has been defined in the list table file
        let filePathAry = this.listTableMap.get( group );
        if( filePathAry !== undefined )
        {
            for( let i = 0; i < filePathAry.length; ++i )
            {
                let filePath = filePathAry[i];
                promiseAry.push( 
                    _utilities_genfunc__WEBPACK_IMPORTED_MODULE_0__.downloadFile( 'xml', filePath )
                        .then(( xmlNode ) => this.loadFromNode( group, xmlNode, filePath ))
                        .catch(( error ) => { console.error(error.stack); throw error; }));
            }
        }
        else if( allowError )
        {
            if( this.listTableMap.size == 0 )
                throw new Error( `Need to load the list table (${group})!` );
            else
                throw new Error( `Group description in list table does not exist (${group})!` );
        }

        return Promise.all( promiseAry );
    }
}


/***/ }),
/* 26 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "downloadFile": () => (/* binding */ downloadFile),
/* harmony export */   "countStrOccurrence": () => (/* binding */ countStrOccurrence),
/* harmony export */   "modulus": () => (/* binding */ modulus),
/* harmony export */   "randomInt": () => (/* binding */ randomInt),
/* harmony export */   "randomArbitrary": () => (/* binding */ randomArbitrary),
/* harmony export */   "shuffle": () => (/* binding */ shuffle),
/* harmony export */   "stringLoadXML": () => (/* binding */ stringLoadXML),
/* harmony export */   "getKey": () => (/* binding */ getKey)
/* harmony export */ });
/* harmony import */ var _managers_signalmanager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);

// 
//  FILE NAME: genfunc.js
//  DESC:      General mutipurpose functions
//





var sessionCacheBustNo = Math.random();

// 
//  DESC: Load files via a promise
//
function downloadFile( fileType, filePath )
{
    return new Promise((resolve, reject) => {
            
        let request = null;
        
        if( fileType !== 'img' )
            request = new XMLHttpRequest();
        
        if( fileType === 'xml' )
        {
            //console.log(`Load XML: ${filePath}`);
            request.responseType = 'document';
            request.overrideMimeType('text/xml');
        }
        else if( fileType === 'txt' )
        {
            //console.log(`Load Text: ${filePath}`);
            request.responseType = 'text';
            request.overrideMimeType('text/plain');
        }
        else if( fileType === 'binary' )
        {
            //console.log(`Load Binary: ${filePath}`);
            request.responseType = 'arraybuffer';
        }
        else if( fileType === 'img' )
        {
            //console.log(`Load Image: ${filePath}`);
        }
        else
        {
            throw new Error( `Unknown file type (${filePath})!` );
        }

        if( request )
        {
            // Asynchronous reading of an xml file. Synchronous has been deprecated
            request.onreadystatechange =
                function()
                {
                    if( this.readyState === 4 )
                    {
                        if( (this.status >= 200 && this.status < 300) || this.status === 304 ) 
                        {
                            // This need to be called before the "resolve" is
                            _managers_signalmanager__WEBPACK_IMPORTED_MODULE_0__.signalManager.broadcast_loadComplete();

                            if( fileType === 'xml' && this.responseXML )
                                resolve(this.responseXML.childNodes[0]);

                            else if( fileType === 'txt' && this.responseText )
                                resolve(this.responseText);

                            else if( fileType === 'binary' && this.response )
                                resolve(this.response);
                                
                            else
                                reject( Error(`Error Loading (${filePath}), file type (${fileType}) not defined!`) );
                        }
                        else
                        {
                            reject( Error(`HTTP Request failed: ${filePath}`) );
                        }
                    }
                }

            // Define which file to open and send the request. True = asynchronous
            request.open('GET', filePath + '?cache_buster=' + sessionCacheBustNo, true);
            request.send();
        }
        // Images are handled differently
        else
        {
            let image = new Image();
            
            image.onload = () => { _managers_signalmanager__WEBPACK_IMPORTED_MODULE_0__.signalManager.broadcast_loadComplete(); resolve(image); }
            image.onerror = () => reject( Error(`Error downloading file: ${filePath}`) );

            image.src = filePath;
        }
    });
}

// 
//  DESC: Count the number of occurrences of sub string
//
function countStrOccurrence( searchStr, subStr )
{
    let result = 0;
    let found = -1;

    do
    {
        found = searchStr.indexOf( subStr, found+1 );

        if( found != -1 )
            ++result;
    }
    while( found != -1 );

    return result;
}

// 
//  DESC: Perform a modulus operation on the passed in floats
//
function modulus( v1, v2 )
{
    return (v1 - v2 * Math.floor(v1 / v2));
}

// 
//  DESC: Generate a random number
//
function randomInt( min, max )
{
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

function randomArbitrary( min, max )
{
    return Math.floor(Math.random() * (max - min)) + min;
}

// 
//  DESC: Shuffle array
//
function shuffle( array )
{
    if( array.length > 2 )
    {
        let currentIndex = array.length, temp, randomIndex;

        // Get the last sound that was just played
        let oldLastElement = array[array.length-1];

        // While there remain elements to shuffle...
        while (0 !== currentIndex)
        {
            // Pick a remaining element...
            randomIndex = Math.floor( Math.random() * currentIndex );
            currentIndex -= 1;

            // And swap it with the current element.
            temp = array[currentIndex];
            array[currentIndex] = array[randomIndex];
            array[randomIndex] = temp;
        }
        
        // Make sure the new first element is not the old last one.
        if( oldLastElement === array[0] )
        {
            randomIndex = Math.trunc(array.length / 2);
            array[0] = array[randomIndex];
            array[randomIndex] = oldLastElement;
        }
    }
}

// 
//  DESC: Load the XML string into a dom object
//
function stringLoadXML( stringData )
{
    let parser = new DOMParser();
    return parser.parseFromString( stringData, "application/xml" );
}

// 
//  DESC: Find a key based on map value
//
function getKey(map, searchValue)
{
    for (let [key, value] of map.entries())
    {
        if( value === searchValue )
            return key;
    }

    return undefined;
}

/***/ }),
/* 27 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UNBOUND_KEYCODE_STR_ID": () => (/* binding */ UNBOUND_KEYCODE_STR_ID),
/* harmony export */   "UNBOUND_KEYCODE_ID": () => (/* binding */ UNBOUND_KEYCODE_ID),
/* harmony export */   "MOUSE_BUTTON_LEFT": () => (/* binding */ MOUSE_BUTTON_LEFT),
/* harmony export */   "MOUSE_BUTTON_MIDDLE": () => (/* binding */ MOUSE_BUTTON_MIDDLE),
/* harmony export */   "MOUSE_BUTTON_RIGHT": () => (/* binding */ MOUSE_BUTTON_RIGHT),
/* harmony export */   "MOUSE_BUTTON_1X": () => (/* binding */ MOUSE_BUTTON_1X),
/* harmony export */   "MOUSE_BUTTON_2X": () => (/* binding */ MOUSE_BUTTON_2X),
/* harmony export */   "MOUSE_BUTTON_3X": () => (/* binding */ MOUSE_BUTTON_3X),
/* harmony export */   "MOUSE_BUTTON_4X": () => (/* binding */ MOUSE_BUTTON_4X),
/* harmony export */   "MOUSE_BUTTON_5X": () => (/* binding */ MOUSE_BUTTON_5X),
/* harmony export */   "MOUSE_BUTTON_6X": () => (/* binding */ MOUSE_BUTTON_6X),
/* harmony export */   "MOUSE_BUTTON_7X": () => (/* binding */ MOUSE_BUTTON_7X),
/* harmony export */   "MOUSE_BUTTON_8X": () => (/* binding */ MOUSE_BUTTON_8X),
/* harmony export */   "actionManager": () => (/* binding */ actionManager)
/* harmony export */ });
/* harmony import */ var _common_keycodeaction__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(28);
/* harmony import */ var _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29);
/* harmony import */ var _utilities_localstorage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);
/* harmony import */ var _utilities_genfunc__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(26);
/* harmony import */ var _common_defs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(6);
// 
//  FILE NAME: actionmanager.js
//  DESC:      Class for handling action mapping
//









const UNBOUND_KEYCODE_STR_ID     = '---',
             UNBOUND_KEYCODE_ID         = -1;

const MOUSE_BUTTON_LEFT          = 0,
             MOUSE_BUTTON_MIDDLE        = 1,
             MOUSE_BUTTON_RIGHT         = 2,
             MOUSE_BUTTON_1X            = 3,
             MOUSE_BUTTON_2X            = 4,
             MOUSE_BUTTON_3X            = 5,
             MOUSE_BUTTON_4X            = 6,
             MOUSE_BUTTON_5X            = 7,
             MOUSE_BUTTON_6X            = 8,
             MOUSE_BUTTON_7X            = 9,
             MOUSE_BUTTON_8X            = 10;

class ActionManager
{
    constructor()
    {
        this.keyboardKeyCodeMap = new Map;
        this.mouseKeyCodeMap = new Map;
        this.gamepadKeyCodeMap = new Map;
        
        // Action maps
        this.keyboardActionMap = new Map;
        this.mouseActionMap = new Map;
        this.gamepadActionMap = new Map;
        
        // Flag to allow action handling
        this.allowAction = true;
        
        // Last device used
        this.lastDeviceUsed = _common_defs__WEBPACK_IMPORTED_MODULE_4__.DEVICE_NULL;

        // xml node
        this.mainNode = null;

        // action mapping dictionary loaded from json
        this.actionDict = null;
        
        this.keyboardKeyCodeMap.set( UNBOUND_KEYCODE_STR_ID, UNBOUND_KEYCODE_ID );
        this.keyboardKeyCodeMap.set( 'ENTER',        'Enter' );
        this.keyboardKeyCodeMap.set( 'ESCAPE',       'Escape' );
        this.keyboardKeyCodeMap.set( 'ARROW UP',     'ArrowUp' );
        this.keyboardKeyCodeMap.set( 'ARROW DOWN',   'ArrowDown' );
        this.keyboardKeyCodeMap.set( 'ARROW LEFT',   'ArrowLeft' );
        this.keyboardKeyCodeMap.set( 'ARROW RIGHT',  'ArrowRight' );
        this.keyboardKeyCodeMap.set( 'A',            'KeyA' );
        this.keyboardKeyCodeMap.set( 'B',            'KeyB' );
        this.keyboardKeyCodeMap.set( 'C',            'KeyC' );
        this.keyboardKeyCodeMap.set( 'D',            'KeyD' );
        this.keyboardKeyCodeMap.set( 'E',            'KeyE' );
        this.keyboardKeyCodeMap.set( 'F',            'KeyF' );
        this.keyboardKeyCodeMap.set( 'G',            'KeyG' );
        this.keyboardKeyCodeMap.set( 'H',            'KeyH' );
        this.keyboardKeyCodeMap.set( 'I',            'KeyI' );
        this.keyboardKeyCodeMap.set( 'J',            'KeyJ' );
        this.keyboardKeyCodeMap.set( 'K',            'KeyK' );
        this.keyboardKeyCodeMap.set( 'L',            'KeyL' );
        this.keyboardKeyCodeMap.set( 'M',            'KeyM' );
        this.keyboardKeyCodeMap.set( 'N',            'KeyN' );
        this.keyboardKeyCodeMap.set( 'O',            'KeyO' );
        this.keyboardKeyCodeMap.set( 'P',            'KeyP' );
        this.keyboardKeyCodeMap.set( 'Q',            'KeyQ' );
        this.keyboardKeyCodeMap.set( 'R',            'KeyR' );
        this.keyboardKeyCodeMap.set( 'S',            'KeyS' );
        this.keyboardKeyCodeMap.set( 'T',            'KeyT' );
        this.keyboardKeyCodeMap.set( 'U',            'KeyU' );
        this.keyboardKeyCodeMap.set( 'V',            'KeyV' );
        this.keyboardKeyCodeMap.set( 'W',            'KeyW' );
        this.keyboardKeyCodeMap.set( 'X',            'KeyX' );
        this.keyboardKeyCodeMap.set( 'Y',            'KeyY' );
        this.keyboardKeyCodeMap.set( 'Z',            'KeyZ' );
        this.keyboardKeyCodeMap.set( '0',            'Digit0' );
        this.keyboardKeyCodeMap.set( '1',            'Digit1' );
        this.keyboardKeyCodeMap.set( '2',            'Digit2' );
        this.keyboardKeyCodeMap.set( '3',            'Digit3' );
        this.keyboardKeyCodeMap.set( '4',            'Digit4' );
        this.keyboardKeyCodeMap.set( '5',            'Digit5' );
        this.keyboardKeyCodeMap.set( '6',            'Digit6' );
        this.keyboardKeyCodeMap.set( '7',            'Digit7' );
        this.keyboardKeyCodeMap.set( '8',            'Digit8' );
        this.keyboardKeyCodeMap.set( '9',            'Digit9' );
        this.keyboardKeyCodeMap.set( 'F1',           'F1' );
        this.keyboardKeyCodeMap.set( 'F2',           'F2' );
        this.keyboardKeyCodeMap.set( 'F3',           'F3' );
        this.keyboardKeyCodeMap.set( 'F4',           'F4' );
        this.keyboardKeyCodeMap.set( 'F5',           'F5' );
        this.keyboardKeyCodeMap.set( 'F6',           'F6' );
        this.keyboardKeyCodeMap.set( 'F7',           'F7' );
        this.keyboardKeyCodeMap.set( 'F8',           'F8' );
        this.keyboardKeyCodeMap.set( 'F9',           'F9' );
        this.keyboardKeyCodeMap.set( 'F10',          'F10' );
        this.keyboardKeyCodeMap.set( 'F11',          'F11' );
        this.keyboardKeyCodeMap.set( 'F12',          'F12' );
        this.keyboardKeyCodeMap.set( 'NUMPAD 0',     'Numpad0' );
        this.keyboardKeyCodeMap.set( 'NUMPAD 1',     'Numpad1' );
        this.keyboardKeyCodeMap.set( 'NUMPAD 2',     'Numpad2' );
        this.keyboardKeyCodeMap.set( 'NUMPAD 3',     'Numpad3' );
        this.keyboardKeyCodeMap.set( 'NUMPAD 4',     'Numpad4' );
        this.keyboardKeyCodeMap.set( 'NUMPAD 5',     'Numpad5' );
        this.keyboardKeyCodeMap.set( 'NUMPAD 6',     'Numpad6' );
        this.keyboardKeyCodeMap.set( 'NUMPAD 7',     'Numpad7' );
        this.keyboardKeyCodeMap.set( 'NUMPAD 8',     'Numpad8' );
        this.keyboardKeyCodeMap.set( 'NUMPAD 9',     'Numpad9' );
        this.keyboardKeyCodeMap.set( 'NUM LOCK',     'NumLock' );
        this.keyboardKeyCodeMap.set( 'NUMPAD /',     'NumpadDivide' );
        this.keyboardKeyCodeMap.set( 'NUMPAD *',     'NumpadMultiply' );
        this.keyboardKeyCodeMap.set( 'NUMPAD -',     'NumpadSubtract' );
        this.keyboardKeyCodeMap.set( 'NUMPAD +',     'NumpadAdd' );
        this.keyboardKeyCodeMap.set( 'NUMPAD ENTER', 'NumpadEnter' );
        this.keyboardKeyCodeMap.set( 'NUMPAD .',     'NumpadDecimal' );
        this.keyboardKeyCodeMap.set( 'CTRL LEFT',    'ControlLeft' );
        this.keyboardKeyCodeMap.set( 'SHIFT LEFT',   'ShiftLeft' );
        this.keyboardKeyCodeMap.set( 'ALT LEFT',     'AltLeft' );
        this.keyboardKeyCodeMap.set( 'CTRL RIGHT',   'ControlRight' );
        this.keyboardKeyCodeMap.set( 'SHIFT RIGHT',  'ShiftRight' );
        this.keyboardKeyCodeMap.set( 'ALT RIGHT',    'AltRight' );
        this.keyboardKeyCodeMap.set( 'PRINT SCREEN', 'PrintScreen' );
        this.keyboardKeyCodeMap.set( 'SCROLL LOCK',  'ScrollLock' );
        this.keyboardKeyCodeMap.set( 'PAUSE',        'Pause' );
        this.keyboardKeyCodeMap.set( 'END',          'End' );
        this.keyboardKeyCodeMap.set( 'INSERT',       'Insert' );
        this.keyboardKeyCodeMap.set( 'DELETE',       'Delete' );
        this.keyboardKeyCodeMap.set( 'HOME',         'Home' );
        this.keyboardKeyCodeMap.set( 'PAGE UP',      'PageUp' );
        this.keyboardKeyCodeMap.set( 'PAGE DOWN',    'PageDown' );
        this.keyboardKeyCodeMap.set( 'BACKSPACE',    'Backspace' );
        this.keyboardKeyCodeMap.set( 'TAB',          'Tab' );
        this.keyboardKeyCodeMap.set( 'SPACE',        'Space' );
        this.keyboardKeyCodeMap.set( ',',            'Comma' );
        this.keyboardKeyCodeMap.set( '-',            'Minus' );
        this.keyboardKeyCodeMap.set( '.',            'Period' );
        this.keyboardKeyCodeMap.set( '/',            'Slash' );
        this.keyboardKeyCodeMap.set( '=',            'Equal' );
        this.keyboardKeyCodeMap.set( ';',            'Semicolon' );
        this.keyboardKeyCodeMap.set( '[',            'BracketLeft' );
        this.keyboardKeyCodeMap.set( '\\',           'Backslash' );
        this.keyboardKeyCodeMap.set( ']',            'BracketRight' );
        this.keyboardKeyCodeMap.set( '`',            'Backquote' );
        this.keyboardKeyCodeMap.set( "'",            'Quote' );
        this.keyboardKeyCodeMap.set( 'META LEFT',    'MetaLeft' );
        this.keyboardKeyCodeMap.set( 'META RIGHT',   'MetaRight' );
        this.keyboardKeyCodeMap.set( 'CONTEXT MENU', 'ContextMenu' );

        this.keyboardKeyCodeMap.set( 'LAUNCH MAIL',      'LaunchMail' );
        this.keyboardKeyCodeMap.set( 'LAUNCH APP 1',     'LaunchApp1' );
        this.keyboardKeyCodeMap.set( 'LAUNCH APP 2',     'LaunchApp2' );
        this.keyboardKeyCodeMap.set( 'MEDIA TRACK PREV', 'MediaTrackPrevious' );
        this.keyboardKeyCodeMap.set( 'MEDIA TRACK NEXT', 'MediaTrackNext' );
        this.keyboardKeyCodeMap.set( 'MEDIA PLAY PAUSE', 'MediaPlayPause' );
        
        this.mouseKeyCodeMap.set( UNBOUND_KEYCODE_STR_ID, UNBOUND_KEYCODE_ID );
        this.mouseKeyCodeMap.set( 'LEFT MOUSE',   MOUSE_BUTTON_LEFT );
        this.mouseKeyCodeMap.set( 'MIDDLE MOUSE', MOUSE_BUTTON_MIDDLE );
        this.mouseKeyCodeMap.set( 'RIGHT MOUSE',  MOUSE_BUTTON_RIGHT );
        this.mouseKeyCodeMap.set( 'MOUSE 1X',     MOUSE_BUTTON_1X );
        this.mouseKeyCodeMap.set( 'MOUSE 2X',     MOUSE_BUTTON_2X );
        this.mouseKeyCodeMap.set( 'MOUSE 3X',     MOUSE_BUTTON_3X );
        this.mouseKeyCodeMap.set( 'MOUSE 4X',     MOUSE_BUTTON_4X );
        this.mouseKeyCodeMap.set( 'MOUSE 5X',     MOUSE_BUTTON_5X );
        this.mouseKeyCodeMap.set( 'MOUSE 6X',     MOUSE_BUTTON_6X );
        this.mouseKeyCodeMap.set( 'MOUSE 7X',     MOUSE_BUTTON_7X );
        this.mouseKeyCodeMap.set( 'MOUSE 8',      MOUSE_BUTTON_8X );

        this.gamepadKeyCodeMap.set( UNBOUND_KEYCODE_STR_ID,     UNBOUND_KEYCODE_ID );
        this.gamepadKeyCodeMap.set( 'A',             _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_A );
        this.gamepadKeyCodeMap.set( 'B',             _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_B );
        this.gamepadKeyCodeMap.set( 'X',             _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_X );
        this.gamepadKeyCodeMap.set( 'Y',             _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_Y );
        this.gamepadKeyCodeMap.set( 'L BUMPER',      _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_L_BUMPER );
        this.gamepadKeyCodeMap.set( 'R BUMPER',      _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_R_BUMPER );
        this.gamepadKeyCodeMap.set( 'L TRIGGER',     _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_L_TRIGGER );
        this.gamepadKeyCodeMap.set( 'R TRIGGER',     _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_R_TRIGGER );
        this.gamepadKeyCodeMap.set( 'BACK',          _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_BACK );
        this.gamepadKeyCodeMap.set( 'START',         _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_START );
        this.gamepadKeyCodeMap.set( 'L STICK',       _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_LEFTSTICK );
        this.gamepadKeyCodeMap.set( 'R STICK',       _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_RIGHTSTICK );
        this.gamepadKeyCodeMap.set( 'UP',            _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_DPAD_UP );
        this.gamepadKeyCodeMap.set( 'DOWN',          _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_DPAD_DOWN );
        this.gamepadKeyCodeMap.set( 'LEFT',          _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_DPAD_LEFT );
        this.gamepadKeyCodeMap.set( 'RIGHT',         _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_DPAD_RIGHT );
        this.gamepadKeyCodeMap.set( 'GUIDE',         _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_GUIDE );

        // Key codes to use analog sticks as buttons
        this.gamepadKeyCodeMap.set( 'L STICK UP',    _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_L_STICK_UP );
        this.gamepadKeyCodeMap.set( 'L STICK DOWN',  _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_L_STICK_DOWN );
        this.gamepadKeyCodeMap.set( 'L STICK LEFT',  _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_L_STICK_LEFT );
        this.gamepadKeyCodeMap.set( 'L STICK RIGHT', _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_L_STICK_RIGHT );
        this.gamepadKeyCodeMap.set( 'R STICK UP',    _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_R_STICK_UP );
        this.gamepadKeyCodeMap.set( 'R STICK DOWN',  _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_R_STICK_DOWN );
        this.gamepadKeyCodeMap.set( 'R STICK LEFT',  _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_R_STICK_LEFT );
        this.gamepadKeyCodeMap.set( 'R STICK RIGHT', _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_R_STICK_RIGHT );
    }

    // 
    //  DESC: Load data from action dictionary
    //
    loadFromObj( obj )
    {
        if( obj )
        {
            this.actionDict = obj;
            let savedActionDict = _utilities_localstorage__WEBPACK_IMPORTED_MODULE_2__.localStorage.get( 'keybinding' );
            if( savedActionDict )
                this.actionDict = JSON.parse( savedActionDict );

            // Load the keyboard mapping
            this.loadAction( this.actionDict.keyboardMapping.playerHidden, this.keyboardKeyCodeMap, this.keyboardActionMap );
            this.loadAction( this.actionDict.keyboardMapping.playerVisible, this.keyboardKeyCodeMap, this.keyboardActionMap );

            // Load the mouse mapping
            this.loadAction( this.actionDict.mouseMapping.playerHidden, this.mouseKeyCodeMap, this.mouseActionMap );
            this.loadAction( this.actionDict.mouseMapping.playerVisible, this.mouseKeyCodeMap, this.mouseActionMap );

            // Load the gamepad mapping
            this.loadAction( this.actionDict.gamepadMapping.playerHidden, this.gamepadKeyCodeMap, this.gamepadActionMap );
            this.loadAction( this.actionDict.gamepadMapping.playerVisible, this.gamepadKeyCodeMap, this.gamepadActionMap );
        }
    }

    // 
    //  DESC: Setup the gamepad mapping based on controller mapping mode
    //
    initGamepadMapping( mapping )
    {
        // Remap for non-standard mapping
        if( mapping === '' )
        {
            this.gamepadKeyCodeMap = new Map;
            this.gamepadActionMap = new Map;

            this.gamepadKeyCodeMap.set( UNBOUND_KEYCODE_STR_ID,     UNBOUND_KEYCODE_ID );
            this.gamepadKeyCodeMap.set( 'A',             _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_A );
            this.gamepadKeyCodeMap.set( 'B',             _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_B );
            this.gamepadKeyCodeMap.set( 'X',             _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_X );
            this.gamepadKeyCodeMap.set( 'Y',             _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_Y );
            this.gamepadKeyCodeMap.set( 'L BUMPER',      _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_L_BUMPER );
            this.gamepadKeyCodeMap.set( 'R BUMPER',      _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_R_BUMPER );
            this.gamepadKeyCodeMap.set( 'BACK',          _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.ALT_GAMEPAD_BUTTON_BACK );
            this.gamepadKeyCodeMap.set( 'START',         _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.ALT_GAMEPAD_BUTTON_START );
            this.gamepadKeyCodeMap.set( 'GUIDE',         _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.ALT_GAMEPAD_BUTTON_GUIDE );
            this.gamepadKeyCodeMap.set( 'L STICK',       _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.ALT_GAMEPAD_BUTTON_LEFTSTICK );
            this.gamepadKeyCodeMap.set( 'R STICK',       _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.ALT_GAMEPAD_BUTTON_RIGHTSTICK );

            // Key codes to use analog sticks as buttons
            this.gamepadKeyCodeMap.set( 'L STICK UP',    _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_L_STICK_UP );
            this.gamepadKeyCodeMap.set( 'L STICK DOWN',  _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_L_STICK_DOWN );
            this.gamepadKeyCodeMap.set( 'L STICK LEFT',  _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_L_STICK_LEFT );
            this.gamepadKeyCodeMap.set( 'L STICK RIGHT', _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_L_STICK_RIGHT );
            this.gamepadKeyCodeMap.set( 'R STICK UP',    _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_R_STICK_UP );
            this.gamepadKeyCodeMap.set( 'R STICK DOWN',  _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_R_STICK_DOWN );
            this.gamepadKeyCodeMap.set( 'R STICK LEFT',  _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_R_STICK_LEFT );
            this.gamepadKeyCodeMap.set( 'R STICK RIGHT', _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_R_STICK_RIGHT );

            // Load the gamepad mapping
            this.loadAction( this.actionDict.gamepadMapping.playerHidden, this.gamepadKeyCodeMap, this.gamepadActionMap );
            this.loadAction( this.actionDict.gamepadMapping.playerVisible, this.gamepadKeyCodeMap, this.gamepadActionMap );
        }
    }
    
    // 
    //  DESC: Load data from file path
    //
    clearLastDeviceUsed()
    {
        this.lastDeviceUsed = _common_defs__WEBPACK_IMPORTED_MODULE_4__.DEVICE_NULL;
    }

    // 
    //  DESC: Load action data from xml node
    //
    loadAction( actionDict, keyCodeMap, actionMap )
    {
        if( actionDict )
        {
            for( let each of actionDict )
            {
                // See if we can find the string that represents the key code id
                let keyCode = keyCodeMap.get( each.componetId );

                // Add it in if we found it
                if( keyCode !== undefined )
                {
                    // See if the controller action string has already been added
                    let actionStr = each.action;
                    let action = actionMap.get( each.action );

                    if( action !== undefined )
                    {
                        // If it's found, add another id to this map
                        action.setId( keyCode );
                    }
                    else
                    {
                        // Add new action to the map
                        actionMap.set( actionStr, new _common_keycodeaction__WEBPACK_IMPORTED_MODULE_0__.KeyCodeAction(keyCode) );
                    }
                }
            }
        }
    }
    
    // 
    //  DESC: Was this an action
    //
    wasActionPress( event, actionStr, actionPress )
    {
        if( this.wasAction( event, actionStr ) === actionPress )
            return true;

        return false;
    }
    
    // 
    //  DESC: Was this an action
    //
    wasAction( event, actionStr )
    {
        let result = _common_defs__WEBPACK_IMPORTED_MODULE_4__.EAP_IDLE;

        if( this.allowAction )
        {
            // Check for keyboard event
            if( event instanceof KeyboardEvent )
            {
                this.lastDeviceUsed = _common_defs__WEBPACK_IMPORTED_MODULE_4__.KEYBOARD;

                if( this.wasActionMap( event.code, actionStr, this.keyboardActionMap ) )
                {
                    result = _common_defs__WEBPACK_IMPORTED_MODULE_4__.EAP_DOWN;

                    if( event.type === 'keyup' )
                    {
                        result = _common_defs__WEBPACK_IMPORTED_MODULE_4__.EAP_UP;
                    }
                }
            }
            // Check for mouse event
            else if( event instanceof MouseEvent )
            {
                this.lastDeviceUsed = _common_defs__WEBPACK_IMPORTED_MODULE_4__.MOUSE;

                if( this.wasActionMap( event.button, actionStr, this.mouseActionMap ) )
                {
                    result = _common_defs__WEBPACK_IMPORTED_MODULE_4__.EAP_DOWN;

                    if( event.type === 'mouseup' )
                    {
                        result = _common_defs__WEBPACK_IMPORTED_MODULE_4__.EAP_UP;
                    }
                }
            }
            // Check for gamepad event
            else if( event instanceof _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GamepadEvent )
            {
                this.lastDeviceUsed = _common_defs__WEBPACK_IMPORTED_MODULE_4__.GAMEPAD;

                if( event.type === _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_DOWN || event.type === _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_UP )
                {
                    if( this.wasActionMap( event.buttonIndex, actionStr, this.gamepadActionMap ) )
                    {
                        result = _common_defs__WEBPACK_IMPORTED_MODULE_4__.EAP_DOWN;

                        if( event.type === _common_gamepadevent__WEBPACK_IMPORTED_MODULE_1__.GAMEPAD_BUTTON_UP )
                        {
                            result = _common_defs__WEBPACK_IMPORTED_MODULE_4__.EAP_UP;
                        }
                    }
                }
            }
        }

        return result;
    }
    
    // 
    //  DESC: Was this an action
    //
    wasActionMap( id, actionStr, actionMap )
    {
        let result = false;

        // See if the action has already been added
        let action = actionMap.get( actionStr );

        // If it's found, see if this is the correct action
        if( action !== undefined )
        {
            result = action.wasAction( id );
        }

        return result;
    }

    // 
    //  DESC: Get the action/component strings for the give device id
    //
    getDeviceActionStr( deviceId, actionNameStr )
    {
        let mappingName = 'keyboardMapping';

        if( deviceId === _common_defs__WEBPACK_IMPORTED_MODULE_4__.MOUSE )
        {
            mappingName = 'mouseMapping';
        }
        else if( deviceId === _common_defs__WEBPACK_IMPORTED_MODULE_4__.GAMEPAD )
        {
            mappingName = 'gamepadMapping';
        }

        return this.getComponentStr( this.actionDict[mappingName].playerVisible, actionNameStr );
    }

    // 
    //  DESC: Get the component string for the action name id
    //
    getComponentStr( actionDict, actionNameStr )
    {
        if( actionDict )
        {
            for( let each of actionDict )
            {
                if( actionNameStr == each['action'] )
                {
                    let componetIdStr = each['componetId'];

                    let configurable = false;

                    let attr = each['configurable'];
                    if( attr )
                        configurable = (attr === 'true');

                    return [componetIdStr, configurable];
                }
            }
        }

        return ['', false];
    }

    // 
    //  DESC: Change the component string for the action Id
    //
    changeComponentStr( actionDict, actionNameStr, componetNameStr )
    {
        if( actionDict )
        {
            for( let each of actionDict )
            {
                if( actionNameStr == each['action'] )
                {
                    if( each['configurable'] === 'true' )
                    {
                        each['componetId'] = componetNameStr;

                        return true;
                    }
                }
            }
        }

        return false;
    }

    // 
    //  DESC: Reset the action
    //
    resetAction( deviceId, actionNameStr, newKeyCode )
    {
        let mappingName = 'keyboardMapping';
        let keyCodeMap = this.keyboardKeyCodeMap;
        let actionMap = this.keyboardActionMap;

        if( deviceId == _common_defs__WEBPACK_IMPORTED_MODULE_4__.MOUSE )
        {
            mappingName = 'mouseMapping';
            keyCodeMap = this.mouseKeyCodeMap;
            actionMap = this.mouseActionMap;
        }
        else if( deviceId == _common_defs__WEBPACK_IMPORTED_MODULE_4__.GAMEPAD )
        {
            mappingName = 'gamepadMapping';
            keyCodeMap = this.gamepadKeyCodeMap;
            actionMap = this.gamepadActionMap;
        }
        
        // If this action ID can be found and is configurable, reset it
        let [oldComponetIdStr, configurable] = this.getComponentStr( this.actionDict[mappingName].playerVisible, actionNameStr );

        if( oldComponetIdStr && configurable )
        {
            // See if we can find the string that represents the key code id
            let key = _utilities_genfunc__WEBPACK_IMPORTED_MODULE_3__.getKey(keyCodeMap, newKeyCode);
            if( key )
            {
                let newComponetIdStr = UNBOUND_KEYCODE_STR_ID;
                if( key != oldComponetIdStr )
                    newComponetIdStr = key;
                else
                    newKeyCode = UNBOUND_KEYCODE_ID;

                let oldKeyCode = keyCodeMap.get(oldComponetIdStr);
                if( oldKeyCode != undefined )
                {
                    // Check for the action to remove the old key code and add the new one
                    let keyCodeAction = actionMap.get( actionNameStr );
                    if( keyCodeAction )
                    {
                        // Remove the old key code Id
                        keyCodeAction.removeId( oldKeyCode );

                        // Add the new key code Id
                        keyCodeAction.setId( newKeyCode );

                        // Update the action dictionary with the change
                        if( this.changeComponentStr( this.actionDict[mappingName].playerVisible, actionNameStr, newComponetIdStr ) )
                            return [newComponetIdStr, true];
                    }
                }
            }
        }

        return ['', false];
    }

    // 
    //  DESC: Save the keybinding
    //
    saveKeybinding()
    {
        _utilities_localstorage__WEBPACK_IMPORTED_MODULE_2__.localStorage.set( 'keybinding', JSON.stringify(this.actionDict) );
    }

    // 
    //  DESC: Reset keybinding
    //
    resetKeybinding()
    {
        this.keyboardActionMap = new Map;
        this.mouseActionMap = new Map;
        this.gamepadActionMap = new Map;

        this.resetKeybindingToDefaults( this.actionDict.keyboardMapping.playerVisible );
        this.resetKeybindingToDefaults( this.actionDict.mouseMapping.playerVisible );
        this.resetKeybindingToDefaults( this.actionDict.gamepadMapping.playerVisible );

        _utilities_localstorage__WEBPACK_IMPORTED_MODULE_2__.localStorage.free( 'keybinding' );
        this.loadFromObj( this.actionDict );
    }

    // 
    //  DESC: Reset keybinding
    //
    resetKeybindingToDefaults( actionDict )
    {
        for( let each of actionDict )
        {
            if( each.defaultId )
                each.componetId = each.defaultId;
        }
    }

    // 
    //  DESC: What was the last device
    //
    wasLastDeviceGamepad()
    {
        return (this.lastDeviceUsed === _common_defs__WEBPACK_IMPORTED_MODULE_4__.GAMEPAD);
    }

    wasLastDeviceKeyboard()
    {
        return (this.lastDeviceUsed === _common_defs__WEBPACK_IMPORTED_MODULE_4__.KEYBOARD);
    }

    wasLastDeviceMouse()
    {
        return (this.lastDeviceUsed === _common_defs__WEBPACK_IMPORTED_MODULE_4__.MOUSE);
    }

    // 
    //  DESC: allow event handling access function
    //
    get allowActionHandling() { return this.allowAction; }
    set allowActionHandling( value ) { this.allowAction = value; }
}

var actionManager = new ActionManager;


/***/ }),
/* 28 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "KeyCodeAction": () => (/* binding */ KeyCodeAction)
/* harmony export */ });
// 
//  FILE NAME: keycodeaction.js
//  DESC:      Class for holding key codes to test for action events
//



class KeyCodeAction
{
    constructor( id )
    {
        this.idAry = [id];
    }
    
    // Set additional id's
    setId( id )
    {
        // Only set id's that are positive numbers
        if( !((id == -1) || (id == '---')) )
            this.idAry.push( id );
    }
    
    // Remove an id
    removeId( id )
    {
        var index = this.idAry.indexOf( id );
        
        if( index > -1 )
            this.idAry.splice( index, 1 );
    }

    // Check for action
    wasAction( id )
    {
        if( this.idAry.indexOf( id ) > -1 )
            return true;

        return false;
    }
}


/***/ }),
/* 29 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GAMEPAD_BUTTON_DOWN": () => (/* binding */ GAMEPAD_BUTTON_DOWN),
/* harmony export */   "GAMEPAD_BUTTON_UP": () => (/* binding */ GAMEPAD_BUTTON_UP),
/* harmony export */   "GAMEPAD_AXIS_LEFT": () => (/* binding */ GAMEPAD_AXIS_LEFT),
/* harmony export */   "GAMEPAD_AXIS_RIGHT": () => (/* binding */ GAMEPAD_AXIS_RIGHT),
/* harmony export */   "GAMEPAD_TRIGGER_LEFT": () => (/* binding */ GAMEPAD_TRIGGER_LEFT),
/* harmony export */   "GAMEPAD_TRIGGER_RIGHT": () => (/* binding */ GAMEPAD_TRIGGER_RIGHT),
/* harmony export */   "GAMEPAD_AXIS_LEFT_X": () => (/* binding */ GAMEPAD_AXIS_LEFT_X),
/* harmony export */   "GAMEPAD_AXIS_LEFT_Y": () => (/* binding */ GAMEPAD_AXIS_LEFT_Y),
/* harmony export */   "GAMEPAD_AXIS_RIGHT_X": () => (/* binding */ GAMEPAD_AXIS_RIGHT_X),
/* harmony export */   "GAMEPAD_AXIS_RIGHT_Y": () => (/* binding */ GAMEPAD_AXIS_RIGHT_Y),
/* harmony export */   "GAMEPAD_BUTTON_A": () => (/* binding */ GAMEPAD_BUTTON_A),
/* harmony export */   "GAMEPAD_BUTTON_B": () => (/* binding */ GAMEPAD_BUTTON_B),
/* harmony export */   "GAMEPAD_BUTTON_X": () => (/* binding */ GAMEPAD_BUTTON_X),
/* harmony export */   "GAMEPAD_BUTTON_Y": () => (/* binding */ GAMEPAD_BUTTON_Y),
/* harmony export */   "GAMEPAD_BUTTON_L_BUMPER": () => (/* binding */ GAMEPAD_BUTTON_L_BUMPER),
/* harmony export */   "GAMEPAD_BUTTON_R_BUMPER": () => (/* binding */ GAMEPAD_BUTTON_R_BUMPER),
/* harmony export */   "GAMEPAD_BUTTON_L_TRIGGER": () => (/* binding */ GAMEPAD_BUTTON_L_TRIGGER),
/* harmony export */   "GAMEPAD_BUTTON_R_TRIGGER": () => (/* binding */ GAMEPAD_BUTTON_R_TRIGGER),
/* harmony export */   "GAMEPAD_BUTTON_BACK": () => (/* binding */ GAMEPAD_BUTTON_BACK),
/* harmony export */   "GAMEPAD_BUTTON_START": () => (/* binding */ GAMEPAD_BUTTON_START),
/* harmony export */   "GAMEPAD_BUTTON_LEFTSTICK": () => (/* binding */ GAMEPAD_BUTTON_LEFTSTICK),
/* harmony export */   "GAMEPAD_BUTTON_RIGHTSTICK": () => (/* binding */ GAMEPAD_BUTTON_RIGHTSTICK),
/* harmony export */   "GAMEPAD_BUTTON_DPAD_UP": () => (/* binding */ GAMEPAD_BUTTON_DPAD_UP),
/* harmony export */   "GAMEPAD_BUTTON_DPAD_DOWN": () => (/* binding */ GAMEPAD_BUTTON_DPAD_DOWN),
/* harmony export */   "GAMEPAD_BUTTON_DPAD_LEFT": () => (/* binding */ GAMEPAD_BUTTON_DPAD_LEFT),
/* harmony export */   "GAMEPAD_BUTTON_DPAD_RIGHT": () => (/* binding */ GAMEPAD_BUTTON_DPAD_RIGHT),
/* harmony export */   "GAMEPAD_BUTTON_GUIDE": () => (/* binding */ GAMEPAD_BUTTON_GUIDE),
/* harmony export */   "ALT_GAMEPAD_BUTTON_BACK": () => (/* binding */ ALT_GAMEPAD_BUTTON_BACK),
/* harmony export */   "ALT_GAMEPAD_BUTTON_START": () => (/* binding */ ALT_GAMEPAD_BUTTON_START),
/* harmony export */   "ALT_GAMEPAD_BUTTON_GUIDE": () => (/* binding */ ALT_GAMEPAD_BUTTON_GUIDE),
/* harmony export */   "ALT_GAMEPAD_BUTTON_LEFTSTICK": () => (/* binding */ ALT_GAMEPAD_BUTTON_LEFTSTICK),
/* harmony export */   "ALT_GAMEPAD_BUTTON_RIGHTSTICK": () => (/* binding */ ALT_GAMEPAD_BUTTON_RIGHTSTICK),
/* harmony export */   "GAMEPAD_BUTTON_L_STICK_UP": () => (/* binding */ GAMEPAD_BUTTON_L_STICK_UP),
/* harmony export */   "GAMEPAD_BUTTON_L_STICK_DOWN": () => (/* binding */ GAMEPAD_BUTTON_L_STICK_DOWN),
/* harmony export */   "GAMEPAD_BUTTON_L_STICK_LEFT": () => (/* binding */ GAMEPAD_BUTTON_L_STICK_LEFT),
/* harmony export */   "GAMEPAD_BUTTON_L_STICK_RIGHT": () => (/* binding */ GAMEPAD_BUTTON_L_STICK_RIGHT),
/* harmony export */   "GAMEPAD_BUTTON_R_STICK_UP": () => (/* binding */ GAMEPAD_BUTTON_R_STICK_UP),
/* harmony export */   "GAMEPAD_BUTTON_R_STICK_DOWN": () => (/* binding */ GAMEPAD_BUTTON_R_STICK_DOWN),
/* harmony export */   "GAMEPAD_BUTTON_R_STICK_LEFT": () => (/* binding */ GAMEPAD_BUTTON_R_STICK_LEFT),
/* harmony export */   "GAMEPAD_BUTTON_R_STICK_RIGHT": () => (/* binding */ GAMEPAD_BUTTON_R_STICK_RIGHT),
/* harmony export */   "ANALOG_STICK_MSG_MAX": () => (/* binding */ ANALOG_STICK_MSG_MAX),
/* harmony export */   "GamepadEvent": () => (/* binding */ GamepadEvent)
/* harmony export */ });

// 
//  FILE NAME:  gamepadevent.js
//  DESC:       class for holding a generic event
//



// Gamepad event types
const GAMEPAD_BUTTON_DOWN   = 0,
             GAMEPAD_BUTTON_UP     = 1,
             GAMEPAD_AXIS_LEFT     = 2,
             GAMEPAD_AXIS_RIGHT    = 3,
             GAMEPAD_TRIGGER_LEFT  = 4,
             GAMEPAD_TRIGGER_RIGHT = 5;

// Negative axis value: X = left, Y = up
const GAMEPAD_AXIS_LEFT_X  = 0,
             GAMEPAD_AXIS_LEFT_Y  = 1,
             GAMEPAD_AXIS_RIGHT_X = 2,
             GAMEPAD_AXIS_RIGHT_Y = 3;

const GAMEPAD_BUTTON_A             = 0,
             GAMEPAD_BUTTON_B             = 1,
             GAMEPAD_BUTTON_X             = 2,
             GAMEPAD_BUTTON_Y             = 3,
             GAMEPAD_BUTTON_L_BUMPER      = 4,
             GAMEPAD_BUTTON_R_BUMPER      = 5,
             GAMEPAD_BUTTON_L_TRIGGER     = 6,
             GAMEPAD_BUTTON_R_TRIGGER     = 7,
             GAMEPAD_BUTTON_BACK          = 8,
             GAMEPAD_BUTTON_START         = 9,
             GAMEPAD_BUTTON_LEFTSTICK     = 10,
             GAMEPAD_BUTTON_RIGHTSTICK    = 11,
             GAMEPAD_BUTTON_DPAD_UP       = 12,
             GAMEPAD_BUTTON_DPAD_DOWN     = 13,
             GAMEPAD_BUTTON_DPAD_LEFT     = 14,
             GAMEPAD_BUTTON_DPAD_RIGHT    = 15,
             GAMEPAD_BUTTON_GUIDE         = 16,

             // Alternative key mappings
             ALT_GAMEPAD_BUTTON_BACK       = 6,
             ALT_GAMEPAD_BUTTON_START      = 7,
             ALT_GAMEPAD_BUTTON_GUIDE      = 8,
             ALT_GAMEPAD_BUTTON_LEFTSTICK  = 9,
             ALT_GAMEPAD_BUTTON_RIGHTSTICK = 10,

             // Key codes to use analog sticks as buttons
             GAMEPAD_BUTTON_L_STICK_UP    = 30,
             GAMEPAD_BUTTON_L_STICK_DOWN  = 31,
             GAMEPAD_BUTTON_L_STICK_LEFT  = 32,
             GAMEPAD_BUTTON_L_STICK_RIGHT = 33,
             GAMEPAD_BUTTON_R_STICK_UP    = 34,
             GAMEPAD_BUTTON_R_STICK_DOWN  = 35,
             GAMEPAD_BUTTON_R_STICK_LEFT  = 36,
             GAMEPAD_BUTTON_R_STICK_RIGHT = 37;

const ANALOG_STICK_MSG_MAX = 0.7;

class GamepadEvent
{
    constructor( type, eventIndex, gamepad )
    {
        // Event type
        this._type = type;

        // Index of the button or axis this event was created for
        this.eventIndex = eventIndex;

        // The gamepad object this event was created from
        this.gamepad = gamepad;
    }

    //
    //  DESC: Was this button touched?
    //
    get type()
    {
        return this._type;
    }

    //
    //  DESC: Was this button touched?
    //
    get touched()
    {
        return this.gamepad.buttons[this.eventIndex].touched;
    }

    //
    //  DESC: Was this button pressed?
    //  NOTE: This is hear for convience. The type indicates the state we car about
    //
    get pressed()
    {
        return this.gamepad.buttons[this.eventIndex].pressed;
    }

    //
    //  DESC: Is this button a trigger?
    //
    get trigger()
    {
        if( this.eventIndex == GAMEPAD_BUTTON_L_TRIGGER || this.eventIndex == GAMEPAD_BUTTON_R_TRIGGER )
            return true;

        return false;
    }

    //
    //  DESC: Return the value of this button.
    //  NOTE: Only the triggers have a value we might care about
    //
    get buttonValue()
    {
        return this.gamepad.buttons[this.eventIndex].value;
    }

    //
    //  DESC: Return the value of this button.
    //  NOTE: Only the triggers have a value we might care about
    //
    get buttonIndex()
    {
        return this.eventIndex;
    }

    //
    //  DESC: Return the value of the axises
    //
    get axis()
    {
        if( this.type == GAMEPAD_AXIS_LEFT )
        {
            return {
                'axisX' : this.gamepad.axes[GAMEPAD_AXIS_LEFT_X].toFixed(2),
                'axisY' : this.gamepad.axes[GAMEPAD_AXIS_LEFT_Y].toFixed(2)};
        }

        return {
            'axisX' : this.gamepad.axes[GAMEPAD_AXIS_RIGHT_X].toFixed(2),
            'axisY' : this.gamepad.axes[GAMEPAD_AXIS_RIGHT_Y].toFixed(2)};
    }

    //
    //  DESC: Return the index of this gamepad
    //
    get gamepadIndex()
    {
        return this.gamepad.index;
    }
}


/***/ }),
/* 30 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "eventManager": () => (/* binding */ eventManager)
/* harmony export */ });
/* harmony import */ var _common_point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14);
/* harmony import */ var _common_genericevent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(31);
/* harmony import */ var _common_gamepad__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(32);
/* harmony import */ var _gui_menumanager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(24);
/* harmony import */ var _managers_actionmanager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(27);
/* harmony import */ var _utilities_settings__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(3);
/* harmony import */ var _common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(29);
/* harmony import */ var _system_device__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(9);

//
//  FILE NAME: eventmanager.js
//  DESC:      event manager class singleton
//











class EventManager
{
    constructor()
    {
        this.canvas = document.getElementById('game-surface');
        this.queue = [];
        
        // Init with the most common events

        // Event handlers
        this.canvas.addEventListener( 'mousedown', this.onMouseDown.bind(this) );
        this.canvas.addEventListener( 'mouseup', this.onMouseUp.bind(this) );
        this.canvas.addEventListener( 'mousemove', this.onMouseMove.bind(this) );
        //document.addEventListener( 'scroll', this.onScroll.bind(this) );
        
        // Using document for key listener because canvas needs the focus before
        // it will trap key events. There's no good solution for force the focus
        // onto the canvas
        document.addEventListener( 'keydown', this.onKeyDown.bind(this) );
        document.addEventListener( 'keyup', this.onKeyUp.bind(this) );
        
        //this.canvas.addEventListener('keydown', this.onKeyDown.bind(this) );
        //this.canvas.addEventListener('keyup', this.onKeyUp.bind(this) );

        // Gamepad event handlers
        window.addEventListener( "gamepadconnected", this.onGamepadconnected.bind(this) );
        window.addEventListener( "gamepaddisconnected", this.onGamepadDisconnected.bind(this) );

        // Resize even handler
        //window.addEventListener( 'resize', this.onResize.bind(this) );

        // Wheel even handler
        window.addEventListener( 'wheel', this.onWheel.bind(this) );

        document.addEventListener('fullscreenchange', this.onFullScreenChange.bind(this) );
        
        // Mouse move relative offset data types
        this.mouseAbsolutePos = new _common_point__WEBPACK_IMPORTED_MODULE_0__.Point;
        this.mouseRelativePos = new _common_point__WEBPACK_IMPORTED_MODULE_0__.Point;
        
        //this.mouseOffset = new Point();

        // Dictionary for holding all the gamepads
        this.gamePadMap = new Map;

        // Store then initial backgroud color
        this.backgroundColor = document.body.style.backgroundColor;
    }
    
    //
    //  DESC: Poll events that have been queued up
    //
    pollEvent()
    {
        if( this.queue.length )
            return this.queue.shift();
        
        return null;
    }
    
    //
    //  DESC: Add an event to the event queue
    //
    dispatchEvent( type, ...args )
    {
        this.queue.push( new _common_genericevent__WEBPACK_IMPORTED_MODULE_1__.GenericEvent( type, args ) );
    }
    
    //
    //  DESC: Handle onScroll events
    //
    /*onScroll( event )
    {
        this.mouseOffset.setXYZ(
            document.documentElement.scrollLeft - this.canvas.offsetLeft,
            document.documentElement.scrollTop - this.canvas.offsetTop );
    }*/
    
    //
    //  DESC: Handle onMouseDown events
    //
    onMouseDown( event )
    {
        // Filter the mouse position and add a new membe to the event
        this.filterMousePos( event );

        // Add to the event queue
        this.queue.push( event );
        
        //console.log( event.type + ', ' + event.button );
    }
    
    //
    //  DESC: Handle onMouseUp events
    //
    onMouseUp( event )
    {
        // Filter the mouse position and add a new membe to the event
        this.filterMousePos( event );

        // Add to the event queue
        this.queue.push( event );

        //console.log( event.type + ', ' + event.button );
    }
    
    //
    //  DESC: Handle onMouseMove events
    //
    onMouseMove( event )
    {
        // Filter the mouse position and add a new membe to the event
        this.filterMousePos( event );

        // Add to the event queue
        this.queue.push( event );

        //console.log(`Mouse move - ClientX: ${event.clientX}, ClientY: ${event.clientY}, OffsetX: ${event.offsetX}, OffsetY: ${event.offsetY}, RelX: ${event.movementX}, RelY: ${event.movementY}`);
        //console.log(`Canvas Offset: ${this.canvas.offsetLeft} x ${this.canvas.offsetTop}`);
        //console.log(`Document Offset: ${document.documentElement.scrollLeft} x ${document.documentElement.scrollTop}`);
        //console.log(`Move; RelX: ${this.mouseMoveRelX} RelY ${this.mouseMoveRelY}; AbsX: ${this.lastMouseMoveX} absY ${this.lastMouseMoveY}`);
    }

    //
    //  DESC: Handle onKeyDown events
    //
    onFullScreenChange( event )
    {
        console.log('onFullScreenChange');
        if (document.fullscreenElement)
        {
            let dpr = window.devicePixelRatio;
            let width = Math.trunc(event.target.clientWidth * dpr);
            let height = Math.trunc(event.target.clientHeight * dpr);
            _system_device__WEBPACK_IMPORTED_MODULE_7__.device.handleResolutionChange( width, height );
            document.body.style.backgroundColor = 'black';
        }
        else
        {
            _system_device__WEBPACK_IMPORTED_MODULE_7__.device.handleResolutionChange( _utilities_settings__WEBPACK_IMPORTED_MODULE_5__.settings.initialSize.w, _utilities_settings__WEBPACK_IMPORTED_MODULE_5__.settings.initialSize.h );
            document.body.style.backgroundColor = this.backgroundColor;
        }
    }
    
    //
    //  DESC: Handle onKeyDown events
    //
    onKeyDown( event )
    {
        if( event.repeat === false )
        {
            this.queue.push( event );

            //console.log( event.type + ', ' + event.key + ', ' + event.keyCode + ', ' + event.code );
        }
    }
    
    //
    //  DESC: Handle onKeyUp events
    //
    onKeyUp( event )
    {
        this.queue.push( event );

        // Check for fullscreen toggle
        if( _managers_actionmanager__WEBPACK_IMPORTED_MODULE_4__.actionManager.wasAction( event, 'fullscreen_toggle' ) )
        {
            //console.log('onKeyDown');
            if (!document.fullscreenElement)
                _system_device__WEBPACK_IMPORTED_MODULE_7__.device.canvas.requestFullscreen();

            else if (document.exitFullscreen)
                document.exitFullscreen();
        }

        //console.log( event.type + ', ' + event.key + ', ' + event.keyCode + ', ' + event.code );
    }

    //
    //  DESC: onWheel even handler
    //
    onWheel( event )
    {
        // Add to the event queue
        this.queue.push( event );
    }

    //
    //  DESC: onResizeObserver even handler
    //
    /*onResize( event )
    {
    }*/

    //
    //  DESC: Handle onGamepadconnected events
    //
    onGamepadconnected( event )
    {
        if( _utilities_settings__WEBPACK_IMPORTED_MODULE_5__.settings.allowGamepad )
        {
            _managers_actionmanager__WEBPACK_IMPORTED_MODULE_4__.actionManager.initGamepadMapping( event.gamepad.mapping );
            this.gamePadMap.set( event.gamepad.index, new _common_gamepad__WEBPACK_IMPORTED_MODULE_2__.Gamepad( event.gamepad ) );
            this.queue.push( event );
            console.log(`Gamepad connected: Index ${event.gamepad.index}; Id: ${event.gamepad.id}; Button Count: ${event.gamepad.buttons.length}; Axes: ${event.gamepad.axes.length}`);
        }
    }

    //
    //  DESC: Handle onGamepadDisconnected events
    //
    onGamepadDisconnected( event )
    {
        if( _utilities_settings__WEBPACK_IMPORTED_MODULE_5__.settings.allowGamepad )
        {
            this.queue.push( event );
            console.log(`Gamepad disconnected: Index ${event.gamepad.index}; Id: ${event.gamepad.id}`);
        }
    }

    //
    //  DESC: Filter the mouse position and add a new member to the event
    //
    filterMousePos( event )
    {
        let x = event.offsetX;
        let y = event.offsetY;
        let pixelRatio = window.devicePixelRatio;

        if( document.fullscreenElement )
        {
            x = Math.trunc(event.offsetX * pixelRatio);
            y = Math.trunc(event.offsetY * pixelRatio);

            // Since it's needed for fullscreen, nullify it for anyone else using it
            pixelRatio = 1.0; 
        }

        // Create a new event member to hold game custom values
        event.gameAdjustedMouseX = x;
        event.gameAdjustedMouseY = y;
        event.gameAdjustedPixelRatio = pixelRatio;

        this.mouseRelativePos.setXYZ( event.movementX, event.movementY );
        this.mouseAbsolutePos.setXYZ( x, y);
    }

    //
    //  DESC: Handle gamepad
    //
    handleGamepad()
    {
        if( this.gamePadMap.size )
        {
            // Send out events for the button presses
            for ( let [index, lastGp] of this.gamePadMap )
            {
                let gp = navigator.getGamepads()[index];

                if( gp && gp.connected )
                {
                    // Create Up/DOWN events for the buttons
                    for(let i = 0; i < gp.buttons.length; i++)
                    {
                        // Check for button down
                        if(!lastGp.pressed[i] && gp.buttons[i].pressed)
                        {
                            this.queue.push( new _common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GamepadEvent(_common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GAMEPAD_BUTTON_DOWN, i, gp) );
                            console.log( `Button Index Down: ${i};` );
                        }
                        // Check for button up
                        else if(lastGp.pressed[i] && !gp.buttons[i].pressed)
                        {
                            this.queue.push( new _common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GamepadEvent(_common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GAMEPAD_BUTTON_UP, i, gp) );
                            //console.log( `Button Index Up: ${i};` );
                        }
                    }

                    //console.log( `Left Axes X Value: ${gp.axes[gamepadevent.GAMEPAD_AXIS_LEFT_X]};` );
                    //console.log( `Left Axes Y Value: ${gp.axes[gamepadevent.GAMEPAD_AXIS_LEFT_Y]};` );

                    // Create UP/DOWN events for the Left analog stick
                    if(!(lastGp.axes[_common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GAMEPAD_AXIS_LEFT_Y] < -_common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.ANALOG_STICK_MSG_MAX) && 
                        (gp.axes[_common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GAMEPAD_AXIS_LEFT_Y] < -_common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.ANALOG_STICK_MSG_MAX))
                    {
                        this.queue.push( new _common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GamepadEvent(_common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GAMEPAD_BUTTON_DOWN, _common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GAMEPAD_BUTTON_L_STICK_UP, gp) );
                        //console.log( `Left Y Axes UP Button Down; Value: ${gp.axes[gamepadevent.GAMEPAD_AXIS_LEFT_Y]};` );
                    }
                    else if((lastGp.axes[_common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GAMEPAD_AXIS_LEFT_Y] < -_common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.ANALOG_STICK_MSG_MAX) && 
                        !(gp.axes[_common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GAMEPAD_AXIS_LEFT_Y] < -_common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.ANALOG_STICK_MSG_MAX))
                    {
                        this.queue.push( new _common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GamepadEvent(_common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GAMEPAD_BUTTON_UP, _common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GAMEPAD_BUTTON_L_STICK_UP, gp) );
                        //console.log( `Left Y Axes UP Button Up; Value: ${gp.axes[gamepadevent.GAMEPAD_AXIS_LEFT_Y]};` );
                    }
                    else if(!(lastGp.axes[_common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GAMEPAD_AXIS_LEFT_Y] > _common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.ANALOG_STICK_MSG_MAX) && 
                        (gp.axes[_common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GAMEPAD_AXIS_LEFT_Y] > _common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.ANALOG_STICK_MSG_MAX))
                    {
                        this.queue.push( new _common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GamepadEvent(_common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GAMEPAD_BUTTON_DOWN, _common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GAMEPAD_BUTTON_L_STICK_DOWN, gp) );
                        //console.log( `Left Y Axes DOWN Button Down; Value: ${gp.axes[gamepadevent.GAMEPAD_AXIS_LEFT_Y]};` );
                    }
                    else if((lastGp.axes[_common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GAMEPAD_AXIS_LEFT_Y] > _common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.ANALOG_STICK_MSG_MAX) && 
                        !(gp.axes[_common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GAMEPAD_AXIS_LEFT_Y] > _common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.ANALOG_STICK_MSG_MAX))
                    {
                        this.queue.push( new _common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GamepadEvent(_common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GAMEPAD_BUTTON_UP, _common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GAMEPAD_BUTTON_L_STICK_DOWN, gp) );
                        //console.log( `Left Y Axes DOWN Button Up; Value: ${gp.axes[gamepadevent.GAMEPAD_AXIS_LEFT_Y]};` );
                    }

                    // Create Left/Right events for the Left analog stick
                    else if(!(lastGp.axes[_common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GAMEPAD_AXIS_LEFT_X] < -_common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.ANALOG_STICK_MSG_MAX) && 
                        (gp.axes[_common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GAMEPAD_AXIS_LEFT_X] < -_common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.ANALOG_STICK_MSG_MAX))
                    {
                        this.queue.push( new _common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GamepadEvent(_common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GAMEPAD_BUTTON_DOWN, _common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GAMEPAD_BUTTON_L_STICK_LEFT, gp) );
                        //console.log( `Left X Axes LEFT Button Down; Value: ${gp.axes[gamepadevent.GAMEPAD_AXIS_LEFT_X]};` );
                    }
                    else if((lastGp.axes[_common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GAMEPAD_AXIS_LEFT_X] < -_common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.ANALOG_STICK_MSG_MAX) && 
                        !(gp.axes[_common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GAMEPAD_AXIS_LEFT_X] < -_common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.ANALOG_STICK_MSG_MAX))
                    {
                        this.queue.push( new _common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GamepadEvent(_common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GAMEPAD_BUTTON_UP, _common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GAMEPAD_BUTTON_L_STICK_LEFT, gp) );
                        //console.log( `Left X Axes LEFT Button Up; Value: ${gp.axes[gamepadevent.GAMEPAD_AXIS_LEFT_X]};` );
                    }
                    else if(!(lastGp.axes[_common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GAMEPAD_AXIS_LEFT_X] > _common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.ANALOG_STICK_MSG_MAX) && 
                        (gp.axes[_common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GAMEPAD_AXIS_LEFT_X] > _common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.ANALOG_STICK_MSG_MAX))
                    {
                        this.queue.push( new _common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GamepadEvent(_common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GAMEPAD_BUTTON_DOWN, _common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GAMEPAD_BUTTON_L_STICK_RIGHT, gp) );
                        //console.log( `Left X Axes RIGHT Button Down; Value: ${gp.axes[gamepadevent.GAMEPAD_AXIS_LEFT_X]};` );
                    }
                    else if((lastGp.axes[_common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GAMEPAD_AXIS_LEFT_X] > _common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.ANALOG_STICK_MSG_MAX) && 
                        !(gp.axes[_common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GAMEPAD_AXIS_LEFT_X] > _common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.ANALOG_STICK_MSG_MAX))
                    {
                        this.queue.push( new _common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GamepadEvent(_common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GAMEPAD_BUTTON_UP, _common_gamepadevent__WEBPACK_IMPORTED_MODULE_6__.GAMEPAD_BUTTON_L_STICK_RIGHT, gp) );
                        //console.log( `Left X Axes RIGHT Button Up; Value: ${gp.axes[gamepadevent.GAMEPAD_AXIS_LEFT_X]};` );
                    }

                    // Sets the current gamepad
                    lastGp.gamepad = gp;
                }
            }
        }
    }
    
    // 
    //  DESC: Clear the event queue
    //
    clear()
    {
        this.queue = [];
    }
}

var eventManager = new EventManager;


/***/ }),
/* 31 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GenericEvent": () => (/* binding */ GenericEvent)
/* harmony export */ });

// 
//  FILE NAME:  genericevent.js
//  DESC:       class for holding a generic event
//



class GenericEvent
{
    constructor( type, ...args )
    {
        this.type = type;
        this.arg = args[0];
    }
}


/***/ }),
/* 32 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Gamepad": () => (/* binding */ Gamepad)
/* harmony export */ });

// 
//  FILE NAME:  gamepad.js
//  DESC:       class for holding gamepad object and a copy of it's values
//  NOTE:       Some browsers keep the same gamepad object while others issue a new one.
//              This is a solution that will solve the problem of remembering the button pressed state.
//



class Gamepad
{
    constructor( gp )
    {
        // The gamepad object this event was created from
        this.gp = gp;

        // List of last pressed values
        this._pressed = [];

        // List of last axes values
        this._axes = [];

        // Copy the values over
        for( const each of gp.buttons )
            this._pressed.push( each.pressed );

        // Copy the values over
        for( const each of gp.axes )
            this._axes.push( each );
    }

    //
    //  DESC: Set the gamepad and copy the last data
    //
    set gamepad( gp )
    {
        // Update the class member because the gamepad object might be different
        this.gp = gp;

        for( let i = 0; i < gp.buttons.length; i++ )
            this._pressed[i] = gp.buttons[i].pressed;

        for( let i = 0; i < gp.axes.length; i++ )
            this._axes[i] = gp.axes[i];
    }

    //
    //  DESC: Get the last set of buttons pressed
    //
    get pressed()
    {
        return this._pressed;
    }
    
    //
    //  DESC: Get the last set of axes
    //
    get axes()
    {
        return this._axes;
    }
}


/***/ }),
/* 33 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "assetHolder": () => (/* binding */ assetHolder)
/* harmony export */ });

// 
//  FILE NAME: assetholder.js
//  DESC:      Class for holding loaded file data
//



class AssetHolder
{
    constructor()
    {
        this.loadMapMap = new Map;
    }

    // 
    //  DESC: Set the data
    //
    set( group, name, data = null )
    {
        let groupMap = this.loadMapMap.get( group );
        if( groupMap === undefined )
        {
            groupMap = new Map;
            this.loadMapMap.set( group, groupMap );
        }

        let asset = groupMap.get( name );
        if( asset === undefined || asset === -1 )
            groupMap.set( name, data );
    }
    
    // 
    //  DESC: Set a place holder that this data is scheduled to be loaded
    //
    allowLoad( group, name )
    {
        let groupMap = this.loadMapMap.get( group );
        if( groupMap === undefined )
        {
            groupMap = new Map;
            this.loadMapMap.set( group, groupMap );
        }
        
        let asset = groupMap.get( name );
        if( asset === undefined )
        {
            // Add an entry to the map as a 
            // place holder for future checks
            groupMap.set( name, -1 );

            return true;
        }

        return false;
    }
    
    // 
    //  DESC: Get the data
    //
    get( group, name )
    {
        let groupMap = this.loadMapMap.get( group );
        if( groupMap === undefined )
            throw new Error( `Group does not exist! (${group}).` );
            
        let data = groupMap.get( name );
        if( data === undefined || data === -1 )
            throw new Error( `Data does not exist! (${name}).` );
        
        return data;
    }
    
    // 
    //  DESC: Delete the group
    //
    deleteGroup( groupAry )
    {
        for( let i = 0; i < groupAry.length; ++i )
            this.loadMapMap.delete( groupAry[i] );
    }
    
    // 
    //  DESC: Clear the group data
    //
    clear()
    {
        if( this.loadMapMap.size )
            this.loadMapMap.clear();
    }
}

var assetHolder = new AssetHolder;


/***/ }),
/* 34 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Menu": () => (/* binding */ Menu)
/* harmony export */ });
/* harmony import */ var _common_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);
/* harmony import */ var _common_dynamicoffset__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23);
/* harmony import */ var _scrollparam__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(35);
/* harmony import */ var _utilities_settings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(3);
/* harmony import */ var _sprite_sprite__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(37);
/* harmony import */ var _managers_eventmanager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(30);
/* harmony import */ var _gui_uicontrolnavnode__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(111);
/* harmony import */ var _objectdatamanager_objectdatamanager__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(112);
/* harmony import */ var _common_genericevent__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(31);
/* harmony import */ var _uicontrolfactory__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(127);
/* harmony import */ var _utilities_xmlparsehelper__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(19);
/* harmony import */ var _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(132);
/* harmony import */ var _gui_menudefs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(36);
/* harmony import */ var _common_defs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(6);
// 
//  FILE NAME: menu.js
//  DESC:      Class for user interface menu
//

















class Menu extends _common_object__WEBPACK_IMPORTED_MODULE_0__.Object
{
    constructor( name, group, filePath )
    {
        super();
        
        // This menu's name
        this.name = name;
        
        // Group name
        this.group = group;
        
        // File path
        this.filePath = filePath;
        
        // Array of menu static sprites
        this.spriteAry = [];

        // Array list of static controls
        this.staticControlAry = [];

        // Array list of mouse only controls
        this.mouseOnlyControlAry = [];

        // Array list of controls
        this.controlAry = [];

        // Array list of navigation nodes
        this.controlNodeAry = [];

        // Map container of controls for easy name access
        this.controlMap = new Map;

        // Current active node
        this.activeNode = null;

        // menu state
        this.state = _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_11__.ECS_NULL;

        // Dynamic offset
        this.dynamicOffset = new _common_dynamicoffset__WEBPACK_IMPORTED_MODULE_1__.DynamicOffset;

        // Scrolling parameters
        this.scrollParam = new _scrollparam__WEBPACK_IMPORTED_MODULE_2__.ScrollParam;
        
        // menu alpha value
        this.alpha = 0;
        
        // The menu needs to default hidden
        this.setVisible(false);
    }
    
    // 
    //  DESC: Load the menu info from file
    //
    loadFromNode( node )
    {
        // Init the script Ids
        this.initScriptIds( node );
        
        // Load the scroll data from node
        this.scrollParam.loadFromNode( node.getElementsByTagName( 'scroll' ) );

        // Get the static sprite
        let nodeLst = node.getElementsByTagName( 'spriteList' );
        if( nodeLst.length )
        {
            let spriteNode = nodeLst[0].children;
            
            for( let i = 0; i < spriteNode.length; ++i )
                this.loadStaticSpriteFromNode( spriteNode[i] );
        }

        // Get the static menu controls node
        nodeLst = node.getElementsByTagName( 'staticMenuControls' );
        if( nodeLst.length )
        {
            let controlNode = nodeLst[0].children;
            
            for( let i = 0; i < controlNode.length; ++i )
                this.loadStaticControlFromNode( controlNode[i] );
        }

        // Get the mouse only menu controls node
        nodeLst = node.getElementsByTagName( 'mouseOnlyControls' );
        if( nodeLst.length )
        {
            let controlNode = nodeLst[0].children;
            
            for( let i = 0; i < controlNode.length; ++i )
                this.loadMouseOnlyControlFromNode( controlNode[i] );
        }

        // Get the menu controls
        nodeLst = node.getElementsByTagName( 'menuControls' );
        if( nodeLst.length )
        {
            let controlNode = nodeLst[0].children;
            
            // map to help setup the node pointers
            let navNodeMap = new Map;

            // Load the controls
            for( let i = 0; i < controlNode.length; ++i )
                this.loadControlFromNode( controlNode[i], navNodeMap );

            // Map the controls to their respective nodes
            for( let i = 0; i < controlNode.length; ++i )
                this.findNodes( controlNode[i], i, navNodeMap );
        }
    }
    
    // 
    //  DESC: Init the script Ids and add them to the map
    //        This function loads the attribute info reguardless of what it is
    //
    initScriptIds( node )
    {
        // Check for scripting
        let scriptList = node.getElementsByTagName( 'scriptList' );
        if( scriptList.length )
            this.scriptComponent.initScriptIds( scriptList[0] );
    }
    
    // 
    //  DESC: Load a static sprite from an XML node
    //
    loadStaticSpriteFromNode( node )
    {
        // Get the type of object
        let objectName = node.getAttribute( 'objectName' );

        // Allocate the static sprite and add it to the array
        let sprite = new _sprite_sprite__WEBPACK_IMPORTED_MODULE_4__.Sprite( _objectdatamanager_objectdatamanager__WEBPACK_IMPORTED_MODULE_7__.objectDataManager.getData( this.group, objectName ) );
        this.spriteAry.push( sprite );

        // Load the transform data
        sprite.load( node );

        // Init the script Ids
        sprite.scriptComponent.initScriptIds( node );
    }

    // 
    //  DESC: Load static controls from an XML node
    //
    loadStaticControlFromNode( node )
    {
        // New up the control with its respected control type
        let control = _uicontrolfactory__WEBPACK_IMPORTED_MODULE_9__.create( node, this.group );
        this.staticControlAry.push( control );

        // Does this control have a name then add it to the map
        if( control.name )
            this.controlMap.set( control.name, control );
    }

    // 
    //  DESC: Load mouse only controls from an XML node
    //
    loadMouseOnlyControlFromNode( node )
    {
        // New up the control with its respected control type
        let control = _uicontrolfactory__WEBPACK_IMPORTED_MODULE_9__.create( node, this.group );
        this.mouseOnlyControlAry.push( control );

        // Does this control have a name then add it to the map
        if( control.name )
            this.controlMap.set( control.name, control );
    }

    // 
    //  DESC: Load a control from an XML node
    //
    loadControlFromNode( node, navNodeMap )
    {
        // New up the control with its respected control type
        let control = _uicontrolfactory__WEBPACK_IMPORTED_MODULE_9__.create( node, this.group );
        this.controlAry.push( control );

        // Does this control have a name then add it to the map
        if( control.name )
        {
            // Check for duplicate names
            if( this.controlMap.has( control.name ) )
                throw new Error( `Duplicate control name! (${control.name})` );
            
            // Map of menu controls
            this.controlMap.set( control.name, control );

            // Add a node to the array with it's control
            let navNode = new _gui_uicontrolnavnode__WEBPACK_IMPORTED_MODULE_6__.UIControlNavNode( control );
            this.controlNodeAry.push( navNode );

            // Map of menu control nodes
            navNodeMap.set( control.name, navNode );
        }
    }
    
    // 
    //  DESC: Load the dynamic offset data from node
    //
    loadDynamicOffsetFromNode( node )
    {
        // Load the dynamic offset
        this.dynamicOffset = _utilities_xmlparsehelper__WEBPACK_IMPORTED_MODULE_10__.loadDynamicOffset( node );

        // Set the dynamic position
        this.setDynamicPos();
    }

    // 
    //  DESC: Set the dynamic position
    //
    setDynamicPos()
    {
        // Position the menu based on the dynamic offset
        // Don't have it exceed the boundries of the art
        if( this.dynamicOffset )
        {
            let size = _utilities_settings__WEBPACK_IMPORTED_MODULE_3__.settings.defaultSize_half;
            if( _utilities_settings__WEBPACK_IMPORTED_MODULE_3__.settings.defaultSize_half > _utilities_settings__WEBPACK_IMPORTED_MODULE_3__.settings.nativeSize_half )
                size = _utilities_settings__WEBPACK_IMPORTED_MODULE_3__.settings.nativeSize_half;

            this.setPos( this.dynamicOffset.getPos( size ) );
        }
    } 

    // 
    //  DESC: Reset the dynamic position
    //
    resetDynamicPos()
    {
        this.setDynamicPos();

        for( let i = 0; i < this.staticControlAry.length; ++i )
            this.staticControlAry[i].setDynamicPos();
        
        for( let i = 0; i < this.mouseOnlyControlAry.length; ++i )
            this.mouseOnlyControlAry[i].setDynamicPos();

        for( let i = 0; i < this.controlAry.length; ++i )
            this.controlAry[i].setDynamicPos();
    }

    // 
    //  DESC: Find the reference nodes
    //
    findNodes( node, nodeIndex, navNodeMap )
    {
        let navNode = node.getElementsByTagName( 'navigate' );
        if( navNode.length )
        {
            this.setNodes( navNode, nodeIndex, 'up',    _common_defs__WEBPACK_IMPORTED_MODULE_13__.ENAV_NODE_UP,    navNodeMap );
            this.setNodes( navNode, nodeIndex, 'down',  _common_defs__WEBPACK_IMPORTED_MODULE_13__.ENAV_NODE_DOWN,  navNodeMap );
            this.setNodes( navNode, nodeIndex, 'left',  _common_defs__WEBPACK_IMPORTED_MODULE_13__.ENAV_NODE_LEFT,  navNodeMap );
            this.setNodes( navNode, nodeIndex, 'right', _common_defs__WEBPACK_IMPORTED_MODULE_13__.ENAV_NODE_RIGHT, navNodeMap );
        }
    }

    // 
    //  DESC: Find the reference nodes
    //
    setNodes( node, nodeIndex, attrStr, navId, navNodeMap )
    {
        let attr = node[0].getAttribute( attrStr );
        if( attr )
        {
            let ctrlNode = navNodeMap.get( attr );
            if( ctrlNode !== undefined )
                this.controlNodeAry[nodeIndex].setNode( navId, ctrlNode );
            else
                throw new Error( `Control node doesn't exist! (${attr}, ${attrStr})` );
        }
    }
    
    // 
    //  DESC: Init the menu controls
    //
    init()
    {
        for( let i = 0; i < this.staticControlAry.length; ++i )
            this.staticControlAry[i].init();

        for( let i = 0; i < this.mouseOnlyControlAry.length; ++i )
            this.mouseOnlyControlAry[i].init();

        for( let i = 0; i < this.controlAry.length; ++i )
            this.controlAry[i].init();
        
        // Prepare any script functions that are flagged to prepareOnInit
        this.scriptComponent.prepareOnInit( this );

    }   // Init

    // 
    //  DESC: Init the menu controls
    //
    cleanUp()
    {
        for( let i = 0; i < this.staticControlAry.length; ++i )
            this.staticControlAry[i].cleanUp();

        for( let i = 0; i < this.mouseOnlyControlAry.length; ++i )
            this.mouseOnlyControlAry[i].cleanUp();

        for( let i = 0; i < this.controlAry.length; ++i )
            this.controlAry[i].cleanUp();

    }   // CleanUp
    
    // 
    //  DESC: Activate this menu because it's probably a root menu
    //
    activateMenu()
    {
        this.state = _gui_menudefs__WEBPACK_IMPORTED_MODULE_12__.EMS_IDLE;
        this.setVisible(true);
        this.setAlpha(1);
        this.activateFirstInactiveControl();
    }

    // 
    //  DESC: Update the menu
    //
    update()
    {
        this.scriptComponent.update();

        if( this.isVisible() )
        {
            for( let i = 0; i < this.spriteAry.length; ++i )
                this.spriteAry[i].update();
            
            for( let i = 0; i < this.staticControlAry.length; ++i )
                this.staticControlAry[i].update();
            
            for( let i = 0; i < this.mouseOnlyControlAry.length; ++i )
                this.mouseOnlyControlAry[i].update();
            
            for( let i = 0; i < this.controlAry.length; ++i )
                this.controlAry[i].update();
        }
    }

    // 
    //  DESC: Transform the menu
    //
    transform()
    {
        if( this.isVisible() )
        {
            super.transform();
            
            for( let i = 0; i < this.spriteAry.length; ++i )
                this.spriteAry[i].transform( this );
            
            for( let i = 0; i < this.staticControlAry.length; ++i )
                this.staticControlAry[i].transform( this );
            
            for( let i = 0; i < this.mouseOnlyControlAry.length; ++i )
                this.mouseOnlyControlAry[i].transform( this );
            
            for( let i = 0; i < this.controlAry.length; ++i )
                this.controlAry[i].transform( this );
        }
    }

    // 
    //  DESC: do the render
    //
    render( camera )
    {
        if( this.isVisible() )
        {
            for( let i = 0; i < this.spriteAry.length; ++i )
                this.spriteAry[i].render( camera );
            
            for( let i = 0; i < this.staticControlAry.length; ++i )
                this.staticControlAry[i].render( camera );
            
            for( let i = 0; i < this.mouseOnlyControlAry.length; ++i )
                this.mouseOnlyControlAry[i].render( camera );
            
            for( let i = 0; i < this.controlAry.length; ++i )
                this.controlAry[i].render( camera );
        }
    }

    // 
    //  DESC: Handle events
    //
    handleEvent( event )
    {
        // Have the controls handle events
        for( let i = 0; i < this.controlAry.length; ++i )
            this.controlAry[i].handleEvent( event );

        for( let i = 0; i < this.mouseOnlyControlAry.length; ++i )
            this.mouseOnlyControlAry[i].handleEvent( event );

        if( event instanceof _common_genericevent__WEBPACK_IMPORTED_MODULE_8__.GenericEvent )
        {
            if( event.type === _gui_menudefs__WEBPACK_IMPORTED_MODULE_12__.EGE_MENU_TRANS_IN )
            {
                this.onTransIn( event );
            }
            else if( event.type === _gui_menudefs__WEBPACK_IMPORTED_MODULE_12__.EGE_MENU_TRANS_OUT )
            {
                this.onTransOut( event );
            }
            else if( event.type === _gui_menudefs__WEBPACK_IMPORTED_MODULE_12__.EGE_MENU_REACTIVATE )
            {
                this.onReactivate( event );
            }
            else if( this.state === _gui_menudefs__WEBPACK_IMPORTED_MODULE_12__.EMS_IDLE )
            {
                if( event.type === _gui_menudefs__WEBPACK_IMPORTED_MODULE_12__.EGE_MENU_SELECT_ACTION )
                {
                    this.onSelectAction( event );
                }
                else if( event.type === _gui_menudefs__WEBPACK_IMPORTED_MODULE_12__.EGE_MENU_SET_ACTIVE_CONTROL )
                {
                    this.onSetActiveControl( event );
                }
                else if( event.type === _gui_menudefs__WEBPACK_IMPORTED_MODULE_12__.EGE_MENU_SCROLL_UP )
                {
                    this.onUpAction( event );
                }
                else if( event.type === _gui_menudefs__WEBPACK_IMPORTED_MODULE_12__.EGE_MENU_SCROLL_DOWN )
                {
                    this.onDownAction( event );
                }
                else if( event.type === _gui_menudefs__WEBPACK_IMPORTED_MODULE_12__.EGE_MENU_SCROLL_LEFT )
                {
                    this.onLeftAction( event );
                }
                else if( event.type === _gui_menudefs__WEBPACK_IMPORTED_MODULE_12__.EGE_MENU_SCROLL_RIGHT )
                {
                    this.onRightAction( event );
                }
                else if( (event.type >= _gui_menudefs__WEBPACK_IMPORTED_MODULE_12__.EGE_MENU_UP_ACTION) &&
                         (event.type <= _gui_menudefs__WEBPACK_IMPORTED_MODULE_12__.EGE_MENU_RIGHT_ACTION) )
                {
                    if( event.arg[0] === _common_defs__WEBPACK_IMPORTED_MODULE_13__.EAP_DOWN )
                    {
                        if( event.type === _gui_menudefs__WEBPACK_IMPORTED_MODULE_12__.EGE_MENU_UP_ACTION )
                        {
                            this.onUpAction( event );
                        }
                        else if( event.type === _gui_menudefs__WEBPACK_IMPORTED_MODULE_12__.EGE_MENU_DOWN_ACTION )
                        {
                            this.onDownAction( event );
                        }
                        if( event.type === _gui_menudefs__WEBPACK_IMPORTED_MODULE_12__.EGE_MENU_LEFT_ACTION )
                        {
                            this.onLeftAction( event );
                        }
                        else if( event.type === _gui_menudefs__WEBPACK_IMPORTED_MODULE_12__.EGE_MENU_RIGHT_ACTION )
                        {
                            this.onRightAction( event );
                        }
                    }
                }
            }
        }
        else if( this.state === _gui_menudefs__WEBPACK_IMPORTED_MODULE_12__.EMS_IDLE )
        {
            if( event.type === 'mousemove' )
            {
                this.onMouseMove( event );
            }
            else if( event.type === 'wheel' )
            {
                this.onWheel( event );
            }
        }
    }

    // 
    //  DESC: Handle OnUpAction message
    //
    onUpAction( /*event*/ )
    {
        this.navigateMenu( _common_defs__WEBPACK_IMPORTED_MODULE_13__.ENAV_NODE_UP );
    }

    // 
    //  DESC: Handle OnMenuDown message
    //
    onDownAction( /*event*/ )
    {
        this.navigateMenu( _common_defs__WEBPACK_IMPORTED_MODULE_13__.ENAV_NODE_DOWN );
    }

    // 
    //  DESC: Handle OnMenuLeft message
    //
    onLeftAction( /*event*/ )
    {
        this.navigateMenu( _common_defs__WEBPACK_IMPORTED_MODULE_13__.ENAV_NODE_LEFT );
    }

    // 
    //  DESC: Handle OnRightAction message
    //
    onRightAction( /*event*/ )
    {
        this.navigateMenu( _common_defs__WEBPACK_IMPORTED_MODULE_13__.ENAV_NODE_RIGHT );
    }

    // 
    //  DESC: Navigate the menu. Find the next control node that isn't
    //        disabled and make it the active control node
    //
    navigateMenu( navNodeAction )
    {
        if( this.activeNode !== null )
        {
            let navNode = this.activeNode;

            do
            {
                navNode = navNode.getNode( navNodeAction );
                
                if( navNode === null )
                {
                    break;
                }
                else if( !navNode.uiControl.isDisabled() )
                {
                    this.activeNode = navNode;

                    _managers_eventmanager__WEBPACK_IMPORTED_MODULE_5__.eventManager.dispatchEvent(
                        _gui_menudefs__WEBPACK_IMPORTED_MODULE_12__.EGE_MENU_CONTROL_STATE_CHANGE,
                        _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_11__.ECS_ACTIVE,
                        navNode.uiControl );

                    break;
                }
            }
            while( navNode );
        }
    }

    // 
    //  DESC: Handle OnMouseMove message
    //
    onMouseMove( event )
    {
        for( let each of this.controlNodeAry )
        {
            if( each.uiControl.onMouseMove( event ) )
                this.activeNode = each;
            else
                each.uiControl.deactivateControl();
        }

        for( let each of this.mouseOnlyControlAry )
            if( !each.onMouseMove( event ) )
                each.deactivateControl();
    }

    // 
    //  DESC: Handle OnWheel message
    //
    onWheel( event )
    {
        for( let each of this.mouseOnlyControlAry )
            each.onWheel( event );

        for( let each of this.controlAry )
            each.onWheel( event );
    }

    // 
    //  DESC: Handle OnSelectAction message
    //
    onSelectAction( event )
    {
        let selectionFound = false;

        if( (this.activeNode !== null) &&
            (this.activeNode.uiControl.handleSelectAction( event )) )
        {
            selectionFound = true;

            // Set the state to active which will block all messages until the state is reset to idle
            let ctrl = this.activeNode.uiControl.getActiveControl();
            if( ctrl && ctrl.actionType > _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_11__.ECAT_IDLE )
                this.state = _gui_menudefs__WEBPACK_IMPORTED_MODULE_12__.EMS_ACTIVE;
        }
        else if( event.arg[ _common_defs__WEBPACK_IMPORTED_MODULE_13__.ESMA_DEVICE_TYPE ] === _common_defs__WEBPACK_IMPORTED_MODULE_13__.MOUSE )
        {
            // For mouse only controls
            for( let i = 0; i < this.mouseOnlyControlAry.length; ++i )
            {
                if( this.mouseOnlyControlAry[i].handleSelectAction( event ) )
                {
                    selectionFound = true;

                    // Set the state to active which will block all messages until the state is reset to idle
                    if( this.mouseOnlyControlAry[i].actionType > _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_11__.ECAT_IDLE )
                        this.state = _gui_menudefs__WEBPACK_IMPORTED_MODULE_12__.EMS_ACTIVE;

                    break;
                }
            }
        }

        // Try to handle touch presses on a non-active control
        // The mouse just happends to be clicked over a non-active control
        if( !selectionFound && event.arg[ _common_defs__WEBPACK_IMPORTED_MODULE_13__.ESMA_DEVICE_TYPE ] === _common_defs__WEBPACK_IMPORTED_MODULE_13__.MOUSE )
        {
            // Deactivate the control that should be active
            if( (this.activeNode !== null) &&
                (event.arg[ _common_defs__WEBPACK_IMPORTED_MODULE_13__.ESMA_PRESS_TYPE ] === this.activeNode.uiControl.mouseSelectType) )
            {
                this.activeNode.uiControl.deactivateControl();

                // Go through all the controls on this menu to try to find the one clicked on
                for( let i = 0; i < this.controlAry.length; ++i )
                {
                    if( this.controlAry[i].handleSelectAction( event ) )
                    {
                        // Set the state to active which will block all messages until the state is reset to idle
                        let ctrl = this.activeNode.uiControl.getActiveControl();
                        if( ctrl && ctrl.actionType > _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_11__.ECAT_IDLE )
                            this.state = _gui_menudefs__WEBPACK_IMPORTED_MODULE_12__.EMS_ACTIVE;

                        break;
                    }
                }
            }
        }
    }

    // 
    //  DESC: Handle OnSetActiveControl message
    //
    onSetActiveControl( event )
    {
        // Set the first inactive control to active
        if( event.arg[0] === _gui_menudefs__WEBPACK_IMPORTED_MODULE_12__.EAC_FIRST_ACTIVE_CONTROL )
            this.activateFirstInactiveControl();
    }

    // 
    //  DESC: Handle OnReactivate message
    //
    onReactivate( /*event*/ )
    {
        this.state = _gui_menudefs__WEBPACK_IMPORTED_MODULE_12__.EMS_IDLE;
    }

    // 
    //  DESC: Handle OnTransIn message
    //
    onTransIn( event )
    {
        if( event.arg[0] === _gui_menudefs__WEBPACK_IMPORTED_MODULE_12__.ETC_BEGIN )
        {
            this.scriptComponent.prepare( 'transIn', this );

            this.state = _gui_menudefs__WEBPACK_IMPORTED_MODULE_12__.EMS_ACTIVE;
        }
        else if( event.arg[0] === _gui_menudefs__WEBPACK_IMPORTED_MODULE_12__.ETC_END )
        {
            this.state = _gui_menudefs__WEBPACK_IMPORTED_MODULE_12__.EMS_IDLE;
        }
    }

    // 
    //  DESC: Handle OnTransOut message
    //
    onTransOut( event )
    {
        if( event.arg[0] === _gui_menudefs__WEBPACK_IMPORTED_MODULE_12__.ETC_BEGIN )
        {
            this.scriptComponent.prepare( 'transOut', this );

            this.state = _gui_menudefs__WEBPACK_IMPORTED_MODULE_12__.EMS_ACTIVE;
        }
        else if( event.arg[0] === _gui_menudefs__WEBPACK_IMPORTED_MODULE_12__.ETC_END )
        {
            this.state = _gui_menudefs__WEBPACK_IMPORTED_MODULE_12__.EMS_INACTIVE;
        }
    }

    // 
    //  DESC: Set the first inactive control to be active
    //
    activateFirstInactiveControl()
    {
        let found = false;

        // Activate the first control found and deactivate all the rest
        for( let i = 0; i < this.controlNodeAry.length; ++i )
        {
            if( !found && this.controlNodeAry[i].uiControl.activateFirstInactiveControl() )
            {
                this.activeNode = this.controlNodeAry[i];

                found = true;
            }
            else
            {
                this.controlNodeAry[i].uiControl.deactivateControl();
            }
        }
    }

    // 
    //  DESC: Reset all controls
    //
    reset()
    {
        for( let i = 0; i < this.controlAry.length; ++i )
            this.controlAry[i].reset( true );

        for( let i = 0; i < this.mouseOnlyControlAry.length; ++i )
            this.mouseOnlyControlAry[i].reset( true );
    }

    // 
    //  DESC: Get the control in question
    //
    getControl( name )
    {
        // See if the control can be found
        let control = this.controlMap.get( name );

        // Make sure control is available
        if( control === undefined )
            throw new Error( `Control being asked for is missing! (${name}).` );

        // Pass back the control if found
        return control;
    }

    // 
    //  DESC: Get the pointer to the active control
    //
    getActiveControl()
    {
        let result = null;

        for( let i = 0; i < this.controlAry.length; ++i )
        {
            if( this.controlAry[i].state > _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_11__.ECS_INACTIVE )
            {
                result = this.controlAry[i].getActiveControl();
                break;
            }
        }

        return result;
    }

    // 
    //  DESC: Does this menu use dynamic offsets
    //
    isDynamicOffset()
    {
        return !this.dynamicOffset.isEmpty();
    }

    // 
    //  DESC: Get the scroll params
    //
    getScrollParam( msg )
    {
        if( (this.activeNode != null) &&
            this.activeNode.uiControl.canScroll(msg) )
        {
            return this.activeNode.uiControl.scrollParam;
        }

        return this.scrollParam;
    }

    // 
    //  DESC: Set the alpha value of this menu
    //
    setAlpha( alpha )
    {
        if( this.isVisible() )
        {
            for( let i = 0; i < this.spriteAry.length; ++i )
                this.spriteAry[i].setAlpha( alpha );

            for( let i = 0; i < this.staticControlAry.length; ++i )
                this.staticControlAry[i].setAlpha( alpha );

            for( let i = 0; i < this.mouseOnlyControlAry.length; ++i )
                this.mouseOnlyControlAry[i].setAlpha( alpha );

            for( let i = 0; i < this.controlAry.length; ++i )
                this.controlAry[i].setAlpha( alpha );
        }

        this.alpha = alpha;
    }
    
    // 
    //  DESC: Get the alpha value of this menu
    //
    getAlpha()
    {
        return this.alpha;
    }

    // 
    //  DESC: Is the menu idle
    //
    isIdle()
    {
        return (this.state === _gui_menudefs__WEBPACK_IMPORTED_MODULE_12__.EMS_IDLE);
    }

    // 
    //  DESC: Get the number of controls in this subcontrol
    //
    get length()
    {
        return this.subControlAry.length;
    }
}


/***/ }),
/* 35 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ScrollParam": () => (/* binding */ ScrollParam)
/* harmony export */ });
/* harmony import */ var _gui_menudefs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(36);
// 
//  FILE NAME: scrollparam.js
//  DESC:      Class for handling scroll parameter data
//




class ScrollParam
{
    constructor()
    {
        // Array that holds the scroll messages allows by this menu or control
        this.scrollTypesMap = null;

        // The delay of the first scroll message
        this.startDelay = -1;

        // The delay of the rest of the scroll messages
        this.scrollDelay = -1;

        // The scroll message to send from the timer
        this.msg = -1;
    }
    
    // 
    //  DESC: Load the scroll data from node
    //
    loadFromNode( node )
    {
        if( node.length )
        {
            this.scrollTypesMap = new Map;
            
            this.startDelay = Number(node[0].getAttribute( 'startDelay' ));
            this.scrollDelay = Number(node[0].getAttribute( 'scrollDelay' ));
            
            if( node[0].getAttribute( 'up' ) === 'true' )
                this.scrollTypesMap.set( _gui_menudefs__WEBPACK_IMPORTED_MODULE_0__.EGE_MENU_UP_ACTION, _gui_menudefs__WEBPACK_IMPORTED_MODULE_0__.EGE_MENU_SCROLL_UP );

            if( node[0].getAttribute( 'down' ) === 'true' )
                this.scrollTypesMap.set( _gui_menudefs__WEBPACK_IMPORTED_MODULE_0__.EGE_MENU_DOWN_ACTION, _gui_menudefs__WEBPACK_IMPORTED_MODULE_0__.EGE_MENU_SCROLL_DOWN );

            if( node[0].getAttribute( 'left' ) === 'true' )
                this.scrollTypesMap.set( _gui_menudefs__WEBPACK_IMPORTED_MODULE_0__.EGE_MENU_LEFT_ACTION, _gui_menudefs__WEBPACK_IMPORTED_MODULE_0__.EGE_MENU_SCROLL_LEFT );

            if( node[0].getAttribute( 'right' ) === 'true' )
                this.scrollTypesMap.set( _gui_menudefs__WEBPACK_IMPORTED_MODULE_0__.EGE_MENU_RIGHT_ACTION, _gui_menudefs__WEBPACK_IMPORTED_MODULE_0__.EGE_MENU_SCROLL_RIGHT );
        }
    }
    
    // 
    //  DESC: Does this menu or control support scrolling this message?
    //
    canScroll( msg )
    {
        if( this.scrollTypesMap )
        {
            this.msg = -1;

            let result = this.scrollTypesMap.get( msg );

            if( result )
            {
                this.msg = result;
                return true;
            }
        }

        return false;
    }
}

/***/ }),
/* 36 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EMS_INACTIVE": () => (/* binding */ EMS_INACTIVE),
/* harmony export */   "EMS_IDLE": () => (/* binding */ EMS_IDLE),
/* harmony export */   "EMS_ACTIVE": () => (/* binding */ EMS_ACTIVE),
/* harmony export */   "EMS_MAX_MENU_STATES": () => (/* binding */ EMS_MAX_MENU_STATES),
/* harmony export */   "EMNS_NULL": () => (/* binding */ EMNS_NULL),
/* harmony export */   "EMNS_MOUSE": () => (/* binding */ EMNS_MOUSE),
/* harmony export */   "EMNS_GAMEPAD_KEYBAORD": () => (/* binding */ EMNS_GAMEPAD_KEYBAORD),
/* harmony export */   "EMTS_INACTIVE": () => (/* binding */ EMTS_INACTIVE),
/* harmony export */   "EMTS_IDLE": () => (/* binding */ EMTS_IDLE),
/* harmony export */   "EMTS_ACTIVE": () => (/* binding */ EMTS_ACTIVE),
/* harmony export */   "EMTS_MAX_MENU_TREE_STATES": () => (/* binding */ EMTS_MAX_MENU_TREE_STATES),
/* harmony export */   "EGE_MENU_TRANS_IN": () => (/* binding */ EGE_MENU_TRANS_IN),
/* harmony export */   "EGE_MENU_TRANS_OUT": () => (/* binding */ EGE_MENU_TRANS_OUT),
/* harmony export */   "EGE_MENU_ESCAPE_ACTION": () => (/* binding */ EGE_MENU_ESCAPE_ACTION),
/* harmony export */   "EGE_MENU_TOGGLE_ACTION": () => (/* binding */ EGE_MENU_TOGGLE_ACTION),
/* harmony export */   "EGE_MENU_BACK_ACTION": () => (/* binding */ EGE_MENU_BACK_ACTION),
/* harmony export */   "EGE_MENU_TO_TREE": () => (/* binding */ EGE_MENU_TO_TREE),
/* harmony export */   "EGE_MENU_TO_MENU": () => (/* binding */ EGE_MENU_TO_MENU),
/* harmony export */   "EGE_MENU_GAME_STATE_CHANGE": () => (/* binding */ EGE_MENU_GAME_STATE_CHANGE),
/* harmony export */   "EGE_MENU_UP_ACTION": () => (/* binding */ EGE_MENU_UP_ACTION),
/* harmony export */   "EGE_MENU_DOWN_ACTION": () => (/* binding */ EGE_MENU_DOWN_ACTION),
/* harmony export */   "EGE_MENU_LEFT_ACTION": () => (/* binding */ EGE_MENU_LEFT_ACTION),
/* harmony export */   "EGE_MENU_RIGHT_ACTION": () => (/* binding */ EGE_MENU_RIGHT_ACTION),
/* harmony export */   "EGE_MENU_CONTROL_STATE_CHANGE": () => (/* binding */ EGE_MENU_CONTROL_STATE_CHANGE),
/* harmony export */   "EGE_MENU_SELECT_ACTION": () => (/* binding */ EGE_MENU_SELECT_ACTION),
/* harmony export */   "EGE_MENU_SELECT_EXECUTE": () => (/* binding */ EGE_MENU_SELECT_EXECUTE),
/* harmony export */   "EGE_MENU_SET_ACTIVE_CONTROL": () => (/* binding */ EGE_MENU_SET_ACTIVE_CONTROL),
/* harmony export */   "EGE_MENU_REACTIVATE": () => (/* binding */ EGE_MENU_REACTIVATE),
/* harmony export */   "EGE_MENU_SCROLL_UP": () => (/* binding */ EGE_MENU_SCROLL_UP),
/* harmony export */   "EGE_MENU_SCROLL_DOWN": () => (/* binding */ EGE_MENU_SCROLL_DOWN),
/* harmony export */   "EGE_MENU_SCROLL_LEFT": () => (/* binding */ EGE_MENU_SCROLL_LEFT),
/* harmony export */   "EGE_MENU_SCROLL_RIGHT": () => (/* binding */ EGE_MENU_SCROLL_RIGHT),
/* harmony export */   "EGE_MENU_TAB_LEFT": () => (/* binding */ EGE_MENU_TAB_LEFT),
/* harmony export */   "EGE_MENU_TAB_RIGHT": () => (/* binding */ EGE_MENU_TAB_RIGHT),
/* harmony export */   "EAC_NULL": () => (/* binding */ EAC_NULL),
/* harmony export */   "EAC_FIRST_ACTIVE_CONTROL": () => (/* binding */ EAC_FIRST_ACTIVE_CONTROL),
/* harmony export */   "EAC_LAST_ACTIVE_CONTROL": () => (/* binding */ EAC_LAST_ACTIVE_CONTROL),
/* harmony export */   "ETC_RESET": () => (/* binding */ ETC_RESET),
/* harmony export */   "ETC_BEGIN": () => (/* binding */ ETC_BEGIN),
/* harmony export */   "ETC_END": () => (/* binding */ ETC_END)
/* harmony export */ });
// 
//  FILE NAME: menudefs.js
//  DESC:      misc defines
//



// EMenuState
const EMS_INACTIVE        = 0,
             EMS_IDLE            = 1,
             EMS_ACTIVE          = 2,
             EMS_MAX_MENU_STATES = 3;

// EMenuNavigationState
const EMNS_NULL             = 0,
             EMNS_MOUSE            = 1,
             EMNS_GAMEPAD_KEYBAORD = 2;

// EMenuTreeState
const EMTS_INACTIVE             = 0,
             EMTS_IDLE                 = 1,
             EMTS_ACTIVE               = 2,
             EMTS_MAX_MENU_TREE_STATES = 3;

// EMenuEvent
const EGE_MENU_TRANS_IN             = 100,
             EGE_MENU_TRANS_OUT            = 101,
             EGE_MENU_ESCAPE_ACTION        = 102,
             EGE_MENU_TOGGLE_ACTION        = 103,
             EGE_MENU_BACK_ACTION          = 104,
             EGE_MENU_TO_TREE              = 105,
             EGE_MENU_TO_MENU              = 106,
             EGE_MENU_GAME_STATE_CHANGE    = 107,
             EGE_MENU_UP_ACTION            = 108,
             EGE_MENU_DOWN_ACTION          = 109,
             EGE_MENU_LEFT_ACTION          = 110,
             EGE_MENU_RIGHT_ACTION         = 111,
             EGE_MENU_CONTROL_STATE_CHANGE = 112,
             EGE_MENU_SELECT_ACTION        = 113,
             EGE_MENU_SELECT_EXECUTE       = 114,
             EGE_MENU_SET_ACTIVE_CONTROL   = 115,
             EGE_MENU_REACTIVATE           = 116,
             EGE_MENU_SCROLL_UP            = 117,
             EGE_MENU_SCROLL_DOWN          = 118,
             EGE_MENU_SCROLL_LEFT          = 119,
             EGE_MENU_SCROLL_RIGHT         = 120,
             EGE_MENU_TAB_LEFT             = 121,
             EGE_MENU_TAB_RIGHT            = 122;

// EActiveControl
const EAC_NULL                 = 0,
             EAC_FIRST_ACTIVE_CONTROL = 1,
             EAC_LAST_ACTIVE_CONTROL  = 2;

// ETransCode
const ETC_RESET = 0,
             ETC_BEGIN = 1,
             ETC_END   = 2;

/***/ }),
/* 37 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Sprite": () => (/* binding */ Sprite)
/* harmony export */ });
/* harmony import */ var _common_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);
/* harmony import */ var _2d_visualcomponentquad__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(38);
/* harmony import */ var _2d_visualcomponentspritesheet__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(44);
/* harmony import */ var _2d_visualcomponentscaledframe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45);
/* harmony import */ var _2d_visualcomponentfont__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(46);
/* harmony import */ var _3d_visualcomponent3d__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(51);
/* harmony import */ var _common_nullvisualcomponent__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(52);
/* harmony import */ var _physics_physicscomponent2d__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(53);
/* harmony import */ var _utilities_matrix__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(12);
/* harmony import */ var _common_defs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(6);

// 
//  FILE NAME:  sprite.js
//  DESC:       Sprite class
//














class Sprite extends _common_object__WEBPACK_IMPORTED_MODULE_0__.Object
{
    constructor( objData, parentNode = null )
    {
        super();

        // parent node of this sprite
        this.parentNode = parentNode;

        // The object data
        this.objData = objData
        
        // The visual part of the sprite
        this.visualComponent = null
        
        // The physics part of the sprite
        this.physicsComponent = null;
        
        // Allocate the sprite specific objects
        if( objData.is2D() )
        {
            if( objData.visualData.genType === _common_defs__WEBPACK_IMPORTED_MODULE_9__.EGT_QUAD )
                this.visualComponent = new _2d_visualcomponentquad__WEBPACK_IMPORTED_MODULE_1__.VisualComponentQuad( objData.visualData );
            
            else if( objData.visualData.genType === _common_defs__WEBPACK_IMPORTED_MODULE_9__.EGT_SPRITE_SHEET )
                this.visualComponent = new _2d_visualcomponentspritesheet__WEBPACK_IMPORTED_MODULE_2__.VisualComponentSpriteSheet( objData.visualData );
            
            else if( objData.visualData.genType === _common_defs__WEBPACK_IMPORTED_MODULE_9__.EGT_SCALED_FRAME )
                this.visualComponent = new _2d_visualcomponentscaledframe__WEBPACK_IMPORTED_MODULE_3__.VisualComponentScaledFrame( objData.visualData );
            
            else if( objData.visualData.genType === _common_defs__WEBPACK_IMPORTED_MODULE_9__.EGT_FONT )
                this.visualComponent = new _2d_visualcomponentfont__WEBPACK_IMPORTED_MODULE_4__.VisualComponentFont( objData.visualData );
            
            if( objData.physicsData.isActive() )
                this.physicsComponent = new _physics_physicscomponent2d__WEBPACK_IMPORTED_MODULE_7__.PhysicsComponent2D( objData.physicsData );
        }
        else if( objData.is3D() )
        {
            // Matrix for rotations only, used for normal calculations
            this.rotMatrix = new _utilities_matrix__WEBPACK_IMPORTED_MODULE_8__.Matrix;
            this.visualComponent = new _3d_visualcomponent3d__WEBPACK_IMPORTED_MODULE_5__.VisualComponent3D( objData.visualData );
        }

        // Allocate the null component if no visual component was created
        if( this.visualComponent === null )
            this.visualComponent = new _common_nullvisualcomponent__WEBPACK_IMPORTED_MODULE_6__.NullVisualComponent();
        
        // If there's no visual data, set the hide flag
        this.setVisible( objData.visualData.isActive() );
    }
    
    // 
    //  DESC: Load from XML node
    //
    load( xmlNode )
    {
        // Load the transform data from node
        this.loadTransFromNode( xmlNode );

        // Load the script functions from node
        this.scriptComponent.initScriptIds( xmlNode );

        if( this.visualComponent.isFontSprite() )
            this.visualComponent.loadFontPropFromNode( xmlNode );
    }

    // 
    //  DESC: Load from XML node
    //
    reload( xmlNode )
    {
        // Load the sprite data
        this.load( xmlNode );

        // Init
        this.init();
        
        if( this.physicsComponent )
            this.physicsComponent.setTransform(this.pos.x, this.pos.y, this.rot.z);
    }
    
    // 
    //  DESC: Init the sprite
    //
    init()
    {
        if( this.visualComponent.isFontSprite() )
            this.visualComponent.createFontStringFromData();
        
        // Prepare any script functions that are flagged to prepareOnInit
        this.scriptComponent.prepareOnInit( this );
    }
    
    //
    //  DESC: Do some cleanup
    //
    cleanUp()
    {
        if( this.visualComponent.isFontSprite() )
            this.visualComponent.deleteFontVBO();
        
        if( this.physicsComponent )
            this.physicsComponent.destroyBody();
    }
    
    // 
    //  DESC: Init the physics
    //
    initPhysics()
    {
        if( this.physicsComponent )
            this.physicsComponent.init( this );
    }
    
    // 
    //  DESC: Handle events
    //
    handleEvent( event )
    {
        this.scriptComponent.handleEvent( event );
    }

    // 
    //  DESC: Update the sprite
    //
    update()
    {
        this.scriptComponent.update();
    }
    
    // 
    //  DESC: Update the physics
    //
    physicsUpdate()
    {
        if( this.physicsComponent )
            this.physicsComponent.update();
    }
    
    // 
    //  DESC: do the render
    //
    render( camera )
    {
        if( this.isVisible() )
            this.visualComponent.render( this, camera );
    }
    
    // 
    //  DESC: Set the color
    //
    setColor( color )
    {
        this.visualComponent.color.copy( color );
    }

    setRGBA( r, g, b, a )
    {
        // This function assumes values between 0.0 to 1.0.
        this.visualComponent.color.set( r, g, b, a );
    }
    
    // 
    //  DESC: Set the Alpha
    //
    setAlpha( alpha, allowToExceed = false )
    {
        if( allowToExceed || (alpha < this.objData.visualData.color.a) )
            this.visualComponent.color.a = alpha;
        else
            this.visualComponent.color.a = this.objData.visualData.color.a;
    }
    
    // 
    //  DESC: Get the Alpha
    //
    getAlpha()
    {
        return this.visualComponent.color.a;
    }
    
    // 
    //  DESC: Get the default Alpha
    //
    getDefaultAlpha()
    {
        return this.objData.visualData.color.a;
    }
    
    // 
    //  DESC: Set the default color
    //
    setDefaultColor()
    {
        this.visualComponent.color.copy( this.objData.visualData.color );
    }

    // 
    //  DESC: Get the color
    //
    getColor()
    {
        return this.visualComponent.color;
    }

    // 
    //  DESC: Get the color
    //
    getDefaultColor()
    {
        return this.objData.visualData.color;
    }
    
    // 
    //  DESC: Set the texture ID from index
    //
    setFrame( index = 0 )
    {
        if( this.visualComponent.frameIndex != index )
        {
            this.visualComponent.setFrame( index );

            if( this.objData.visualData.genType === _common_defs__WEBPACK_IMPORTED_MODULE_9__.EGT_SPRITE_SHEET )
                if( index < this.objData.visualData.spriteSheet.getCount() )
                    this.setCropOffset( this.objData.visualData.spriteSheet.getGlyph(index).cropOffset );
        }
    }
    
    // 
    //  DESC: Set the texture ID from index
    //
    getFrameCount()
    {
        return this.objData.visualData.getFrameCount();
    }

    //
    //  DESC: Is the physics active
    //
    isPhysicsActive()
    {
        if( this.physicsComponent && this.physicsComponent.isActive() )
            return true;

        return false;
    }

    //
    //  DESC: Is the physics awake
    //
    isPhysicsAwake()
    {
        if( this.isPhysicsActive() && this.physicsComponent.isAwake() )
            return true;

        return false;
    }

    //
    //  DESC: Apply the rotation
    //
    applyRotation( matrix )
    {
        // 3D light calculations require a rotation matrix without scale
        if( this.objData.is3D() )
        {
            // Add in the center point prior to rotation
            if( this.parameters.isSet( _common_defs__WEBPACK_IMPORTED_MODULE_9__.CENTER_POINT ) )
                this.matrix.translate( this.centerPos );
            
            // Add in the rotation if this is NOT a physics transformation
            // NOTE: Don't have a 3D physics library yet
            //if( !this.parameters.isSet( defs.PHYSICS_TRANSFORM ) )
            {
                this.rotMatrix.initilizeMatrix();
                this.rotMatrix.rotate( this.rot );
            }

            // Since the rotation has already been done, multiply it into the matrix
            matrix.multiply3x3( this.rotMatrix.matrix );

            // Subtract the center point after rotation to put back in original position
            // Doing two inverts keeps us from having to new up a point that would be garbage collected
            if( this.parameters.isSet( _common_defs__WEBPACK_IMPORTED_MODULE_9__.CENTER_POINT ) )
            {
                this.centerPos.invert();
                this.matrix.translate( this.centerPos );
                this.centerPos.invert();
            }
        }
        else
            super.applyRotation( matrix );
    }
}


/***/ }),
/* 38 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VisualComponentQuad": () => (/* binding */ VisualComponentQuad)
/* harmony export */ });
/* harmony import */ var _common_ivisualcomponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(39);
/* harmony import */ var _managers_shadermanager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40);
/* harmony import */ var _managers_texturemanager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);
/* harmony import */ var _managers_vertexbuffermanager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(42);
/* harmony import */ var _utilities_matrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(12);
/* harmony import */ var _common_color__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(20);
/* harmony import */ var _system_device__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(9);
/* harmony import */ var _common_defs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(6);

// 
//  FILE NAME:  visualcomponentquad.js
//  DESC:       Class for handling the visual part of the sprite
//












// Global final matrix to be reused by every render call so that an object specific
// one doesn't have to be created each time a render call is made or a perminate one
// allocated and heald within each class
var gFinalMatrix = new _utilities_matrix__WEBPACK_IMPORTED_MODULE_4__.Matrix;

class VisualComponentQuad extends _common_ivisualcomponent__WEBPACK_IMPORTED_MODULE_0__.ivisualComponent
{
    constructor( visualData )
    {
        super();
        
        this.visualData = visualData;
        this.shaderData = null;
        this.vertexLocation = null;
        this.text0Location = null;
        this.uvLocation = null;
        this.matrixLocation = null;
        this.colorLocation = null;
        this.VERTEX_BUF_SIZE = 20;
        this.frameIndex = 0;
        this.vbo = visualData.vbo;
        this.ibo = visualData.ibo;
        this.iboCount = visualData.iboCount;
        this.texture = visualData.getTexture();
        this.color = new _common_color__WEBPACK_IMPORTED_MODULE_5__.Color;
        
        if( visualData.isActive() )
        {
            this.shaderData = _managers_shadermanager__WEBPACK_IMPORTED_MODULE_1__.shaderManager.getShaderData( visualData.shaderID );

            // Common shader members
            this.vertexLocation = this.shaderData.getLocation( 'in_position' );
            this.matrixLocation = this.shaderData.getLocation( 'cameraViewProjMatrix' );
            this.colorLocation = this.shaderData.getLocation( 'color' );
            
            // Do we have a texture? This could be a solid rect
            if( this.texture !== null )
            {
                this.uvLocation = this.shaderData.getLocation( 'in_uv' );
                this.text0Location = this.shaderData.getLocation( 'text0' );
            }
            
            this.color.copy( this.visualData.color );
        }
    }

    //
    //  DESC: do the render
    //
    render( object, camera )
    {
        if( this.allowRender() )
        {
            let gl = _system_device__WEBPACK_IMPORTED_MODULE_6__.device.gl;
            
            // Bind the VBO and IBO
            _managers_vertexbuffermanager__WEBPACK_IMPORTED_MODULE_3__.vertexBufferManager.bind( this.vbo, this.ibo );

            // Bind the shader.
            _managers_shadermanager__WEBPACK_IMPORTED_MODULE_1__.shaderManager.bind( this.shaderData );
            
            // Setup the vertex attribute shader data
            gl.vertexAttribPointer( this.vertexLocation, 3, gl.FLOAT, false, this.VERTEX_BUF_SIZE, 0 );
            
            if( this.texture )
            {
                // Bind the texture
                _managers_texturemanager__WEBPACK_IMPORTED_MODULE_2__.textureManager.bind( this.texture.id );
                gl.uniform1i( this.text0Location, 0 ); // 0 = TEXTURE0

                // Setup the UV attribute shade data
                gl.vertexAttribPointer( this.uvLocation, 2, gl.FLOAT, false, this.VERTEX_BUF_SIZE, 12 );
            }
            
            // Send the color to the shader
            gl.uniform4fv( this.colorLocation, this.color.data );
            
            // Calculate the final matrix
            gFinalMatrix.initilizeMatrix();
            gFinalMatrix.setScaleFromSize( this.visualData.vertexScale );
            gFinalMatrix.mergeMatrix( object.matrix.matrix );
            gFinalMatrix.mergeMatrix( camera.finalMatrix.matrix );

            // Send the final matrix to the shader
            gl.uniformMatrix4fv( this.matrixLocation, false, gFinalMatrix.matrix );
            
            // Do the render
            gl.drawElements(gl.TRIANGLE_FAN, this.iboCount, gl.UNSIGNED_BYTE, 0);
        }
    }
    
    //
    //  DESC: Is rendering allowed?
    //
    allowRender()
    {
        return (this.visualData.genType != _common_defs__WEBPACK_IMPORTED_MODULE_7__.EGT_NULL);
    }
    
    //
    //  DESC: Set the frame ID from index
    //
    setFrame( index )
    {
        if( index < this.visualData.getFrameCount() )
        {
            this.frameIndex = index;
            this.texture = this.visualData.getTexture( index );
        }
    }
    
    //
    //  DESC: Get the frame count
    //
    getFrameCount()
    {
        return this.visualData.getFrameCount();
    }
}


/***/ }),
/* 39 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ivisualComponent": () => (/* binding */ ivisualComponent)
/* harmony export */ });

// 
//  FILE NAME:  ivisualcomponent.js
//  DESC:       Interface class
//



class ivisualComponent
{
    constructor()
    {
    }
    
    //
    //  DESC: Delete the custom VBO for this font
    //
    deleteFontVBO()
    {
    }
    
    //
    //  DESC: Is this a font sprite
    //
    isFontSprite()
    {
        return false;
    }
    
    //
    //  DESC: Set the frame ID from index
    //
    setFrame( /*index*/ )
    {
    }
    
    //
    //  DESC: Get the frame count
    //
    getFrameCount()
    {
        return 1;
    }
    
    //
    //  DESC: Get the font size
    //
    getFontSize()
    {
        return 0;
    }
}


/***/ }),
/* 40 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "shaderManager": () => (/* binding */ shaderManager)
/* harmony export */ });
/* harmony import */ var _common_shaderdata__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(41);
/* harmony import */ var _system_device__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);
/* harmony import */ var _managers_signalmanager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2);
/* harmony import */ var _utilities_genfunc__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(26);

// 
//  FILE NAME: shadermanager.js
//  DESC:      shader class singleton
//








class ShaderManager
{
    constructor()
    {
        this.shaderMap = new Map;
        this.currentShaderData = null;
        this.currentAttributeCount = 0;
    }

    // 
    //  DESC: Load the shader from object
    //
    loadFromObj( obj )
    {
        let promiseAry = [];

        for( const [key, value] of Object.entries(obj) )
            this.createShader( key, value );

        return Promise.all( promiseAry );
    }

    // 
    //  DESC: Setup the load request to load the shader files from the server
    //
    createShader( name, data )
    {
        let gl = _system_device__WEBPACK_IMPORTED_MODULE_1__.device.gl;

        // Check for duplicate
        if( this.shaderMap.has(name) )
            throw new Error( `Shader of this name already exists (${name}).` );

        // Add an entry to the map
        let shaderData = new _common_shaderdata__WEBPACK_IMPORTED_MODULE_0__.ShaderData(name);
        this.shaderMap.set( name, shaderData );

        // Create the vertex shader
        let vertPromise = _utilities_genfunc__WEBPACK_IMPORTED_MODULE_3__.downloadFile( 'txt', data.vert.file )
            .then(( vertText ) => this.create( gl.VERTEX_SHADER, shaderData, name, vertText ) );

        // Create the frag shader
        let fragPromise = _utilities_genfunc__WEBPACK_IMPORTED_MODULE_3__.downloadFile( 'txt', data.frag.file )
            .then( (fragText ) => this.create( gl.FRAGMENT_SHADER, shaderData, name, fragText ) );
        
        return Promise.all( [vertPromise, fragPromise] )
            .then(() =>
            {
                // Combine the shaders into a program
                this.createProgram( shaderData );
                
                // Find the location of the custom shader variables
                this.locateShaderVariables( shaderData, data.vert.dataType, data.frag.dataType );

                // Init the shader
                _managers_signalmanager__WEBPACK_IMPORTED_MODULE_2__.signalManager.broadcast_initShader( name );
            });
    }
    
    // 
    //  DESC: Create the shaders from the shader files
    //
    create( shaderType, shaderData, shaderTxtId, shaderTxt )
    {
        let gl = _system_device__WEBPACK_IMPORTED_MODULE_1__.device.gl;
        let id = gl.createShader(shaderType);
        if( id === 0 )
            throw new Error( `Error creating shader (${shaderTxtId}).` );
        
        // Load the shader text
        gl.shaderSource(id, shaderTxt);
        
        // Compile the shader and check for error
        gl.compileShader(id);
        if( !gl.getShaderParameter(id, gl.COMPILE_STATUS) )
                throw new Error( `ERROR compiling shader! (${gl.getShaderInfoLog(id)}).` );
        
        if( shaderType === gl.VERTEX_SHADER )
            shaderData.vertexId = id;

        else
            shaderData.fragmentId = id;
    }
    
    // 
    //  DESC: Create the programs
    //
    createProgram( shaderData )
    {
        let gl = _system_device__WEBPACK_IMPORTED_MODULE_1__.device.gl;

        // Combine the shaders into a program
        shaderData.programId = gl.createProgram();
        gl.attachShader( shaderData.programId, shaderData.vertexId );
        gl.attachShader( shaderData.programId, shaderData.fragmentId );
        
        // Link the shader program
        gl.linkProgram( shaderData.programId );
            
        if( !gl.getProgramParameter( shaderData.programId, gl.LINK_STATUS ) )
            throw new Error( `ERROR linking program! (${shaderData.name}, ${gl.getProgramInfoLog(shaderData.programId)}).` );

        gl.validateProgram( shaderData.programId );

        if( !gl.getProgramParameter( shaderData.programId, gl.VALIDATE_STATUS ) )
            throw new Error( `ERROR validating program! (${shaderData.name}, ${gl.getProgramInfoLog(shaderData.programId)}).` );
    }

    // 
    //  DESC: Locate the indexes of the shader variables
    //
    locateShaderVariables( shaderData, vertObj, fragObj )
    {
        let gl = _system_device__WEBPACK_IMPORTED_MODULE_1__.device.gl;

        for( const each of vertObj )
        {
            if( each.location !== undefined )
            {
                shaderData.locationMap.set( each.name, gl.getAttribLocation(shaderData.programId, each.name) );
                ++shaderData.attributeCount;
            }
            else
            {
                shaderData.locationMap.set( each.name, gl.getUniformLocation(shaderData.programId, each.name) );
            }
        }
        
        for( const each of fragObj )
            shaderData.locationMap.set( each.name, gl.getUniformLocation(shaderData.programId, each.name) );
    }
    
    // 
    //  DESC: Bind the shader program attribute variables
    //
    bind( shaderData )
    {
        if( this.currentShaderData != shaderData )
        {
            let gl = _system_device__WEBPACK_IMPORTED_MODULE_1__.device.gl;
            
            if( this.currentShaderData === null )
            {
                this.currentAttributeCount = shaderData.attributeCount;
                
                for( let i = 0; i < this.currentAttributeCount; ++i )
                    gl.enableVertexAttribArray(i);
            }
            else if( this.currentAttributeCount != shaderData.attributeCount )
            {
                if( this.currentAttributeCount < shaderData.attributeCount )
                {
                    for( let i = this.currentAttributeCount; i < shaderData.attributeCount; ++i )
                        gl.enableVertexAttribArray(i);
                }
                else
                {
                    for( let i = shaderData.attributeCount; i < this.currentAttributeCount; ++i )
                        gl.disableVertexAttribArray(i);
                }

                this.currentAttributeCount = shaderData.attributeCount;
            }
            
            // save the current binding
            this.currentShaderData = shaderData;
            
            // Have OpenGL bind this shader now
            gl.useProgram( shaderData.programId );
        }
    }
    
    // 
    //  DESC: Unbind the shader program attribute variables
    //
    unbind()
    {
        let gl = _system_device__WEBPACK_IMPORTED_MODULE_1__.device.gl;

        for( let i = 0; i < this.currentAttributeCount; ++i )
            gl.disableVertexAttribArray(i);
    
        this.currentShaderData = null;
        this.currentAttributeCount = 0;
        gl.useProgram( null );
    }
    
    // 
    //  DESC: Get the shader data
    //
    getShaderData( shaderId )
    {
        let shader = this.shaderMap.get( shaderId );
        if( shader !== undefined )
            return shader;
 
        throw new Error( `ERROR Shader has not been created! (${shaderId}).` );
    }
    
    // 
    //  DESC: Set the shader member varaible
    //
    setShaderValue4fv( shaderId, locationId, data )
    {
        let shaderData = this.getShaderData( shaderId );

        if( shaderData.hasLocation( locationId ) )
        {
            // Get the location of the variable
            let location = shaderData.getLocation( locationId );

            // Bind the shader so that we can change the value of the member
            this.bind( shaderData );

            _system_device__WEBPACK_IMPORTED_MODULE_1__.device.gl.uniform4fv( location, data );

            // Unbind now that we are done
            this.unbind();
        }
    }
    
    // 
    //  DESC: Set the shader member varaible
    //
    setAllShaderValue4fv( locationId, data )
    {
        for( let key of this.shaderMap.keys() )
            this.setShaderValue4fv( key, locationId, data );
    }
}

var shaderManager = new ShaderManager;


/***/ }),
/* 41 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ShaderData": () => (/* binding */ ShaderData)
/* harmony export */ });

// 
//  FILE NAME: shaderdata.js
//  DESC:      shader data class
//



class ShaderData
{
    constructor( name )
    {
        this.name = name;

        // OpenGL ID's
        this.programId = 0;
        this.vertexId = 0;
        this.fragmentId = 0;
        this.attributeCount = 0;
        
        // location shader map
        this.locationMap = new Map;
    }
    
    //
    //  DESC: Get the shader location variable
    //
    getLocation( id )
    {
        let loc = this.locationMap.get( id );
        if( loc !== undefined )
            return loc;
        else
            throw new Error( 'ERROR Shader variable location does not exist! (' + id + ').' );
    }
    
    //
    //  DESC: Check for the shader location variable
    //
    hasLocation( id )
    {
        return this.locationMap.has( id );
    }
}


/***/ }),
/* 42 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "vertexBufferManager": () => (/* binding */ vertexBufferManager)
/* harmony export */ });
/* harmony import */ var _system_device__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9);
/* harmony import */ var _common_point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14);
/* harmony import */ var _common_size__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony import */ var _common_quad2d__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(43);

//
//  FILE NAME: vertexbuffermanager.js
//  DESC:      vertex buffer manager class singleton
//








class VertexBufferManager
{
    constructor()
    {
        // Map containing a group of VBO handles
        this.vertexBufMapMap = new Map;

        // Map containing a group of IBO handles
        this.indexBufMapMap = new Map;

        // Current vbo
        this.currentVBO = null;

        // Current ibo
        this.currentIBO = null;

        // Current dynamic font IBO indices size
        this.currentMaxFontIndices = 0;
    }

    //
    //  DESC: Load all the textures associated with this group
    //
    createVBO( group, name, vertAry )
    {
        let gl = _system_device__WEBPACK_IMPORTED_MODULE_0__.device.gl;

        // Create the group map if it doesn't already exist
        let groupMap = this.vertexBufMapMap.get( group );
        if( groupMap === undefined )
        {
            groupMap = new Map;
            this.vertexBufMapMap.set( group, groupMap );
        }

        // See if this vertex buffer ID has already been created
        let vboID = groupMap.get( name );
        if( vboID === undefined )
        {
            vboID = gl.createBuffer();
            gl.bindBuffer( gl.ARRAY_BUFFER, vboID );
            gl.bufferData( gl.ARRAY_BUFFER, new Float32Array(vertAry), gl.STATIC_DRAW );
            gl.bindBuffer( gl.ARRAY_BUFFER, null );

            groupMap.set( name, vboID );
        }

        return vboID;
    }

    //
    //  DESC: Load all the textures associated with this group
    //
    createIBO( group, name, indexAry, intAs8bit )
    {
        let gl = _system_device__WEBPACK_IMPORTED_MODULE_0__.device.gl;

        // Create the group map if it doesn't already exist
        let groupMap = this.indexBufMapMap.get( group );
        if( groupMap === undefined )
        {
            groupMap = new Map;
            this.indexBufMapMap.set( group, groupMap );
        }

        // See if this vertex buffer ID has already been created
        let iboID = groupMap.get( name );
        if( iboID === undefined )
        {
            iboID = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iboID);

            if( intAs8bit )
                gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(indexAry), gl.STATIC_DRAW );
            else
                gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexAry), gl.STATIC_DRAW );

            gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, null );

            groupMap.set( name, iboID );
        }

        return iboID;
    }
    
    //
    //  DESC: Create a dynamic font IBO buffer
    //
    createDynamicFontIBO( group, name, indexAry, maxIndicies )
    {
        let gl = _system_device__WEBPACK_IMPORTED_MODULE_0__.device.gl;

        // Create the group map if it doesn't already exist
        let groupMap = this.indexBufMapMap.get( group );
        if( groupMap === undefined )
        {
            groupMap = new Map;
            this.indexBufMapMap.set( group, groupMap );
        }

        // If it's not found, create the intex buffer and add it to the list
        let iboID = groupMap.get( name );
        if( iboID === undefined )
        {
            iboID = gl.createBuffer();

            groupMap.set( name, iboID );
        }    

        // If the new indices are greater then the current, init the IBO with the newest
        if( maxIndicies > this.currentMaxFontIndices )
        {
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, iboID);
            gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexAry), gl.STATIC_DRAW );
            gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, null );

            // Save the number of indices for later to compare and expand this size of this IBO
            this.currentMaxFontIndices = maxIndicies;
        }

        return iboID;
    }

    //
    //  DESC: Create a scaled frame
    //
    createScaledFrame( group, name, scaledFrame, textureSize, glyphSize, frameSize, spriteSheetOffset, meshFileVertAry = null )
    {
        let gl = _system_device__WEBPACK_IMPORTED_MODULE_0__.device.gl;

        // Create the group map if it doesn't already exist
        let groupMap = this.vertexBufMapMap.get( group );
        if( groupMap === undefined )
        {
            groupMap = new Map;
            this.vertexBufMapMap.set( group, groupMap );
        }
        
        // See if this vertex buffer ID has already been created
        let vboID = groupMap.get( name );
        if( vboID === undefined )
        {
            let vertAry = [];
            
            // Generate the scaled frame
            this.generateScaledFrame( vertAry, scaledFrame, textureSize, glyphSize, frameSize, spriteSheetOffset );
            
            if( meshFileVertAry !== null )
                Array.prototype.push.apply( vertAry, meshFileVertAry );
            
            vboID = gl.createBuffer();
            gl.bindBuffer( gl.ARRAY_BUFFER, vboID );
            gl.bufferData( gl.ARRAY_BUFFER, new Float32Array(vertAry), gl.STATIC_DRAW );
            gl.bindBuffer( gl.ARRAY_BUFFER, null );

            groupMap.set( name, vboID );
        }

        return vboID;
    }
    
    //
    //  DESC: Create a scaled frame
    //
    generateScaledFrame( vertAry, scaledFrame, textureSize, glyphSize, frameSize, spriteSheetOffset )
    {
        // Offsets to center the mesh
        let center = new _common_point__WEBPACK_IMPORTED_MODULE_1__.Point(frameSize.w / 2, frameSize.h / 2);
        let frameLgth = new _common_size__WEBPACK_IMPORTED_MODULE_2__.Size( frameSize.w - (scaledFrame.frame.w * 2.0), frameSize.h - (scaledFrame.frame.h * 2.0) );
        let uvLgth = new _common_size__WEBPACK_IMPORTED_MODULE_2__.Size( glyphSize.w - (scaledFrame.frame.w * 2.0), glyphSize.h - (scaledFrame.frame.h * 2.0) );

        let quadBuf = [new _common_quad2d__WEBPACK_IMPORTED_MODULE_3__.Quad2d, new _common_quad2d__WEBPACK_IMPORTED_MODULE_3__.Quad2d, new _common_quad2d__WEBPACK_IMPORTED_MODULE_3__.Quad2d, new _common_quad2d__WEBPACK_IMPORTED_MODULE_3__.Quad2d, new _common_quad2d__WEBPACK_IMPORTED_MODULE_3__.Quad2d, new _common_quad2d__WEBPACK_IMPORTED_MODULE_3__.Quad2d, new _common_quad2d__WEBPACK_IMPORTED_MODULE_3__.Quad2d, new _common_quad2d__WEBPACK_IMPORTED_MODULE_3__.Quad2d];

        // Left frame
        this.createQuad( 
            new _common_point__WEBPACK_IMPORTED_MODULE_1__.Point(-center.x, center.y-scaledFrame.frame.h),
            new _common_size__WEBPACK_IMPORTED_MODULE_2__.Size(scaledFrame.frame.w, -frameLgth.h),
            new _common_size__WEBPACK_IMPORTED_MODULE_2__.Size(0, scaledFrame.frame.h),
            new _common_size__WEBPACK_IMPORTED_MODULE_2__.Size(scaledFrame.frame.w, uvLgth.h),
            textureSize,
            frameSize,
            spriteSheetOffset,
            quadBuf[0] );

        // top left
        this.createQuad(
            new _common_point__WEBPACK_IMPORTED_MODULE_1__.Point(-center.x, center.y),
            new _common_size__WEBPACK_IMPORTED_MODULE_2__.Size(scaledFrame.frame.w, -scaledFrame.frame.h),
            new _common_size__WEBPACK_IMPORTED_MODULE_2__.Size(0, 0),
            new _common_size__WEBPACK_IMPORTED_MODULE_2__.Size(scaledFrame.frame.w, scaledFrame.frame.h),
            textureSize,
            frameSize,
            spriteSheetOffset,
            quadBuf[1] );

        // top
        this.createQuad(
            new _common_point__WEBPACK_IMPORTED_MODULE_1__.Point(-(center.x-scaledFrame.frame.w), center.y),
            new _common_size__WEBPACK_IMPORTED_MODULE_2__.Size(frameLgth.w, -scaledFrame.frame.h),
            new _common_size__WEBPACK_IMPORTED_MODULE_2__.Size(scaledFrame.frame.w, 0),
            new _common_size__WEBPACK_IMPORTED_MODULE_2__.Size(uvLgth.w, scaledFrame.frame.h),
            textureSize,
            frameSize,
            spriteSheetOffset,
            quadBuf[2] );

        // top right
        this.createQuad(
            new _common_point__WEBPACK_IMPORTED_MODULE_1__.Point(center.x-scaledFrame.frame.w, center.y),
            new _common_size__WEBPACK_IMPORTED_MODULE_2__.Size(scaledFrame.frame.w, -scaledFrame.frame.h),
            new _common_size__WEBPACK_IMPORTED_MODULE_2__.Size(scaledFrame.frame.w + uvLgth.w, 0),
            new _common_size__WEBPACK_IMPORTED_MODULE_2__.Size(scaledFrame.frame.w, scaledFrame.frame.h),
            textureSize,
            frameSize,
            spriteSheetOffset,
            quadBuf[3] );

        // right frame
        this.createQuad(
            new _common_point__WEBPACK_IMPORTED_MODULE_1__.Point(center.x-scaledFrame.frame.w, center.y-scaledFrame.frame.h),
            new _common_size__WEBPACK_IMPORTED_MODULE_2__.Size(scaledFrame.frame.w, -frameLgth.h),
            new _common_size__WEBPACK_IMPORTED_MODULE_2__.Size(scaledFrame.frame.w + uvLgth.w, scaledFrame.frame.h),
            new _common_size__WEBPACK_IMPORTED_MODULE_2__.Size(scaledFrame.frame.w, uvLgth.h),
            textureSize,
            frameSize,
            spriteSheetOffset,
            quadBuf[4] );

        // bottom right
        this.createQuad(
            new _common_point__WEBPACK_IMPORTED_MODULE_1__.Point(center.x-scaledFrame.frame.w, -(center.y-scaledFrame.frame.h)),
            new _common_size__WEBPACK_IMPORTED_MODULE_2__.Size(scaledFrame.frame.w, -scaledFrame.frame.h),
            new _common_size__WEBPACK_IMPORTED_MODULE_2__.Size(scaledFrame.frame.w + uvLgth.w, scaledFrame.frame.h + uvLgth.h),
            new _common_size__WEBPACK_IMPORTED_MODULE_2__.Size(scaledFrame.frame.w, scaledFrame.frame.h),
            textureSize,
            frameSize,
            spriteSheetOffset,
            quadBuf[5] );

        // bottom frame
        this.createQuad(
            new _common_point__WEBPACK_IMPORTED_MODULE_1__.Point(-(center.x-scaledFrame.frame.w), -(center.y-scaledFrame.frame.h)),
            new _common_size__WEBPACK_IMPORTED_MODULE_2__.Size(frameLgth.w, -scaledFrame.frame.h),
            new _common_size__WEBPACK_IMPORTED_MODULE_2__.Size(scaledFrame.frame.w, scaledFrame.frame.h + uvLgth.h),
            new _common_size__WEBPACK_IMPORTED_MODULE_2__.Size(uvLgth.w, scaledFrame.frame.h),
            textureSize,
            frameSize,
            spriteSheetOffset,
            quadBuf[6] );

        // bottom left
        this.createQuad(
            new _common_point__WEBPACK_IMPORTED_MODULE_1__.Point(-center.x, -(center.y-scaledFrame.frame.h)),
            new _common_size__WEBPACK_IMPORTED_MODULE_2__.Size(scaledFrame.frame.w, -scaledFrame.frame.h),
            new _common_size__WEBPACK_IMPORTED_MODULE_2__.Size(0, scaledFrame.frame.h + uvLgth.h),
            new _common_size__WEBPACK_IMPORTED_MODULE_2__.Size(scaledFrame.frame.w, scaledFrame.frame.h),
            textureSize,
            frameSize,
            spriteSheetOffset,
            quadBuf[7] );

        // Piece together the needed unique verts
        Array.prototype.push.apply( vertAry, quadBuf[0].vert[0].data );
        Array.prototype.push.apply( vertAry, quadBuf[0].vert[1].data );
        Array.prototype.push.apply( vertAry, quadBuf[0].vert[2].data );
        Array.prototype.push.apply( vertAry, quadBuf[0].vert[3].data );
        Array.prototype.push.apply( vertAry, quadBuf[1].vert[1].data );
        Array.prototype.push.apply( vertAry, quadBuf[1].vert[2].data );
        Array.prototype.push.apply( vertAry, quadBuf[2].vert[1].data );
        Array.prototype.push.apply( vertAry, quadBuf[2].vert[3].data );
        Array.prototype.push.apply( vertAry, quadBuf[3].vert[1].data );
        Array.prototype.push.apply( vertAry, quadBuf[3].vert[3].data );
        Array.prototype.push.apply( vertAry, quadBuf[4].vert[0].data );
        Array.prototype.push.apply( vertAry, quadBuf[4].vert[3].data );
        Array.prototype.push.apply( vertAry, quadBuf[5].vert[0].data );
        Array.prototype.push.apply( vertAry, quadBuf[5].vert[3].data );
        Array.prototype.push.apply( vertAry, quadBuf[6].vert[0].data );
        Array.prototype.push.apply( vertAry, quadBuf[7].vert[0].data );
    }
    
    //
    //  DESC: Create a quad
    //
    createQuad( vert, vSize, uv, uvSize, textureSize, frameSize, spriteSheetOffset, quadBuf )
    {
        // For OpenGL pixel perfect rendering is an even size graphic,
        // for DirectX, it's an odd size graphic.

        // Check if the width or height is odd. If so, we offset 
        // by 0.5 for proper orthographic rendering
        // speed enhancement - if( Math.trunc(frameSize.w) % 2 != 0 )
        let additionalOffsetX = 0;
        if( Math.trunc(frameSize.w) & 1 !== 0 )
            additionalOffsetX = 0.5;

        let additionalOffsetY = 0;
        if( Math.trunc(frameSize.h) & 2 !== 0 )
            additionalOffsetY = 0.5;

        // Calculate the third vertex of the first face
        quadBuf.vert[0].x = vert.x + additionalOffsetX;
        quadBuf.vert[0].y = vert.y + additionalOffsetY + vSize.h;
        quadBuf.vert[0].u = spriteSheetOffset.x1 + (uv.u / textureSize.w);
        quadBuf.vert[0].v = spriteSheetOffset.y1 + ((uv.v + uvSize.h) / textureSize.h);

        // Calculate the second vertex of the first face
        quadBuf.vert[1].x = vert.x + additionalOffsetX + vSize.w;
        quadBuf.vert[1].y = vert.y + additionalOffsetY;
        quadBuf.vert[1].u = spriteSheetOffset.x1 + ((uv.u + uvSize.w) / textureSize.w);
        quadBuf.vert[1].v = spriteSheetOffset.y1 + (uv.v / textureSize.h);

        // Calculate the first vertex of the first face
        quadBuf.vert[2].x = quadBuf.vert[0].x;
        quadBuf.vert[2].y = quadBuf.vert[1].y;
        quadBuf.vert[2].u = quadBuf.vert[0].u;
        quadBuf.vert[2].v = quadBuf.vert[1].v;

        // Calculate the second vertex of the second face
        quadBuf.vert[3].x = quadBuf.vert[1].x;
        quadBuf.vert[3].y = quadBuf.vert[0].y;
        quadBuf.vert[3].u = quadBuf.vert[1].u;
        quadBuf.vert[3].v = quadBuf.vert[0].v;
    }
    
    //
    //  DESC: Delete the group of buffers
    //
    deleteGroup( group )
    {
        let gl = _system_device__WEBPACK_IMPORTED_MODULE_0__.device.gl;

        let groupMap = this.vertexBufMapMap.get( group );
        if( groupMap !== undefined )
        {
            for( let vboID of groupMap.values() )
                gl.deleteBuffer( vboID );
            
            this.vertexBufMapMap.delete( group );
        }
        
        groupMap = this.indexBufMapMap.get( group );
        if( groupMap !== undefined )
        {
            for( let iboID of groupMap.values() )
                gl.deleteBuffer( iboID );
            
            this.indexBufMapMap.delete( group );
        }
    }
    
    //
    //  DESC: See if a VBO already exists
    //
    isVBO( group, name )
    {
        // See if the group exists
        let groupMap = this.vertexBufMapMap.get( group );
        if( groupMap === undefined )
            return null;

        // See if this vertex buffer ID has already been created
        let vboId = groupMap.get( name );
        if( vboId === undefined )
            return null;

        return vboId;
    }

    //
    //  DESC: Bind the buffers
    //
    bind( vbo, ibo )
    {
        let gl = _system_device__WEBPACK_IMPORTED_MODULE_0__.device.gl;

        if( this.currentVBO != vbo )
        {
            // save the current binding
            this.currentVBO = vbo;

            // Have OpenGL bind this buffer now
            gl.bindBuffer( gl.ARRAY_BUFFER, vbo );
        }

        if( this.currentIBO != ibo )
        {
            // save the current binding
            this.currentIBO = ibo;

            // Have OpenGL bind this buffer now
            gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, ibo );
        }
    }
    
    //
    //  DESC: Bind the buffers
    //
    unbind()
    {
        let gl = _system_device__WEBPACK_IMPORTED_MODULE_0__.device.gl;
        
        this.currentVBO = null;
        this.currentIBO = null;
        gl.bindBuffer( gl.ARRAY_BUFFER, null );
        gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, null );
    }
}

var vertexBufferManager = new VertexBufferManager;


/***/ }),
/* 43 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Quad2d": () => (/* binding */ Quad2d)
/* harmony export */ });
/* harmony import */ var _common_vertex2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(22);

// 
//  FILE NAME:  quad2d.js
//  DESC:       quad 2d class
//




class Quad2d
{
    constructor()
    {
        this.vert = [new _common_vertex2d__WEBPACK_IMPORTED_MODULE_0__.Vertex2d, new _common_vertex2d__WEBPACK_IMPORTED_MODULE_0__.Vertex2d, new _common_vertex2d__WEBPACK_IMPORTED_MODULE_0__.Vertex2d, new _common_vertex2d__WEBPACK_IMPORTED_MODULE_0__.Vertex2d];
    }
}


/***/ }),
/* 44 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VisualComponentSpriteSheet": () => (/* binding */ VisualComponentSpriteSheet)
/* harmony export */ });
/* harmony import */ var _2d_visualcomponentquad__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _managers_shadermanager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40);
/* harmony import */ var _managers_texturemanager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);
/* harmony import */ var _managers_vertexbuffermanager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(42);
/* harmony import */ var _utilities_matrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(12);
/* harmony import */ var _common_size__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(4);
/* harmony import */ var _system_device__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(9);

// 
//  FILE NAME:  visualcomponentspritesheet.js
//  DESC:       Class for handling the visual part of the sprite
//











// Global final matrix to be reused by every render call so that an object specific
// one doesn't have to be created each time a render call is made or a perminate one
// allocated and heald within each class
var gFinalMatrix = new _utilities_matrix__WEBPACK_IMPORTED_MODULE_4__.Matrix;

class VisualComponentSpriteSheet extends _2d_visualcomponentquad__WEBPACK_IMPORTED_MODULE_0__.VisualComponentQuad
{
    constructor( visualData )
    {
        super( visualData );
        
        if( visualData.isActive() )
        {
            this.glyphLocation = this.shaderData.getLocation( 'glyphRect' );

            this.glyphUV = visualData.spriteSheet.getGlyph().uv;
            this.frameIndex = visualData.spriteSheet.defaultIndex;

            // Local vertex scale for sprite sheets that might have glyphs of different sizes
            this.vertexScale = new _common_size__WEBPACK_IMPORTED_MODULE_5__.Size;
            this.vertexScale.copy( this.visualData.vertexScale );
        }
    }

    //
    //  DESC: do the render
    //
    render( object, camera )
    {
        if( this.allowRender() )
        {
            let gl = _system_device__WEBPACK_IMPORTED_MODULE_6__.device.gl;
            
            // Bind the VBO and IBO
            _managers_vertexbuffermanager__WEBPACK_IMPORTED_MODULE_3__.vertexBufferManager.bind( this.vbo, this.ibo );

            // Bind the shader.
            _managers_shadermanager__WEBPACK_IMPORTED_MODULE_1__.shaderManager.bind( this.shaderData );
            
            // Setup the vertex attribute shader data
            gl.vertexAttribPointer( this.vertexLocation, 3, gl.FLOAT, false, this.VERTEX_BUF_SIZE, 0 );
            
            if( this.texture )
            {
                // Bind the texture
                _managers_texturemanager__WEBPACK_IMPORTED_MODULE_2__.textureManager.bind( this.texture.id );
                gl.uniform1i( this.text0Location, 0 ); // 0 = TEXTURE0

                // Setup the UV attribute shade data
                gl.vertexAttribPointer( this.uvLocation, 2, gl.FLOAT, false, this.VERTEX_BUF_SIZE, 12 );
            }
            
            // Send the color to the shader
            gl.uniform4fv( this.colorLocation, this.color.data );
            
            // Calculate the final matrix
            gFinalMatrix.initilizeMatrix();
            gFinalMatrix.setScaleFromSize( this.vertexScale );
            gFinalMatrix.mergeMatrix( object.matrix.matrix );
            gFinalMatrix.mergeMatrix( camera.finalMatrix.matrix );

            // Send the final matrix to the shader
            gl.uniformMatrix4fv( this.matrixLocation, false, gFinalMatrix.matrix );

            // Send the glyph rect
            gl.uniform4fv( this.glyphLocation, this.glyphUV.data );
            
            // Do the render
            gl.drawElements(gl.TRIANGLE_FAN, this.iboCount, gl.UNSIGNED_BYTE, 0);
        }
    }
    
    //
    //  DESC: Set the frame ID from index
    //
    setFrame( index )
    {
        this.frameIndex = index;
        
        let glyph = this.visualData.spriteSheet.getGlyph( index );

        this.vertexScale.w = glyph.size.w * this.visualData.defaultUniformScale;
        this.vertexScale.h = glyph.size.h * this.visualData.defaultUniformScale;

        this.glyphUV = glyph.uv;
    }
}


/***/ }),
/* 45 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VisualComponentScaledFrame": () => (/* binding */ VisualComponentScaledFrame)
/* harmony export */ });
/* harmony import */ var _2d_visualcomponentquad__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _managers_shadermanager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40);
/* harmony import */ var _managers_texturemanager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);
/* harmony import */ var _managers_vertexbuffermanager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(42);
/* harmony import */ var _utilities_matrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(12);
/* harmony import */ var _system_device__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9);

// 
//  FILE NAME:  visualcomponentscaledframe.js
//  DESC:       Class for handling the visual part of the sprite
//










// Global final matrix to be reused by every render call so that an object specific
// one doesn't have to be created each time a render call is made or a perminate one
// allocated and heald within each class
var gFinalMatrix = new _utilities_matrix__WEBPACK_IMPORTED_MODULE_4__.Matrix;

class VisualComponentScaledFrame extends _2d_visualcomponentquad__WEBPACK_IMPORTED_MODULE_0__.VisualComponentQuad
{
    constructor( visualData )
    {
        super( visualData );
    }

    //
    //  DESC: do the render
    //
    render( object, camera )
    {
        if( this.allowRender() )
        {
            let gl = _system_device__WEBPACK_IMPORTED_MODULE_5__.device.gl;
            
            // Bind the VBO and IBO
            _managers_vertexbuffermanager__WEBPACK_IMPORTED_MODULE_3__.vertexBufferManager.bind( this.vbo, this.ibo );

            // Bind the shader.
            _managers_shadermanager__WEBPACK_IMPORTED_MODULE_1__.shaderManager.bind( this.shaderData );
            
            // Setup the vertex attribute shader data
            gl.vertexAttribPointer( this.vertexLocation, 3, gl.FLOAT, false, this.VERTEX_BUF_SIZE, 0 );
            
            if( this.texture )
            {
                // Bind the texture
                _managers_texturemanager__WEBPACK_IMPORTED_MODULE_2__.textureManager.bind( this.texture.id );
                gl.uniform1i( this.text0Location, 0 ); // 0 = TEXTURE0

                // Setup the UV attribute shade data
                gl.vertexAttribPointer( this.uvLocation, 2, gl.FLOAT, false, this.VERTEX_BUF_SIZE, 12 );
            }
            
            // Send the color to the shader
            gl.uniform4fv( this.colorLocation, this.color.data );
            
            // Calculate the final matrix
            gFinalMatrix.initilizeMatrix();
            gFinalMatrix.mergeMatrix( object.matrix.matrix );
            gFinalMatrix.mergeMatrix( camera.finalMatrix.matrix );

            // Send the final matrix to the shader
            gl.uniformMatrix4fv( this.matrixLocation, false, gFinalMatrix.matrix );
            
            // Do the render
            gl.drawElements(gl.TRIANGLES, this.iboCount, gl.UNSIGNED_BYTE, 0);
        }
    }
}


/***/ }),
/* 46 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VisualComponentFont": () => (/* binding */ VisualComponentFont)
/* harmony export */ });
/* harmony import */ var _2d_visualcomponentquad__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(38);
/* harmony import */ var _managers_shadermanager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40);
/* harmony import */ var _managers_texturemanager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);
/* harmony import */ var _managers_vertexbuffermanager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(42);
/* harmony import */ var _managers_fontmanager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(47);
/* harmony import */ var _common_fontdata__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(49);
/* harmony import */ var _utilities_matrix__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(12);
/* harmony import */ var _system_device__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(9);
/* harmony import */ var _common_defs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(6);
/* harmony import */ var _utilities_genfunc__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(26);

// 
//  FILE NAME:  visualcomponentfont.js
//  DESC:       Class for handling the visual part of the sprite
//














// Global final matrix to be reused by every render call so that an object specific
// one doesn't have to be created each time a render call is made or a perminate one
// allocated and heald within each class
var gFinalMatrix = new _utilities_matrix__WEBPACK_IMPORTED_MODULE_6__.Matrix;

class VisualComponentFont extends _2d_visualcomponentquad__WEBPACK_IMPORTED_MODULE_0__.VisualComponentQuad
{
    constructor( visualData )
    {
        super( visualData );
        
        if( visualData.isActive() )
        {
            this.uvLocation = this.shaderData.getLocation( 'in_uv' );
            this.text0Location = this.shaderData.getLocation( 'text0' );
            
            // Allocate the storage for the font if this is a font sprite
            this.fontData = new _common_fontdata__WEBPACK_IMPORTED_MODULE_5__.FontData;
        }
    }
    
    //
    //  DESC: Delete the custom VBO for this font
    //
    deleteFontVBO()
    {
        // Delete the VBO if this is a font
        if( (this.visualData.genType === _common_defs__WEBPACK_IMPORTED_MODULE_8__.EGT_FONT) && (this.vbo !== null) )
        {
            _system_device__WEBPACK_IMPORTED_MODULE_7__.device.gl.deleteBuffer( this.vbo );
            this.vbo = null;
        }

        // The IBO for the font is managed by the vertex buffer manager.
        // Font IBO are all the same with the only difference being
        // length of the character string.
    }

    //
    //  DESC: do the render
    //
    render( object, camera )
    {
        if( this.allowRender() )
        {
            let gl = _system_device__WEBPACK_IMPORTED_MODULE_7__.device.gl;

            // Bind the VBO and IBO
            _managers_vertexbuffermanager__WEBPACK_IMPORTED_MODULE_3__.vertexBufferManager.bind( this.vbo, this.ibo );

            // Bind the shader.
            _managers_shadermanager__WEBPACK_IMPORTED_MODULE_1__.shaderManager.bind( this.shaderData );
            
            // Setup the vertex attribute shader data
            gl.vertexAttribPointer( this.vertexLocation, 3, gl.FLOAT, false, this.VERTEX_BUF_SIZE, 0 );
            
            if( this.texture )
            {
                // Bind the texture
                _managers_texturemanager__WEBPACK_IMPORTED_MODULE_2__.textureManager.bind( this.texture.id );
                gl.uniform1i( this.text0Location, 0 ); // 0 = TEXTURE0

                // Setup the UV attribute shade data
                gl.vertexAttribPointer( this.uvLocation, 2, gl.FLOAT, false, this.VERTEX_BUF_SIZE, 12 );
            }
            
            // Send the color to the shader
            gl.uniform4fv( this.colorLocation, this.color.data );
            
            // Calculate the final matrix
            gFinalMatrix.initilizeMatrix();
            gFinalMatrix.mergeMatrix( object.matrix.matrix );
            gFinalMatrix.mergeMatrix( camera.finalMatrix.matrix );

            // Send the final matrix to the shader
            gl.uniformMatrix4fv( this.matrixLocation, false, gFinalMatrix.matrix );
            
            // Do the render
            gl.drawElements(gl.TRIANGLES, this.iboCount, gl.UNSIGNED_SHORT, 0);
        }
    }
    
    //
    //  DESC: Is rendering allowed?
    //
    allowRender()
    {
        return (this.fontData.fontString && this.vbo);
    }
    
    //
    //  DESC: Is this a font sprite
    //
    isFontSprite()
    {
        return true;
    }
    
    //
    //  DESC: Load the font properties from XML node
    //
    loadFontPropFromNode( node )
    {
        if( this.fontData )
            this.fontData.loadFromNode( node );
    }
    
    //
    //  DESC: Set the font properties
    //
    setFontProperties( fontName, hAlign = null, vAlign = null, kerning = null, sKern = null, lineWrapWidth = null, lineWrapHeight = null )
    {
        if( this.fontData )
        {
            this.fontData.fontProp.fontName = fontName;
            
            if( hAlign )
                this.fontData.fontProp.hAlign = hAlign;
            
            if( vAlign )
                this.fontData.fontProp.hAlign = vAlign;
            
            if( kerning )
                this.fontData.fontProp.kerning = kerning;
            
            if( sKern )
                this.fontData.fontProp.spaceCharKerning = sKern;
            
            if( lineWrapWidth )
                this.fontData.fontProp.lineWrapWidth = lineWrapWidth;
            
            if( lineWrapHeight )
                this.fontData.fontProp.lineWrapHeight = lineWrapHeight;
        }
    }
    
    //
    //  DESC: Create the font string from data
    //
    createFontStringFromData()
    {
        if( (this.fontData !== null) && this.fontData.fontString )
            this.createFontString( this.fontData.fontString );
    }

    //
    //  DESC: Create the font string
    //
    createFontString( fontString )
    {
        let gl = _system_device__WEBPACK_IMPORTED_MODULE_7__.device.gl;
        
        // Qualify if we want to build the font string
        if( (this.fontData !== null) &&
            (fontString !== '') &&
            (this.fontData.fontProp.fontName !== null) &&
            ((fontString !== this.fontData.fontString) || (this.vbo === null)) )
        {
            this.fontData.fontStrSize.reset();
            let lastCharDif = 0;

            let font = _managers_fontmanager__WEBPACK_IMPORTED_MODULE_4__.fontManager.getFont( this.fontData.fontProp.fontName );

            this.texture = font.texture;

            this.fontData.fontString = fontString;

            // count up the number of space characters
            let spaceCharCount = _utilities_genfunc__WEBPACK_IMPORTED_MODULE_9__.countStrOccurrence( this.fontData.fontString, ' ' );

            // count up the number of bar | characters
            let barCharCount = _utilities_genfunc__WEBPACK_IMPORTED_MODULE_9__.countStrOccurrence( this.fontData.fontString, '|' );

            // Size of the allocation
            const charCount = this.fontData.fontString.length - spaceCharCount - barCharCount;
            this.iboCount = charCount * 6;
            
            // Set a flag to indicate if the IBO should be built
            const BUILD_FONT_IBO = (this.iboCount > _managers_vertexbuffermanager__WEBPACK_IMPORTED_MODULE_3__.vertexBufferManager.currentMaxFontIndices);
            
            // Allocate the vert array
            let vertAry = new Array(charCount * 4 * 5);

            // Create a buffer to hold the indicies
            let indexAry = null;
            
            // Should we build or rebuild the font IBO
            if( BUILD_FONT_IBO )
                indexAry = new Array(this.iboCount);

            let xOffset = 0;
            let width = 0;
            let lineHeightOffset = 0;
            let lineHeightWrap = font.lineHeight + font.vertPadding + this.fontData.fontProp.lineWrapHeight;
            let initialHeightOffset = font.baselineOffset + font.vertPadding;
            let lineSpace = font.lineHeight - font.baselineOffset;

            let counter = 0;
            let vertAryIndex = 0;
            let lineCount = 0;

            // Get the size of the texture
            let textureSize = font.texture.size;

            // Handle the horizontal alignment
            let lineWidthOffsetAry = this.calcLineWidthOffset( font, this.fontData.fontString );

            // Set the initial line offset
            xOffset = lineWidthOffsetAry[lineCount++];

            // Handle the vertical alighnmenrt
            if( this.fontData.fontProp.vAlign === _common_defs__WEBPACK_IMPORTED_MODULE_8__.EVA_VERT_TOP )
                lineHeightOffset = -initialHeightOffset;

            if( this.fontData.fontProp.vAlign === _common_defs__WEBPACK_IMPORTED_MODULE_8__.EVA_VERT_CENTER )
            {
                lineHeightOffset = -(initialHeightOffset - ((font.baselineOffset-lineSpace) / 2) - font.vertPadding);

                if( lineWidthOffsetAry.length > 1 )
                    lineHeightOffset = ((lineHeightWrap * lineWidthOffsetAry.length) / 2) - font.baselineOffset;
            }

            else if( this.fontData.fontProp.vAlign === _common_defs__WEBPACK_IMPORTED_MODULE_8__.EVA_VERT_BOTTOM )
            {
                lineHeightOffset = -(initialHeightOffset - font.baselineOffset - font.vertPadding);

                if( lineWidthOffsetAry.length > 1 )
                    lineHeightOffset += (lineHeightWrap * (lineWidthOffsetAry.length-1));
            }

            // Remove any fractional component of the line height offset
            lineHeightOffset = Math.trunc(lineHeightOffset);

            // Setup each character in the vertex buffer
            for( let i = 0; i < this.fontData.fontString.length; ++i )
            {
                let id = this.fontData.fontString.charCodeAt(i);

                // Line wrap if '|' character was used
                if( id === _common_defs__WEBPACK_IMPORTED_MODULE_8__.CHAR_CODE_PIPE )
                {
                    xOffset = lineWidthOffsetAry[lineCount];
                    width = 0;

                    lineHeightOffset += -lineHeightWrap;
                    ++lineCount;
                }
                else
                {
                    // See if we can find the character
                    let charData = font.getCharData(id);

                    // Ignore space characters
                    if( id != _common_defs__WEBPACK_IMPORTED_MODULE_8__.CHAR_CODE_SPACE )
                    {
                        let rect = charData.rect;

                        let yOffset = (font.lineHeight - rect.y2 - charData.offset.h) + lineHeightOffset;

                        // Check if the width or height is odd. If so, we offset
                        // by 0.5 for proper orthographic rendering
                        // speed enhancement - if( Math.trunc(rect.x2) % 2 != 0 )
                        let additionalOffsetX = 0;
                        if( Math.trunc(rect.x2) & 1 !== 0 )
                            additionalOffsetX = 0.5;

                        let additionalOffsetY = 0;
                        if( Math.trunc(rect.y2) & 1 !== 0 )
                            additionalOffsetY = 0.5;
                        
                        vertAry[vertAryIndex]   = xOffset + charData.offset.w + additionalOffsetX;
                        vertAry[vertAryIndex+1] = yOffset + additionalOffsetY;
                        vertAry[vertAryIndex+2] = 0;
                        vertAry[vertAryIndex+3] = rect.x1 / textureSize.w;
                        vertAry[vertAryIndex+4] = (rect.y1 + rect.y2) / textureSize.h;

                        // Calculate the second vertex of the first face
                        vertAry[vertAryIndex+5] = xOffset + rect.x2 + charData.offset.w + additionalOffsetX;
                        vertAry[vertAryIndex+6] = yOffset + rect.y2 + additionalOffsetY;
                        vertAry[vertAryIndex+7] = 0;
                        vertAry[vertAryIndex+8] = (rect.x1 + rect.x2) / textureSize.w;
                        vertAry[vertAryIndex+9] = rect.y1 / textureSize.h;

                        // Calculate the third vertex of the first face
                        vertAry[vertAryIndex+10] = vertAry[vertAryIndex];
                        vertAry[vertAryIndex+11] = vertAry[vertAryIndex+6];
                        vertAry[vertAryIndex+12] = 0;
                        vertAry[vertAryIndex+13] = vertAry[vertAryIndex+3];
                        vertAry[vertAryIndex+14] = vertAry[vertAryIndex+9];

                        // Calculate the second vertex of the second face
                        vertAry[vertAryIndex+15] = vertAry[vertAryIndex+5];
                        vertAry[vertAryIndex+16] = vertAry[vertAryIndex+1];
                        vertAry[vertAryIndex+17] = 0;
                        vertAry[vertAryIndex+18] = vertAry[vertAryIndex+8];
                        vertAry[vertAryIndex+19] = vertAry[vertAryIndex+4];
                        
                        vertAryIndex += 20;

                        if( BUILD_FONT_IBO )
                        {
                            // Create the indicies into the VBO
                            let arrayIndex = counter * 6;
                            let vertIndex = counter * 4;

                            indexAry[arrayIndex]   = vertIndex;
                            indexAry[arrayIndex+1] = vertIndex+1;
                            indexAry[arrayIndex+2] = vertIndex+2;

                            indexAry[arrayIndex+3] = vertIndex;
                            indexAry[arrayIndex+4] = vertIndex+3;
                            indexAry[arrayIndex+5] = vertIndex+1;
                        }

                        ++counter;
                    }

                    // Inc the font position
                    let inc = charData.xAdvance + this.fontData.fontProp.kerning + font.horzPadding;

                    // Add in any additional spacing for the space character
                    if( id === _common_defs__WEBPACK_IMPORTED_MODULE_8__.CHAR_CODE_SPACE )
                        inc += this.fontData.fontProp.spaceCharKerning;

                    width += inc;
                    xOffset += inc;

                    // Get the longest width of this font string
                    if( this.fontData.fontStrSize.w < width )
                    {
                        this.fontData.fontStrSize.w = width;

                        // This is the space between this character and the next.
                        // Save this difference so that it can be subtracted at the end
                        lastCharDif = inc - charData.rect.x2;
                    }

                    // Wrap to another line
                    if( (id === _common_defs__WEBPACK_IMPORTED_MODULE_8__.CHAR_CODE_SPACE ) && (this.fontData.fontProp.lineWrapWidth > 0) )
                    {
                        let nextWord = 0;

                        // Get the length of the next word to see if if should wrap
                        for( let j = i+1; j < this.fontData.fontString.length; ++j )
                        {
                            id = this.fontData.fontString.charCodeAt(j);

                            if( id != _common_defs__WEBPACK_IMPORTED_MODULE_8__.CHAR_CODE_PIPE )
                            {
                                // See if we can find the character
                                let anotherCharData = font.getCharData(id);

                                // Break here when space is found
                                // Don't add the space to the size of the next word
                                if( id === _common_defs__WEBPACK_IMPORTED_MODULE_8__.CHAR_CODE_SPACE )
                                    break;

                                // Don't count the
                                nextWord += anotherCharData.xAdvance + this.fontData.fontProp.kerning + font.horzPadding;
                            }
                        }

                        if( width + nextWord >= this.fontData.fontProp.lineWrapWidth )
                        {
                            xOffset = lineWidthOffsetAry[lineCount++];
                            width = 0;

                            lineHeightOffset += -lineHeightWrap;
                        }
                    }
                }
            }

            // Subtract the extra space after the last character
            this.fontData.fontStrSize.w -= lastCharDif;
            this.fontData.fontStrSize.h = font.lineHeight;

            // Save the data
            // If one doesn't exist, create the VBO and IBO for this font
            if( this.vbo === null )
                this.vbo = gl.createBuffer();

            gl.bindBuffer( gl.ARRAY_BUFFER, this.vbo );
            gl.bufferData( gl.ARRAY_BUFFER, new Float32Array(vertAry), gl.STATIC_DRAW );
            gl.bindBuffer( gl.ARRAY_BUFFER, null );

            // All fonts share the same IBO because it's always the same and the only difference is it's length
            // This updates the current IBO if it exceeds the current max
            this.ibo = _managers_vertexbuffermanager__WEBPACK_IMPORTED_MODULE_3__.vertexBufferManager.createDynamicFontIBO( _managers_fontmanager__WEBPACK_IMPORTED_MODULE_4__.fontManager.groupName, 'dynamic_font_ibo', indexAry, this.iboCount );
        }
        else if( (this.fontData !== null) &&
                 (fontString !== '') &&
                 (fontString !== this.fontData.fontString) &&
                 (this.vbo !== null) )
        {
            this.fontData.fontString = '';
        }
    }

    //
    //  DESC: Add up all the character widths
    //
    calcLineWidthOffset( font, str )
    {
        let firstCharOffset = 0;
        let lastCharOffset = 0;
        let spaceWidth = 0;
        let width = 0;
        let counter = 0;
        let lineWidthOffsetAry = [];

        for( let i = 0; i < str.length; ++i )
        {
            let id = str.charCodeAt(i);

            // Line wrap if '|' character was used
            if( id === _common_defs__WEBPACK_IMPORTED_MODULE_8__.CHAR_CODE_PIPE )
            {
                // Add the line width to the vector based on horz alignment
                this.addLineWithToAry( font, lineWidthOffsetAry, this.fontData.fontProp.hAlign, width, firstCharOffset, lastCharOffset );

                counter = 0;
                width = 0;
            }
            else
            {
                // Get the next character
                let charData = font.getCharData( id );

                if(counter === 0)
                    firstCharOffset = charData.offset.w;

                spaceWidth = charData.xAdvance + this.fontData.fontProp.kerning + font.horzPadding;

                // Add in any additional spacing for the space character
                if( id === _common_defs__WEBPACK_IMPORTED_MODULE_8__.CHAR_CODE_SPACE )
                    spaceWidth += this.fontData.fontProp.spaceCharKerning;

                width += spaceWidth;

                if( id != _common_defs__WEBPACK_IMPORTED_MODULE_8__.CHAR_CODE_SPACE )
                    lastCharOffset = charData.offset.w;

                ++counter;
            }

            // Wrap to another line
            if( (id === _common_defs__WEBPACK_IMPORTED_MODULE_8__.CHAR_CODE_SPACE) && (this.fontData.fontProp.lineWrapWidth > 0) )
            {
                let nextWord = 0;

                // Get the length of the next word to see if if should wrap
                for( let j = i+1; j < str.length; ++j )
                {
                    id = str.charCodeAt(j);

                    if( id != _common_defs__WEBPACK_IMPORTED_MODULE_8__.CHAR_CODE_PIPE )
                    {
                        // See if we can find the character
                        let charData = font.getCharData(id);

                        // Break here when space is found
                        // Don't add the space to the size of the next word
                        if( id === _common_defs__WEBPACK_IMPORTED_MODULE_8__.CHAR_CODE_SPACE )
                            break;

                        // Don't count the
                        nextWord += charData.xAdvance + this.fontData.fontProp.kerning + font.horzPadding;
                    }
                }

                if( width + nextWord >= this.fontData.fontProp.lineWrapWidth )
                {
                    // Add the line width to the vector based on horz alignment
                    this.addLineWithToAry( font, lineWidthOffsetAry, this.fontData.fontProp.hAlign, width-spaceWidth, firstCharOffset, lastCharOffset );

                    counter = 0;
                    width = 0;
                }
            }
        }

        // Add the line width to the vector based on horz alignment
        this.addLineWithToAry( font, lineWidthOffsetAry, this.fontData.fontProp.hAlign, width, firstCharOffset, lastCharOffset );

        return lineWidthOffsetAry;
    }

    //
    //  DESC: Add the line width to the array based on horz alignment
    //
    addLineWithToAry( font, lineWidthOffsetAry, hAlign, width, firstCharOffset, lastCharOffset )
    {
        if( hAlign === _common_defs__WEBPACK_IMPORTED_MODULE_8__.EHA_HORZ_LEFT )
            lineWidthOffsetAry.push(-(firstCharOffset + font.horzPadding));

        else if( hAlign === _common_defs__WEBPACK_IMPORTED_MODULE_8__.EHA_HORZ_CENTER )
            lineWidthOffsetAry.push(-((width - font.horzPadding) / 2));

        else if( hAlign === _common_defs__WEBPACK_IMPORTED_MODULE_8__.EHA_HORZ_RIGHT )
            lineWidthOffsetAry.push(-(width - lastCharOffset - font.horzPadding));

        // Remove any fractional component of the last index
        lineWidthOffsetAry[lineWidthOffsetAry.length-1] = Math.trunc(lineWidthOffsetAry[lineWidthOffsetAry.length-1]);
    }
    
    //
    //  DESC: Get/Set the displayed font string
    //
    getFontString()
    {
        if( this.fontData === null )
            throw new Error( `Can't ask for the font string from a sprite that is not a sprite font!` );

        return this.fontData.fontString;
    }

    setFontString( fontString )
    {
        if( this.fontData === null )
            throw new Error( `Can't set a font string for a sprite that is not a sprite font!` );
        
        this.fontData.fontString = fontString;
    }
    
    //
    //  DESC: Get the font size
    //
    getFontSize()
    {
        if( !this.fontData )
            throw new Error( `Can't ask for the font size from a sprite that is not defined!` );

        return this.fontData.fontStrSize;
    }
}


/***/ }),
/* 47 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "fontManager": () => (/* binding */ fontManager)
/* harmony export */ });
/* harmony import */ var _2d_font__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(48);
/* harmony import */ var _managers_texturemanager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/* harmony import */ var _utilities_genfunc__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(26);

//
//  FILE NAME: fontmanager.js
//  DESC:      font manager class singleton
//






class FontManager
{
    constructor()
    {
        // map list of fonts
        this.fontMap = new Map;

        // Group name
        this.group = '(font)';
    }
    
    //
    //  DESC: Load the fonts from xml node
    //
    loadFromObj( obj )
    {
        let promiseAry = [];

        for( const each of obj )
        {
            // Sanity check to make sure the font has not already been added in
            if( this.fontMap.has( each.name ) )
                throw new Error( `Font name has already been loaded (${each.name}).` );

            // Sanity check to make sure the font has not already been added in
            if( this.fontMap.has( each.name ) )
                throw new Error( `Font name has already been loaded (${each.name}).` );
            
            // Add the font to our list
            this.fontMap.set( each.name, new _2d_font__WEBPACK_IMPORTED_MODULE_0__.Font );

            // Load the texture file
            let textureFilePath = each.file + '.png'
            promiseAry.push( _utilities_genfunc__WEBPACK_IMPORTED_MODULE_2__.downloadFile( 'img', textureFilePath )
                    .then(( image ) => _managers_texturemanager__WEBPACK_IMPORTED_MODULE_1__.textureManager.load( this.group, each.name, image ))
                    .catch(( error ) => { console.error(error.stack); throw error; }) );

            // Load the xml file describing the font characteristics
            let fontFilePath = each.file + '.fnt'
            promiseAry.push( _utilities_genfunc__WEBPACK_IMPORTED_MODULE_2__.downloadFile( 'xml', fontFilePath )
                    .then(( fontXmlNode ) => this.loadFont( each.name, fontXmlNode ))
                    .catch(( error ) => { console.error(error.stack); throw error; }) );
        }

        return Promise.all( promiseAry )
            .then(() => this.setFontTexture());
    }

    //
    //  DESC: Load the fonts from xml node
    //
    loadFromNode( xmlNode )
    {
        let promiseAry = [];

        if( xmlNode )
        {
            // Get the list of font info
            let fontNode = xmlNode.getElementsByTagName('font');

            for( let i = 0; i < fontNode.length; ++i )
            {
                // Get the name of the font
                let name = fontNode[i].getAttribute( 'name' );

                // Sanity check to make sure the font has not already been added in
                if( this.fontMap.has( name ) )
                    throw new Error( `Font name has already been loaded (${name}).` );

                // Add the font to our list
                this.fontMap.set( name, new _2d_font__WEBPACK_IMPORTED_MODULE_0__.Font );

                let filePath = fontNode[i].getAttribute( 'file' );

                // Load the texture file
                let textureFilePath = filePath + '.png'
                promiseAry.push( _utilities_genfunc__WEBPACK_IMPORTED_MODULE_2__.downloadFile( 'img', textureFilePath )
                        .then(( image ) => _managers_texturemanager__WEBPACK_IMPORTED_MODULE_1__.textureManager.load( this.group, name, image ))
                        .catch(( error ) => { console.error(error.stack); throw error; }) );

                // Load the xml file describing the font characteristics
                let fontFilePath = filePath + '.fnt'
                promiseAry.push( _utilities_genfunc__WEBPACK_IMPORTED_MODULE_2__.downloadFile( 'xml', fontFilePath )
                        .then(( fontXmlNode ) => this.loadFont( name, fontXmlNode ))
                        .catch(( error ) => { console.error(error.stack); throw error; }) );
            }
        }

        return Promise.all( promiseAry )
                    .then(() => this.setFontTexture());
    }
    
    //
    //  DESC: Load the font
    //
    loadFont( name, xmlNode )
    {
        let font = this.fontMap.get( name );
        if( font === undefined )
            throw new Error( `Font name has not been added to the map (${name}).` );
        
        font.loadFromNode( this.group, name, xmlNode );
    }

    //
    //  DESC: Set the textures to the font object
    //
    setFontTexture()
    {
        for( let [ key, font ] of this.fontMap.entries() )
            font.texture = _managers_texturemanager__WEBPACK_IMPORTED_MODULE_1__.textureManager.get( this.group, key );
    }
    
    //
    //  DESC: Get the font
    //
    getFont( name )
    {
        let font = this.fontMap.get( name );
        if( font === undefined )
            throw new Error( `Font name can't be found (${name}).` );

        return font;
    }
    
    //
    //  DESC: Get the font
    //
    isFont( name )
    {
        let font = this.fontMap.get( name );
        if( font === undefined )
            throw new Error( `Font name can't be found (${name}).` );
    }
}

var fontManager = new FontManager;


/***/ }),
/* 48 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CharData": () => (/* binding */ CharData),
/* harmony export */   "Font": () => (/* binding */ Font)
/* harmony export */ });
/* harmony import */ var _common_size__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
/* harmony import */ var _common_rect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(21);

// 
//  FILE NAME:  font.js
//  DESC:       font class
//






class CharData
{
    constructor()
    {
        // Character offsets
        this.offset = new _common_size__WEBPACK_IMPORTED_MODULE_0__.Size;

        // Character rect
        this.rect = new _common_rect__WEBPACK_IMPORTED_MODULE_1__.Rect;

        // Amount to advance
        this.xAdvance = 0;
    }
}

class Font
{
    constructor()
    {
        // map list of character data
        this.charDataMap = new Map;

        // Line height
        this.lineHeight = 0;

        // base line offset
        this.baselineOffset = 0;

        // Horizontal padding
        this.horzPadding = 0;

        // Vertival padding
        this.vertPadding = 0;

        // The texture in set from font manager
        this.texture = null;
    }
    
    // 
    //  DESC: Load from XML node
    //
    loadFromNode( group, name, xmlNode )
    {
        // Get the padding
        let padding = xmlNode.getElementsByTagName('info')[0].getAttribute('padding');
        this.horzPadding = Number(padding.substr(6,1));
        this.vertPadding = Number(padding.substr(0,1));

        // Get the common font info
        let commonNode = xmlNode.getElementsByTagName( 'common' );

        // get the line height
        this.lineHeight = Number(commonNode[0].getAttribute('lineHeight'));

        // get the baseline offset
        this.baselineOffset = Number(commonNode[0].getAttribute('base'));

        // Get the list of character info
        let charNode = xmlNode.getElementsByTagName( 'char' );

        // Load in the individual character data
        for( let i = 0; i < charNode.length; ++i )
        {
            let charData = new CharData;

            // Get the offset of the character
            charData.offset.w = Number(charNode[i].getAttribute( 'xoffset' ));
            charData.offset.h = Number(charNode[i].getAttribute( 'yoffset' ));

            // Get the x advance of the character
            charData.xAdvance = Number(charNode[i].getAttribute( 'xadvance' ));

            // Get the rect of the character
            charData.rect.x1 = Number(charNode[i].getAttribute( 'x' ));
            charData.rect.y1 = Number(charNode[i].getAttribute( 'y' ));
            charData.rect.x2 = Number(charNode[i].getAttribute( 'width' ));
            charData.rect.y2 = Number(charNode[i].getAttribute( 'height' ));

            // Get the character ID which is the ascii value of the character.
            let id = Number(charNode[i].getAttribute( 'id' ));

            // Add the character to the map
            this.charDataMap.set( id, charData );
        }
    }
    
    // 
    //  DESC: Get the data for this character
    //
    getCharData( id )
    {
        // See if this character is part of the map
        let charData = this.charDataMap.get( id );

        if( charData === undefined )
            throw new Error( `Font character ID can't be found (${id}).` );

        return charData;
    }
}


/***/ }),
/* 49 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FontData": () => (/* binding */ FontData)
/* harmony export */ });
/* harmony import */ var _fontproperties__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50);
/* harmony import */ var _size__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4);

// 
//  FILE NAME:  fontdata.js
//  DESC:       font data class
//





class FontData
{
    constructor()
    {
        // Displayed font string
        this.fontString = '';

        // Font members
        this.fontProp = new _fontproperties__WEBPACK_IMPORTED_MODULE_0__.FontProperties;

        // Font string size
        // Not usefull for multiline strings
        this.fontStrSize = new _size__WEBPACK_IMPORTED_MODULE_1__.Size;
    }
    
    // 
    //  Copy the data
    //
    copy( obj )
    {
        this.fontString = obj.fontString;
        this.fontProp.copy( obj.fontProp );
        this.fontStrSize.copy( obj.fontStrSize );
    }
    
    //
    //  DESC: Load the font properties from XML node
    //
    loadFromNode( node )
    {
        let fontNode = node.getElementsByTagName( 'font' );
        if( fontNode.length )
        {
            // See if a font string has been defined
            let attr = fontNode[0].getAttribute( 'fontString' );
            if( attr )
                this.fontString = attr;

            this.fontProp.loadFromNode( fontNode[0] );
        }
    }
}


/***/ }),
/* 50 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FontProperties": () => (/* binding */ FontProperties)
/* harmony export */ });
/* harmony import */ var _managers_fontmanager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(47);
/* harmony import */ var _utilities_xmlparsehelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(19);
/* harmony import */ var _defs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6);

// 
//  FILE NAME: fontproperties.js
//  DESC:      font properties class
//







class FontProperties
{
    constructor( fontName = null, hAlign = _defs__WEBPACK_IMPORTED_MODULE_2__.EHA_HORZ_CENTER, vAlign = _defs__WEBPACK_IMPORTED_MODULE_2__.EVA_VERT_CENTER, kerning = 0, spaceCharKerning = 0, lineWrapWidth = -1, lineWrapHeight = 0 )
    {
        // font to use
        this.fontName = fontName;

        // horzontal alignment
        this.hAlign = hAlign;

        // vertical alignment
        this.vAlign = vAlign;

        // distance between each character
        this.kerning = kerning;

        // special kerning just for the space character
        this.spaceCharKerning = spaceCharKerning;

        // width of line to force wrap
        this.lineWrapWidth = lineWrapWidth;

        // add spacing to the lines
        this.lineWrapHeight = lineWrapHeight;
        
        // Throws an error if font is not loaded
        if( this.fontName )
            _managers_fontmanager__WEBPACK_IMPORTED_MODULE_0__.fontManager.isFont( this.fontName );
    }
    
    // 
    //  Copy the data
    //
    copy( obj )
    {
        this.fontName = obj.fontName;
        this.hAlign = obj.hAlign;
        this.vAlign = obj.vAlign;
        this.kerning = obj.kerning;
        this.spaceCharKerning = obj.spaceCharKerning;
        this.lineWrapWidth = obj.lineWrapWidth;
        this.lineWrapHeight = obj.lineWrapHeight;
        
        // Throws an error if font is not loaded
        _managers_fontmanager__WEBPACK_IMPORTED_MODULE_0__.fontManager.isFont( this.fontName );
    }
    
    //
    //  DESC: Load the font properties from XML node
    //
    loadFromNode( node )
    {
        // Get the must have font name
        let attr = node.getAttribute( 'fontName' );
        if( attr )
            this.fontName = attr;
        
        // Throws an error if font is not loaded
        _managers_fontmanager__WEBPACK_IMPORTED_MODULE_0__.fontManager.isFont( this.fontName );

        // Get the attributes node
        let attrNode = node.getElementsByTagName( 'attributes' );
        if( attrNode.length )
        {
            attr = attrNode[0].getAttribute( 'kerning' );
            if( attr )
                this.kerning = Number(attr);

            attr = attrNode[0].getAttribute( 'spaceCharKerning' );
            if( attr )
                this.spaceCharKerning = Number(attr);

            attr = attrNode[0].getAttribute( 'lineWrapWidth' );
            if( attr )
                this.lineWrapWidth = Number(attr);

            attr = attrNode[0].getAttribute( 'lineWrapHeight' );
            if( attr )
                this.lineWrapHeight = Number(attr);
        }

        // Get the alignment node
        let alignmentNode = node.getElementsByTagName( 'alignment' );
        if( alignmentNode.length )
        {
            // Set the default alignment
            this.hAlign = _utilities_xmlparsehelper__WEBPACK_IMPORTED_MODULE_1__.loadHorzAlignment( alignmentNode[0], _defs__WEBPACK_IMPORTED_MODULE_2__.EHA_HORZ_CENTER );
            this.vAlign = _utilities_xmlparsehelper__WEBPACK_IMPORTED_MODULE_1__.loadVertAlignment( alignmentNode[0], _defs__WEBPACK_IMPORTED_MODULE_2__.EVA_VERT_CENTER );
        }
    }
}



/***/ }),
/* 51 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VisualComponent3D": () => (/* binding */ VisualComponent3D)
/* harmony export */ });
/* harmony import */ var _common_ivisualcomponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(39);
/* harmony import */ var _managers_vertexbuffermanager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(42);
/* harmony import */ var _managers_shadermanager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(40);
/* harmony import */ var _managers_texturemanager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7);
/* harmony import */ var _utilities_matrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(12);
/* harmony import */ var _common_color__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(20);
/* harmony import */ var _system_device__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(9);

// 
//  FILE NAME:  visualcomponent3d.js
//  DESC:       Class for handling the visual part of the sprite
//











// Global final matrix to be reused by every render call so that an object specific
// one doesn't have to be created each time a render call is made or a perminate one
// allocated and heald within each class
var gFinalMatrix = new _utilities_matrix__WEBPACK_IMPORTED_MODULE_4__.Matrix;

class VisualComponent3D extends _common_ivisualcomponent__WEBPACK_IMPORTED_MODULE_0__.ivisualComponent
{
    constructor( visualData )
    {
        super();
        
        this.visualData = visualData;
        this.shaderData = null;
        this.vertexLocation = null;
        this.normalLocation = null;
        this.uvLocation = null;
        this.text0Location = null;
        this.colorLocation = null;
        this.matrixLocation = null;
        this.normalMatrixLocation = null;
        this.VERTEX_BUF_SIZE = 24;
        
        this.color = new _common_color__WEBPACK_IMPORTED_MODULE_5__.Color;
        
        if( visualData.isActive() )
        {
            this.meshAry = visualData.meshGrp.meshAry;
            this.shaderData = _managers_shadermanager__WEBPACK_IMPORTED_MODULE_2__.shaderManager.getShaderData( visualData.shaderID );
            
            // Common shader members
            this.vertexLocation = this.shaderData.getLocation( 'in_position' );
            this.normalLocation = this.shaderData.getLocation( 'in_normal' );
            this.matrixLocation = this.shaderData.getLocation( 'cameraViewProjMatrix' );
            this.normalMatrixLocation = this.shaderData.getLocation( 'normalMatrix' );
            this.colorLocation = this.shaderData.getLocation( 'color' );
            
            if( this.meshAry[0].textureAry.length )
            {
                this.VERTEX_BUF_SIZE = 32;
                this.uvLocation = this.shaderData.getLocation( 'in_uv' );
                this.text0Location = this.shaderData.getLocation( 'text0' );
            }
            
            this.color.copy( this.visualData.color );
        }
    }
    
    //
    //  DESC: do the render
    //
    render( object, camera )
    {
        let gl = _system_device__WEBPACK_IMPORTED_MODULE_6__.device.gl;
        
        for( let i = 0; i < this.meshAry.length; ++i )
        {
            // Increment our stat counter to keep track of what is going on.
            //CStatCounter::Instance().IncDisplayCounter();

            // Bind the VBO and IBO. NOTE: One singlton needs to manage the vertex bindings
            _managers_vertexbuffermanager__WEBPACK_IMPORTED_MODULE_1__.vertexBufferManager.bind( this.meshAry[i].vbo, this.meshAry[i].ibo );

            // Bind the shader.
            _managers_shadermanager__WEBPACK_IMPORTED_MODULE_2__.shaderManager.bind( this.shaderData );

            // Setup the vertex attribute shader data
            gl.vertexAttribPointer( this.vertexLocation, 3, gl.FLOAT, false, this.VERTEX_BUF_SIZE, 0 );

            // Setup the normal attribute shade data
            gl.vertexAttribPointer( this.normalLocation, 3, gl.FLOAT, false, this.VERTEX_BUF_SIZE, 12 );

            // Enable the UV attribute shade data
            if( this.uvLocation )
            {
                // Bind the texture
                for( let j = 0; j < this.meshAry[i].textureAry.length; ++j )
                {
                    _managers_texturemanager__WEBPACK_IMPORTED_MODULE_3__.textureManager.bind( this.meshAry[i].textureAry[j].id );
                    gl.uniform1i( this.text0Location, 0);// future implementation - this.meshAry[i].textureAry[j].type ); // 0 = TEXTURE0
                }

                // Setup the uv attribute shade data
                gl.vertexAttribPointer( this.uvLocation, 2, gl.FLOAT, false, this.VERTEX_BUF_SIZE, 24 );
            }

            // Send the color to the shader
            gl.uniform4fv( this.colorLocation, this.color.data );

            gFinalMatrix.initilizeMatrix();
            gFinalMatrix.mergeMatrix( object.matrix.matrix );
            gFinalMatrix.mergeMatrix( camera.finalMatrix.matrix );
            gl.uniformMatrix4fv( this.matrixLocation, false, gFinalMatrix.matrix );
            
            gFinalMatrix.initilizeMatrix();
            gFinalMatrix.mergeMatrix( object.rotMatrix.matrix );
            gFinalMatrix.mergeMatrix( camera.rotMatrix.matrix );
            gl.uniformMatrix4fv( this.normalMatrixLocation, false, gFinalMatrix.matrix );

            // Render it
            gl.drawElements( gl.TRIANGLES, this.meshAry[i].iboCount, gl.UNSIGNED_SHORT, 0);
        }
    }
}


/***/ }),
/* 52 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NullVisualComponent": () => (/* binding */ NullVisualComponent)
/* harmony export */ });
/* harmony import */ var _common_ivisualcomponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(39);

// 
//  FILE NAME:  visualcomponentquad.js
//  DESC:       Class for handling the visual part of the sprite
//





class NullVisualComponent extends _common_ivisualcomponent__WEBPACK_IMPORTED_MODULE_0__.ivisualComponent
{
    constructor()
    {
        super();
    }

    //
    //  DESC: do the render
    //
    render( /*object, camera*/ )
    {
    }
    
    //
    //  DESC: Is rendering allowed?
    //
    allowRender()
    {
        return false;
    }
    
    //
    //  DESC: Get the frame count
    //
    getFrameCount()
    {
        return 0;
    }
}


/***/ }),
/* 53 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PhysicsComponent2D": () => (/* binding */ PhysicsComponent2D)
/* harmony export */ });
/* harmony import */ var _physicsworldmanager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(54);
/* harmony import */ var _common_size__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4);
/* harmony import */ var planck_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(57);

// 
//  FILE NAME: physicscomponent2d.js
//  DESC:      Class for handling the physics part of the sprite.
//







class PhysicsComponent2D
{
    constructor( physicsData )
    {
        // Parent sprite
        this.sprite = null;
                
        // Body type
        this.bodyType = null;

        // The physics body the sprite belongs to
        this.body = null;

        // Pixels to meters conversion
        this.pixelsToMeters = 0;
        this.metersToPixels = 0;

        // Pointer to the world
        this.world = null;
        
        if( physicsData.isActive() )
        {
            this.world = _physicsworldmanager__WEBPACK_IMPORTED_MODULE_0__.physicsWorldManager.getWorld( physicsData.world );

            // MAke sure the world has been loaded
            if( this.world.pixelsPerMeter == 0 )
                throw new Error( `Physics world not loaded (${physicsData.world})!` );

            // Re-init the constants to the values needed
            this.metersToPixels = this.world.pixelsPerMeter;
            this.pixelsToMeters = 1.0 / this.metersToPixels;
        }
    }
    
    // 
    //  DESC: Init the physics by creating the body and fixture
    //  NOTE: Function must be called externally at the right time
    //        when the sprite has been setup with it's initial offsets
    //
    init( sprite )
    {
        if( this.world !== null )
        {
            this.sprite = sprite;
            this.createBody();
            this.createFixture();
        }
    }
    
    // 
    //  DESC: Create the body
    //
    createBody()
    {
        if( !this.body )
        {
            let physicsData = this.sprite.objData.physicsData;
            let worldDef = {
                type : physicsData.bodyType,
                position : planck_js__WEBPACK_IMPORTED_MODULE_2__.Vec2( this.sprite.pos.x * this.pixelsToMeters, -(this.sprite.pos.y * this.pixelsToMeters) ),
                angle : -this.sprite.rot.z,

                linearVelocity : planck_js__WEBPACK_IMPORTED_MODULE_2__.Vec2.zero(),
                angularVelocity : 0.0,

                linearDamping : physicsData.linearDamping,
                angularDamping : physicsData.angularDamping,

                fixedRotation : physicsData.fixedRotation,
                bullet : false,
                gravityScale : 1.0,

                allowSleep : true,
                awake : true,
                active : true,

                userData : this.sprite };

            // Create the body
            this.body = this.world.createBody( worldDef );
        }
    }

    // 
    //  DESC: Create the fixture
    //
    createFixture()
    {
        let fixtureAry = this.sprite.objData.physicsData.fixtureAry;

        for( let i = 0; i < fixtureAry.length; ++i )
        {
            // Create the fixture
            if( fixtureAry[i].shape === planck_js__WEBPACK_IMPORTED_MODULE_2__.Circle.TYPE )
                this.createCircularShapeFixture( fixtureAry[i] );

            else if( fixtureAry[i].shape === planck_js__WEBPACK_IMPORTED_MODULE_2__.Edge.TYPE )
                this.createEdgeShapeFixture( fixtureAry[i] );

            else if( fixtureAry[i].shape === planck_js__WEBPACK_IMPORTED_MODULE_2__.Polygon.TYPE )
                this.createPolygonShapeFixture( fixtureAry[i] );

            else if( fixtureAry[i].shape === planck_js__WEBPACK_IMPORTED_MODULE_2__.Chain.TYPE )
                this.createChainShapeFixture( fixtureAry[i] );
        }
    }
    
    // 
    //  DESC: Create the circular shape fixture
    //
    getFixtureDef( fixture )
    {
        let fixtureDef = {
            userData : this.sprite,
            friction : fixture.friction,
            restitution : fixture.restitution,
            density : fixture.density,
            isSensor : fixture.sensor,

            filterGroupIndex : 0,
            filterCategoryBits : 0x0001,
            filterMaskBits : 0xFFFF };
        
        return fixtureDef;
    }
    
    // 
    //  DESC: Create the circular shape fixture
    //
    createCircularShapeFixture( fixture )
    {
        this.body.createFixture(
            planck_js__WEBPACK_IMPORTED_MODULE_2__.Circle( (fixture.radius * this.sprite.scale.x) * this.pixelsToMeters ),
            this.getFixtureDef( fixture ) );
    }

    // 
    //  DESC: Create the edge shape fixture
    //  NOTE: An edge is a line segment of two points
    //        This is no different then making a polygon from points
    //
    createEdgeShapeFixture( fixture )
    {
        // Do a sanity check because we need two points to define an edge
        if( fixture.vertAry.length !== 2 )
            throw new Error( `Physics object has incorrect number of points defined (${fixture.vertAry.length})!` );

        // Apply scale to the size and divide by 2
        let size = new _common_size__WEBPACK_IMPORTED_MODULE_1__.Size(
            this.sprite.objData.size.w * this.sprite.scale.x * 0.5,
            this.sprite.objData.size.h * this.sprite.scale.y * 0.5 );

        // Convert the points to world location in meters
        let Vec2Ary = [];
        this.convertPoints( Vec2Ary, fixture, size, this.sprite.scale );

        this.body.createFixture(
            planck_js__WEBPACK_IMPORTED_MODULE_2__.Edge( Vec2Ary[0], Vec2Ary[1] ),
            this.getFixtureDef( fixture ) );
    }

    // 
    //  DESC: Create the polygon shape fixture
    //
    createPolygonShapeFixture( fixture )
    {
        let Vec2Ary = [];

        // Apply scale to the size and divide by 2
        let size = new _common_size__WEBPACK_IMPORTED_MODULE_1__.Size(
            this.sprite.objData.size.w * this.sprite.scale.x * 0.5,
            this.sprite.objData.size.h * this.sprite.scale.y * 0.5 );

        // Is this polygon shape defined by a vector of points?
        if( fixture.vertAry.length )
        {
            // Convert the points to world location in meters
            this.convertPoints( Vec2Ary, fixture, size, this.sprite.scale );
        }
        
        // If vector points are not supplied, build a square based on the object size
        else
        {
            // Bottom and left mod have their signs flipped so that a positive mod always means
            // expansion of the side, and a negative mod always means a contraction of the side
            let topMod = fixture.topMod * this.sprite.scale.y;
            let bottomMod = -fixture.bottomMod * this.sprite.scale.y;
            let leftMod = -fixture.leftMod * this.sprite.scale.x;
            let rightMod = fixture.rightMod * this.sprite.scale.x;

            // Convert to meters
            // Box2D polygons are defined using Counter Clockwise Winding (CCW)
            Vec2Ary.push(
                planck_js__WEBPACK_IMPORTED_MODULE_2__.Vec2(
                    (-(size.w + leftMod)) * this.pixelsToMeters,
                    (size.h + bottomMod) * this.pixelsToMeters ) );

            Vec2Ary.push(
                planck_js__WEBPACK_IMPORTED_MODULE_2__.Vec2(
                    (-(size.w + leftMod)) * this.pixelsToMeters,
                    (-(size.h + topMod)) * this.pixelsToMeters ) );

            Vec2Ary.push(
                planck_js__WEBPACK_IMPORTED_MODULE_2__.Vec2(
                    (size.w + rightMod) * this.pixelsToMeters,
                    (-(size.h + topMod)) * this.pixelsToMeters ) );

            Vec2Ary.push(
                planck_js__WEBPACK_IMPORTED_MODULE_2__.Vec2(
                    (size.w + rightMod) * this.pixelsToMeters,
                    (size.h + bottomMod) * this.pixelsToMeters ) );
        }

        this.body.createFixture(
            planck_js__WEBPACK_IMPORTED_MODULE_2__.Polygon( Vec2Ary ),
            this.getFixtureDef( fixture ) );
    }

    // 
    //  DESC: Create the chain shape fixture
    //
    createChainShapeFixture( fixture )
    {
        // Do a sanity check because we need more then 1 point to define a chain
        if( fixture.vertAry.length > 1 )
            throw new Error( `Physics object has incorrect number of points defined (${fixture.vertAry.length})!` );
        
        // Apply scale to the size and divide by 2
        let size = new _common_size__WEBPACK_IMPORTED_MODULE_1__.Size(
            this.sprite.objData.size.w * this.sprite.scale.x * 0.5,
            this.sprite.objData.size.h * this.sprite.scale.y * 0.5 );

        // Convert the points to world location in meters
        let Vec2Ary = [];
        this.convertPoints( Vec2Ary, fixture, size, this.sprite.scale );

        this.body.createFixture(
            planck_js__WEBPACK_IMPORTED_MODULE_2__.Chain( Vec2Ary, fixture.chainLoop ),
            this.getFixtureDef( fixture ) );
    }

    // 
    //  DESC: Convert the points to world location in meters
    //
    convertPoints( polyPointAry, fixture, size, scale )
    {
        // Convert to meters and world coordinates
        // Box2D polygons are defined using Counter Clockwise Winding (CCW)
        for( let i = 0; i < fixture.vertAry.length; ++i )
        {
            polyPointAry.push(
                planck_js__WEBPACK_IMPORTED_MODULE_2__.Vec2( ((fixture.vertAry[i].x * scale.x) - size.w) * this.pixelsToMeters,
                             ((fixture.vertAry[i].y * scale.y) - size.h) * this.pixelsToMeters ) );
        }
    }

    // 
    //  DESC: Update the physics
    //
    update()
    {
        if( this.isActive() )
        {
            if( !this.body.isStatic() && this.body.isAwake() )
            {
                //CStatCounter::Instance().IncPhysicsObjectsCounter();
                
                this.applyTransforms();
            }
        }
    }
    
    // 
    //  DESC: Update the physics
    //
    applyTransforms()
    {
        let pos = this.body.getPosition();
        let angle = this.body.getAngle();
        this.sprite.setPosXYZ( pos.x * this.metersToPixels, -(pos.y * this.metersToPixels) );
        this.sprite.setRotXYZ( 0, 0, -angle, false );
    }
    
    // 
    //  DESC: Set the physics to be active
    //
    setActive( active )
    {
        if( this.body )
            this.body.setActive( active );
    }
    
    // 
    //  DESC: Is this component active?
    //
    isActive()
    {
        return (this.body && this.body.isActive());
    }

    // 
    //  DESC: Is this component awake?
    //
    isAwake()
    {
        return (this.body && !this.body.isStatic() && this.body.isAwake() );
    }

    // 
    //  DESC: Update the physics
    //
    destroyBody()
    {
        if( this.body !== null )
        {
            this.world.destroyBody( this.body );
            this.body = null;
        }
    }

    // 
    //  DESC: Set the physics position and rotation
    //
    setTransform( x, y, angle, resetVelocity = false )
    {
        if( this.body !== null )
        {
            this.body.setTransform( planck_js__WEBPACK_IMPORTED_MODULE_2__.Vec2( x * this.pixelsToMeters, -(y * this.pixelsToMeters) ), angle );

            if( resetVelocity )
            {
                this.body.setLinearVelocity( planck_js__WEBPACK_IMPORTED_MODULE_2__.Vec2.zero() );
                this.body.setAngularVelocity( 0 );
            }
            
            // If this body is staic, need to apply the transforms the the sprite position
            if( this.body.isStatic() )
                this.applyTransforms();
        }
    }

    // 
    //  DESC: Set the physics position and rotation
    //
    setPosition( x, y, resetVelocity = false )
    {
        if( this.body !== null )
        {
            this.body.setPosition( planck_js__WEBPACK_IMPORTED_MODULE_2__.Vec2( x * this.pixelsToMeters, -(y * this.pixelsToMeters) ) );

            if( resetVelocity )
            {
                this.body.setLinearVelocity( planck_js__WEBPACK_IMPORTED_MODULE_2__.Vec2.zero() );
                this.body.setAngularVelocity( 0 );
            }
            
            // If this body is staic, need to apply the transforms the the sprite position
            if( this.body.isStatic() )
                this.applyTransforms();
        }
    }
    
    // 
    //  DESC: Set the angular velocity
    //
    setAngularVelocity( value )
    {
        if( this.body !== null )
            this.body.setAngularVelocity( value );
    }
    
    // 
    //  DESC: Set the angular velocity
    //
    applyAngularImpulse( value, wake = false )
    {
        if( this.body !== null )
            this.body.applyAngularImpulse( value, wake );
    }
}


/***/ }),
/* 54 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "physicsWorldManager": () => (/* binding */ physicsWorldManager)
/* harmony export */ });
/* harmony import */ var _managers_managerbase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(25);
/* harmony import */ var _physicsworld2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(55);
/* harmony import */ var _physicsworld3d__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(110);
/* harmony import */ var _utilities_genfunc__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(26);

// 
//  FILE NAME: physicsworldmanager.js
//  DESC:      Physics manager class singleton
//








const LOAD_2D = 0;
const LOAD_3D = 1;

class PhysicsWorldManager extends _managers_managerbase__WEBPACK_IMPORTED_MODULE_0__.ManagerBase
{
    constructor()
    {
        super();
        
        this.worldMap = new Map;
    }
    
    //
    //  DESC: Load all XML's associated with this group
    //
    loadWorldGroup2D( group )
    {
        return this.loadWorldGroup( LOAD_2D, group );
    }
    
    loadWorldGroup3D( group )
    {
        return this.loadWorldGroup( LOAD_3D, group );
    }
    
    loadWorldGroup( loadType, group )
    {
        // Make sure the group we are looking for has been defined in the list table file
        let pathAry = this.listTableMap.get( group );
        if( pathAry !== undefined )
        {
            // Load the group data if it doesn't already exist
            if( this.worldMap.get( group ) === undefined )
            {
                // Create a new physics world inside of our map
                if( loadType === LOAD_2D )
                    this.worldMap.set( group, new _physicsworld2d__WEBPACK_IMPORTED_MODULE_1__.PhysicsWorld2D );
                else
                    this.worldMap.set( group, new _physicsworld3d__WEBPACK_IMPORTED_MODULE_2__.PhysicsWorld3D );

                // There will only be one xml per physics world
                let filePath = pathAry[0];

                return _utilities_genfunc__WEBPACK_IMPORTED_MODULE_3__.downloadFile( 'xml', filePath )
                        .then(( xmlNode ) => this.loadFromNode( group, xmlNode, filePath ))
                        .catch(( error ) => { console.error(error.stack); throw error; });
            }
            else
            {
                throw new Error( `Physics world group has alread been loaded (${group})!` );
            }
        }
        else
        {
            throw new Error( `Physics world list group name can't be found (${group})!` );
        }
    }
    
    //
    //  DESC: Load from an xml node
    //
    loadFromNode( group, xmlNode, filePath )
    {
        // Get the physics world
        let world = this.worldMap.get( group );
        if( world === undefined )
            throw new Error( `Physics World doesn't exist (${group}, ${filePath})!` );
        
        world.loadFromNode( xmlNode );
    }
    
    //
    //  DESC: Get the physics world
    //
    getWorld( group )
    {
        let world = this.worldMap.get( group );
        if( world === undefined )
            throw new Error( `Physics World doesn't exist (${group})!` );

        return world;
    }
    
    //
    //  DESC: Destroy the physics world
    //
    destroyWorld( group )
    {
        this.worldMap.delete( group );
    }
}

var physicsWorldManager = new PhysicsWorldManager;


/***/ }),
/* 55 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PhysicsWorld2D": () => (/* binding */ PhysicsWorld2D)
/* harmony export */ });
/* harmony import */ var _utilities_highresolutiontimer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(56);
/* harmony import */ var _utilities_genfunc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(26);
/* harmony import */ var planck_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(57);

// 
//  FILE NAME: physicsworld2d.js
//  DESC:      Wrapper class for Box2D's b2World
//







class PhysicsWorld2D
{
    constructor()
    {
        // Box2D world
        this.world = planck_js__WEBPACK_IMPORTED_MODULE_2__.World();
        
        // All bodies that are handled by this physics world
        this.bodyAry = [];

        // If we're actively running simulations
        this.active = false;

        // If we're going to start a step this frame
        this.beginStep = 0;

        // Timer to let us know when to do another step
        this.timer = 0;

        // The ammount of time to simulate in milliseconds
        this.stepTime = 0;

        // The ammount of time to simulate in Seconds
        this.stepTimeSec = 0;

        // The number of velocity and position steps to calculate
        this.velStepCount = 0;
        this.posStepCount = 0;

        // pixels per meter scaler
        this.pixelsPerMeter = 0;
    }
    
    //
    //  DESC: Load the physics world from XML node
    //
    loadFromNode( node )
    {
        // Get the world's settings, if any are set
        let settingsNode = node.getElementsByTagName( "settings" );
        if( settingsNode.length )
        {
            let attr = settingsNode[0].getAttribute( 'active' );
            if( attr )
                this.active = (attr === 'true');
        }

        // Get the world's gravity, if any are set
        let gravityNode = node.getElementsByTagName( "gravity" );
        if( gravityNode.length )
        {
            let gravity = planck_js__WEBPACK_IMPORTED_MODULE_2__.Vec2(
                Number( gravityNode[0].getAttribute( "x" ) ),
                Number( gravityNode[0].getAttribute( "y" ) ) );

            this.world.setGravity( gravity );
        }

        // Get the stepping which determins how accurate the physics are
        let steppingNode = node.getElementsByTagName( "stepping" );
        if( steppingNode.length )
        {
            this.velStepCount = Number( steppingNode[0].getAttribute( "velocity" ) );
            this.posStepCount = Number( steppingNode[0].getAttribute( "position" ) );

            let fps = Number( steppingNode[0].getAttribute( "fps" ) );

            // If the number is negative, get the current refresh rate
            /*if( fps < 0.0 )
            {
                SDL_DisplayMode dm;
                SDL_GetDesktopDisplayMode(0, &dm);

                if( dm.refresh_rate == 0 )
                    fps = 60.f;
                else
                    fps = dm.refresh_rate;
            }*/

            this.setFPS( fps );
        }

        // Get the conversion of pixels per meter because Box2D works in meters
        let conversionNode = node.getElementsByTagName( "conversion" );
        if( conversionNode.length )
            this.pixelsPerMeter = Number( conversionNode[0].getAttribute( "pixelsPerMeter" ) );
    }
    
    //
    //  DESC: Create a physics body
    //  NOTE: Function should only be called from physics component
    //
    createBody( def )
    {
        let body = this.world.createBody( def );

        if( body === null )
            throw new Error( `Error creating physics body!` );

        this.bodyAry.push( body );

        return body;
    }
    
    //
    //  DESC: Destroy a physics body
    //  NOTE: Function should only be called from physics component
    //
    destroyBody( body )
    {
        let index = this.bodyAry.indexOf( body );

        if( index !== -1 )
        {
            // Destroy the body
            this.world.destroyBody( body );

            // Remove the body from the array
            this.bodyAry.splice( index, 1 );
        }
    }
    
    //
    //  DESC: Perform fixed time step physics simulation
    //
    fixedTimeStep()
    {
        if( this.active )
        {
            // Increment the timer
            this.timer += _utilities_highresolutiontimer__WEBPACK_IMPORTED_MODULE_0__.highResTimer.elapsedTime;

            if( this.timer > this.stepTime )
            {
                this.timer = _utilities_genfunc__WEBPACK_IMPORTED_MODULE_1__.modulus( this.timer, this.stepTime );

                // Begin the physics world step
                this.world.step( this.stepTimeSec, this.velStepCount, this.posStepCount );
            }

            //this.timeRatio = this.timer / this.stepTime;
        }
    }

    //
    //  DESC: Perform variable time step physics simulation
    //
    variableTimeStep()
    {
        if( this.active )
        {
            // Begin the physics world step
            this.world.step( _utilities_highresolutiontimer__WEBPACK_IMPORTED_MODULE_0__.highResTimer.elapsedTime / 1000.0, this.velStepCount, this.posStepCount );
        }
    }
    
    //
    //  DESC: Set the fps to run the simulation at
    //
    setFPS( fps )
    {
        // Make sure we don't have a negative or zero fps
        if( fps > 1.0 )
        {
            // Calculate the step paramaters
            this.stepTimeSec = 1.0 / fps;
            this.stepTime = this.stepTimeSec * 1000.0;

            // Set the timer so that we'll begin a step next time we call Update
            this.timer = this.stepTime;
        }
    }
}


/***/ }),
/* 56 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "highResTimer": () => (/* binding */ highResTimer)
/* harmony export */ });

// 
//  FILE NAME: highresolutiontimer.js
//  DESC:      high resolution timer class
//



class HighResTimer
{
    constructor()
    {
        // Last recorded time
        this.lastTime = performance.now();

        // Timer time
        this.timer;

        // The amount of time that has elapsed between frames
        this.elapsedTime;

        // The frames per second
        this.fps;
    }
    
    //
    //  DESC: Simple timer start
    //
    timerStart()
    {
        // Get the current performance time
        this.timer = performance.now();
    }

    //
    //  DESC: Simple timer duration
    //
    timerStop()
    {
        // Get the elapsed time
        return (performance.now() - this.timer);
    }
    
    //
    //  DESC: Calc the elapsed time
    //
    calcElapsedTime()
    {
        // Get the current performance time
        let time = performance.now();

        // Set the elapsed time
        this.elapsedTime = time - this.lastTime;

        // Set the fps
        this.fps = 1000.0 / this.elapsedTime;

        // Catch any hickups - cap to about 10 fps
        // Elapsed time is not expected to get this 
        // high in  a game which is why it's capped
        if( this.elapsedTime > 100.0 )
            this.elapsedTime = 100.0;

        // Reset the last time
        this.lastTime = time;
    }

}

var highResTimer = new HighResTimer;


/***/ }),
/* 57 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.internal = {};

exports.Serializer = __webpack_require__(58);

exports.Math = __webpack_require__(63);
exports.Vec2 = __webpack_require__(62);
exports.Vec3 = __webpack_require__(84);
exports.Mat22 = __webpack_require__(80);
exports.Mat33 = __webpack_require__(85);
exports.Transform = __webpack_require__(74);
exports.Rot = __webpack_require__(72);

exports.AABB = __webpack_require__(67);

exports.Shape = __webpack_require__(78);
exports.Fixture = __webpack_require__(77);
exports.Body = __webpack_require__(71);
exports.Contact = __webpack_require__(79);
exports.Joint = __webpack_require__(86);
exports.World = __webpack_require__(59);

exports.Circle = __webpack_require__(89);
exports.Edge = __webpack_require__(90);
exports.Polygon = __webpack_require__(91);
exports.Chain = __webpack_require__(92);
exports.Box = __webpack_require__(93);

__webpack_require__(94);
__webpack_require__(95);
exports.internal.CollidePolygons = __webpack_require__(96);
__webpack_require__(97);
__webpack_require__(98);

exports.DistanceJoint = __webpack_require__(99);
exports.FrictionJoint = __webpack_require__(100);
exports.GearJoint = __webpack_require__(101);
exports.MotorJoint = __webpack_require__(104);
exports.MouseJoint = __webpack_require__(105);
exports.PrismaticJoint = __webpack_require__(103);
exports.PulleyJoint = __webpack_require__(106);
exports.RevoluteJoint = __webpack_require__(102);
exports.RopeJoint = __webpack_require__(107);
exports.WeldJoint = __webpack_require__(108);
exports.WheelJoint = __webpack_require__(109);

exports.Settings = __webpack_require__(66);

exports.internal.Sweep = __webpack_require__(73);
exports.internal.stats = __webpack_require__(83); // todo: remove this
exports.internal.Manifold = __webpack_require__(81);
exports.internal.Distance = __webpack_require__(82);
exports.internal.TimeOfImpact = __webpack_require__(87);
exports.internal.DynamicTree = __webpack_require__(68);
exports.internal.Settings = exports.Settings;


/***/ }),
/* 58 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var World = __webpack_require__(59);
var Body = __webpack_require__(71);
var Joint = __webpack_require__(86);
var Fixture = __webpack_require__(77);
var Shape = __webpack_require__(78);
var Vec2 = __webpack_require__(62);
var Vec3 = __webpack_require__(84);

var SID = 0;

function Serializer(opts) {
  opts = opts || {};

  var rootClass = opts.rootClass || World;

  var preSerialize = opts.preSerialize || function (obj) { return obj; };
  var postSerialize = opts.postSerialize || function (data, obj) { return data; };

  var preDeserialize = opts.preDeserialize || function (data) { return data; };
  var postDeserialize = opts.postDeserialize || function (obj, data) { return obj; };

  // This is used to create ref objects during serialize
  var refTypes = {
    'World': World,
    'Body': Body,
    'Joint': Joint,
    'Fixture': Fixture,
    'Shape': Shape,
  };

  // This is used by restore to deserialize objects and refs
  var restoreTypes = Object.assign({
    'Vec2': Vec2,
    'Vec3': Vec3,
  }, refTypes);

  this.toJson = function (root) {
    var json = [];

    var queue = [root];
    var refMap = {};

    function storeRef(value, typeName) {
      value.__sid = value.__sid || ++SID;
      if (!refMap[value.__sid]) {
        queue.push(value);
        var index = json.length + queue.length;
        var ref = {
          refIndex: index,
          refType: typeName
        };
        refMap[value.__sid] = ref;
      }
      return refMap[value.__sid];
    }

    function serialize(obj) {
      obj = preSerialize(obj);
      var data = obj._serialize();
      data = postSerialize(data, obj);
      return data;
    }

    function toJson(value, top) {
      if (typeof value !== 'object' || value === null) {
        return value;
      }
      if (typeof value._serialize === 'function') {
        if (value !== top) {
          for (var typeName in refTypes) {
            if (value instanceof refTypes[typeName]) {
              return storeRef(value, typeName);
            }
          }
        }
        value = serialize(value);
      }
      if (Array.isArray(value)) {
        var newValue = [];
        for (var key = 0; key < value.length; key++) {
          newValue[key] = toJson(value[key]);
        }
        value = newValue;

      } else {
        var newValue = {};
        for (var key in value) {
          if (value.hasOwnProperty(key)) {
            newValue[key] = toJson(value[key]);
          }
        }
        value = newValue;
      }
      return value;
    }

    while (queue.length) {
      var obj = queue.shift();
      var str = toJson(obj, obj);
      json.push(str);
    }

    return json;
  };

  this.fromJson = function (json) {
    var refMap = {};

    function deserialize(cls, data, ctx) {
      data = preDeserialize(data);
      var obj = cls._deserialize(data, ctx, restoreRef);
      obj = postDeserialize(obj, data);
      return obj;
    }

    function restoreRef(cls, ref, ctx) {
      if (!ref.refIndex) {
        return cls && cls._deserialize && deserialize(cls, ref, ctx);
      }
      cls = restoreTypes[ref.refType] || cls;
      var index = ref.refIndex;
      if (!refMap[index]) {
        var data = json[index];
        var obj = deserialize(cls, data, ctx);
        refMap[index] = obj;
      }
      return refMap[index];
    }

    var root = rootClass._deserialize(json[0], null, restoreRef);

    return root;
  }
}

module.exports = Serializer;

var serializer = new Serializer();
module.exports.toJson = serializer.toJson;
module.exports.fromJson = serializer.fromJson;


/***/ }),
/* 59 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

module.exports = World;

var options = __webpack_require__(60);
var common = __webpack_require__(61);
var Vec2 = __webpack_require__(62);
var BroadPhase = __webpack_require__(65);
var Solver = __webpack_require__(70);
var Body = __webpack_require__(71);
var Joint = __webpack_require__(86);
var Contact = __webpack_require__(79);

/**
 * @typedef {Object} WorldDef
 *
 * @prop {Vec2} [gravity = { x : 0, y : 0}]
 * @prop {boolean} [allowSleep = true]
 * @prop {boolean} [warmStarting = true]
 * @prop {boolean} [continuousPhysics = true]
 * @prop {boolean} [subStepping = false]
 * @prop {boolean} [blockSolve = true]
 * @prop {int} [velocityIterations = 8] For the velocity constraint solver.
 * @prop {int} [positionIterations = 3] For the position constraint solver.
 */
var WorldDef = {
  gravity : Vec2.zero(),
  allowSleep : true,
  warmStarting : true,
  continuousPhysics : true,
  subStepping : false,
  blockSolve : true,
  velocityIterations : 8,
  positionIterations : 3
};

/**
 * @param {WorldDef|Vec2} def World definition or gravity vector.
 */
function World(def) {
  if (!(this instanceof World)) {
    return new World(def);
  }

  if (def && Vec2.isValid(def)) {
    def = {gravity : def};
  }

  def = options(def, WorldDef);

  this.m_solver = new Solver(this);

  this.m_broadPhase = new BroadPhase();

  this.m_contactList = null;
  this.m_contactCount = 0;

  this.m_bodyList = null;
  this.m_bodyCount = 0;

  this.m_jointList = null;
  this.m_jointCount = 0;

  this.m_stepComplete = true;

  this.m_allowSleep = def.allowSleep;
  this.m_gravity = Vec2.clone(def.gravity);

  this.m_clearForces = true;
  this.m_newFixture = false;
  this.m_locked = false;

  // These are for debugging the solver.
  this.m_warmStarting = def.warmStarting;
  this.m_continuousPhysics = def.continuousPhysics;
  this.m_subStepping = def.subStepping;

  this.m_blockSolve = def.blockSolve;
  this.m_velocityIterations = def.velocityIterations;
  this.m_positionIterations = def.positionIterations;

  this.m_t = 0;

  // Broad-phase callback.
  this.addPair = this.createContact.bind(this);
}

World.prototype._serialize = function() {
  var bodies = [];
  var joints = [];

  for (var b = this.getBodyList(); b; b = b.getNext()) {
    bodies.push(b);
  }

  for (var j = this.getJointList(); j; j = j.getNext()) {
    if (typeof j._serialize === 'function') {
      joints.push(j);
    }
  }

  return {
    gravity: this.m_gravity,
    bodies: bodies,
    joints: joints,
  };
};

World._deserialize = function(data, context, restore) {
  if (!data) {
    return new World();
  }

  var world = new World(data.gravity);

  if (data.bodies) {
    for(var i = data.bodies.length - 1; i >= 0; i -= 1) {
      world._addBody(restore(Body, data.bodies[i], world));
    }
  }

  if (data.joints) {
    for(var i = data.joints.length - 1; i >= 0; i--) {
      world.createJoint(restore(Joint, data.joints[i], world));
    }
  }

  return world;
};

/**
 * Get the world body list. With the returned body, use Body.getNext to get the
 * next body in the world list. A null body indicates the end of the list.
 *
 * @return the head of the world body list.
 */
World.prototype.getBodyList = function() {
  return this.m_bodyList;
}

/**
 * Get the world joint list. With the returned joint, use Joint.getNext to get
 * the next joint in the world list. A null joint indicates the end of the list.
 *
 * @return the head of the world joint list.
 */
World.prototype.getJointList = function() {
  return this.m_jointList;
}

/**
 * Get the world contact list. With the returned contact, use Contact.getNext to
 * get the next contact in the world list. A null contact indicates the end of
 * the list.
 *
 * @return the head of the world contact list. Warning: contacts are created and
 *         destroyed in the middle of a time step. Use ContactListener to avoid
 *         missing contacts.
 */
World.prototype.getContactList = function() {
  return this.m_contactList;
}

World.prototype.getBodyCount = function() {
  return this.m_bodyCount;
}

World.prototype.getJointCount = function() {
  return this.m_jointCount;
}

/**
 * Get the number of contacts (each may have 0 or more contact points).
 */
World.prototype.getContactCount = function() {
  return this.m_contactCount;
}

/**
 * Change the global gravity vector.
 */
World.prototype.setGravity = function(gravity) {
  this.m_gravity = gravity;
}

/**
 * Get the global gravity vector.
 */
World.prototype.getGravity = function() {
  return this.m_gravity;
}

/**
 * Is the world locked (in the middle of a time step).
 */
World.prototype.isLocked = function() {
  return this.m_locked;
}

/**
 * Enable/disable sleep.
 */
World.prototype.setAllowSleeping = function(flag) {
  if (flag == this.m_allowSleep) {
    return;
  }

  this.m_allowSleep = flag;
  if (this.m_allowSleep == false) {
    for (var b = this.m_bodyList; b; b = b.m_next) {
      b.setAwake(true);
    }
  }
}

World.prototype.getAllowSleeping = function() {
  return this.m_allowSleep;
}

/**
 * Enable/disable warm starting. For testing.
 */
World.prototype.setWarmStarting = function(flag) {
  this.m_warmStarting = flag;
}

World.prototype.getWarmStarting = function() {
  return this.m_warmStarting;
}

/**
 * Enable/disable continuous physics. For testing.
 */
World.prototype.setContinuousPhysics = function(flag) {
  this.m_continuousPhysics = flag;
}

World.prototype.getContinuousPhysics = function() {
  return this.m_continuousPhysics;
}

/**
 * Enable/disable single stepped continuous physics. For testing.
 */
World.prototype.setSubStepping = function(flag) {
  this.m_subStepping = flag;
}

World.prototype.getSubStepping = function() {
  return this.m_subStepping;
}

/**
 * Set flag to control automatic clearing of forces after each time step.
 */
World.prototype.setAutoClearForces = function(flag) {
  this.m_clearForces = flag;
}

/**
 * Get the flag that controls automatic clearing of forces after each time step.
 */
World.prototype.getAutoClearForces = function() {
  return this.m_clearForces;
}

/**
 * Manually clear the force buffer on all bodies. By default, forces are cleared
 * automatically after each call to step. The default behavior is modified by
 * calling setAutoClearForces. The purpose of this function is to support
 * sub-stepping. Sub-stepping is often used to maintain a fixed sized time step
 * under a variable frame-rate. When you perform sub-stepping you will disable
 * auto clearing of forces and instead call clearForces after all sub-steps are
 * complete in one pass of your game loop.
 *
 * @see setAutoClearForces
 */
World.prototype.clearForces = function() {
  for (var body = this.m_bodyList; body; body = body.getNext()) {
    body.m_force.setZero();
    body.m_torque = 0.0;
  }
}

/**
 * @function World~rayCastCallback
 *
 * @param fixture
 */

/**
 * Query the world for all fixtures that potentially overlap the provided AABB.
 *
 * @param {World~queryCallback} queryCallback Called for each fixture
 *          found in the query AABB. It may return `false` to terminate the
 *          query.
 *
 * @param aabb The query box.
 */
World.prototype.queryAABB = function(aabb, queryCallback) {
  _ASSERT && common.assert(typeof queryCallback === 'function');
  var broadPhase = this.m_broadPhase;
  this.m_broadPhase.query(aabb, function(proxyId) { //TODO GC
    var proxy = broadPhase.getUserData(proxyId); // FixtureProxy
    return queryCallback(proxy.fixture);
  });
}

/**
 * @function World~rayCastCallback
 *
 * Callback class for ray casts. See World.rayCast
 *
 * Called for each fixture found in the query. You control how the ray cast
 * proceeds by returning a float: return -1: ignore this fixture and continue
 * return 0: terminate the ray cast return fraction: clip the ray to this point
 * return 1: don't clip the ray and continue
 *
 * @param fixture The fixture hit by the ray
 * @param point The point of initial intersection
 * @param normal The normal vector at the point of intersection
 * @param fraction
 *
 * @return {float} -1 to filter, 0 to terminate, fraction to clip the ray for
 *         closest hit, 1 to continue
 */

/**
 *
 * Ray-cast the world for all fixtures in the path of the ray. Your callback
 * controls whether you get the closest point, any point, or n-points. The
 * ray-cast ignores shapes that contain the starting point.
 *
 * @param {World~RayCastCallback} reportFixtureCallback A user implemented
 *          callback function.
 * @param point1 The ray starting point
 * @param point2 The ray ending point
 */
World.prototype.rayCast = function(point1, point2, reportFixtureCallback) {
  _ASSERT && common.assert(typeof reportFixtureCallback === 'function');
  var broadPhase = this.m_broadPhase;

  this.m_broadPhase.rayCast({
    maxFraction : 1.0,
    p1 : point1,
    p2 : point2
  }, function(input, proxyId) { // TODO GC
    var proxy = broadPhase.getUserData(proxyId); // FixtureProxy
    var fixture = proxy.fixture;
    var index = proxy.childIndex;
    var output = {}; // TODO GC
    var hit = fixture.rayCast(output, input, index);
    if (hit) {
      var fraction = output.fraction;
      var point = Vec2.add(Vec2.mul((1.0 - fraction), input.p1), Vec2.mul(fraction, input.p2));
      return reportFixtureCallback(fixture, point, output.normal, fraction);
    }
    return input.maxFraction;
  });
}

/**
 * Get the number of broad-phase proxies.
 */
World.prototype.getProxyCount = function() {
  return this.m_broadPhase.getProxyCount();
}

/**
 * Get the height of broad-phase dynamic tree.
 */
World.prototype.getTreeHeight = function() {
  return this.m_broadPhase.getTreeHeight();
}

/**
 * Get the balance of broad-phase dynamic tree.
 *
 * @returns {int}
 */
World.prototype.getTreeBalance = function() {
  return this.m_broadPhase.getTreeBalance();
}

/**
 * Get the quality metric of broad-phase dynamic tree. The smaller the better.
 * The minimum is 1.
 *
 * @returns {float}
 */
World.prototype.getTreeQuality = function() {
  return this.m_broadPhase.getTreeQuality();
}

/**
 * Shift the world origin. Useful for large worlds. The body shift formula is:
 * position -= newOrigin
 *
 * @param {Vec2} newOrigin The new origin with respect to the old origin
 */
World.prototype.shiftOrigin = function(newOrigin) {
  _ASSERT && common.assert(this.m_locked == false);
  if (this.m_locked) {
    return;
  }

  for (var b = this.m_bodyList; b; b = b.m_next) {
    b.m_xf.p.sub(newOrigin);
    b.m_sweep.c0.sub(newOrigin);
    b.m_sweep.c.sub(newOrigin);
  }

  for (var j = this.m_jointList; j; j = j.m_next) {
    j.shiftOrigin(newOrigin);
  }

  this.m_broadPhase.shiftOrigin(newOrigin);
}

/**
 * @internal Used for deserialize.
 */
World.prototype._addBody = function(body) {
  _ASSERT && common.assert(this.isLocked() === false);
  if (this.isLocked()) {
    return;
  }

  // Add to world doubly linked list.
  body.m_prev = null;
  body.m_next = this.m_bodyList;
  if (this.m_bodyList) {
    this.m_bodyList.m_prev = body;
  }
  this.m_bodyList = body;
  ++this.m_bodyCount;
}

/**
 * Create a rigid body given a definition. No reference to the definition is
 * retained.
 *
 * Warning: This function is locked during callbacks.
 *
 * @param {BodyDef|Vec2} def Body definition or position.
 * @param {float} angle Body angle if def is position.
 */
World.prototype.createBody = function(def, angle) {
  _ASSERT && common.assert(this.isLocked() == false);
  if (this.isLocked()) {
    return null;
  }

  if (def && Vec2.isValid(def)) {
    def = {
      position : def,
      angle : angle
    };
  }

  var body = new Body(this, def);

  this._addBody(body);

  return body;
}

World.prototype.createDynamicBody = function(def, angle) {
  if (!def) {
    def = {};
  } else if (Vec2.isValid(def)) {
    def = { position : def, angle : angle };
  }
  def.type = 'dynamic';
  return this.createBody(def);
}

World.prototype.createKinematicBody = function(def, angle) {
  if (!def) {
    def = {};
  } else if (Vec2.isValid(def)) {
    def = { position : def, angle : angle };
  }
  def.type = 'kinematic';
  return this.createBody(def);
}

/**
 * Destroy a rigid body given a definition. No reference to the definition is
 * retained.
 *
 * Warning: This automatically deletes all associated shapes and joints.
 *
 * Warning: This function is locked during callbacks.
 *
 * @param {Body} b
 */
World.prototype.destroyBody = function(b) {
  _ASSERT && common.assert(this.m_bodyCount > 0);
  _ASSERT && common.assert(this.isLocked() == false);
  if (this.isLocked()) {
    return;
  }

  if (b.m_destroyed) {
    return false;
  }

  // Delete the attached joints.
  var je = b.m_jointList;
  while (je) {
    var je0 = je;
    je = je.next;

    this.publish('remove-joint', je0.joint);
    this.destroyJoint(je0.joint);

    b.m_jointList = je;
  }
  b.m_jointList = null;

  // Delete the attached contacts.
  var ce = b.m_contactList;
  while (ce) {
    var ce0 = ce;
    ce = ce.next;

    this.destroyContact(ce0.contact);

    b.m_contactList = ce;
  }
  b.m_contactList = null;

  // Delete the attached fixtures. This destroys broad-phase proxies.
  var f = b.m_fixtureList;
  while (f) {
    var f0 = f;
    f = f.m_next;

    this.publish('remove-fixture', f0);
    f0.destroyProxies(this.m_broadPhase);

    b.m_fixtureList = f;
  }
  b.m_fixtureList = null;

  // Remove world body list.
  if (b.m_prev) {
    b.m_prev.m_next = b.m_next;
  }

  if (b.m_next) {
    b.m_next.m_prev = b.m_prev;
  }

  if (b == this.m_bodyList) {
    this.m_bodyList = b.m_next;
  }

  b.m_destroyed = true;

  --this.m_bodyCount;

  this.publish('remove-body', b);

  return true;
}

/**
 * Create a joint to constrain bodies together. No reference to the definition
 * is retained. This may cause the connected bodies to cease colliding.
 *
 * Warning: This function is locked during callbacks.
 *
 * @param {Joint} join
 * @param {Body} bodyB
 * @param {Body} bodyA
 */
World.prototype.createJoint = function(joint) {
  _ASSERT && common.assert(!!joint.m_bodyA);
  _ASSERT && common.assert(!!joint.m_bodyB);
  _ASSERT && common.assert(this.isLocked() == false);
  if (this.isLocked()) {
    return null;
  }

  // Connect to the world list.
  joint.m_prev = null;
  joint.m_next = this.m_jointList;
  if (this.m_jointList) {
    this.m_jointList.m_prev = joint;
  }
  this.m_jointList = joint;
  ++this.m_jointCount;

  // Connect to the bodies' doubly linked lists.
  joint.m_edgeA.joint = joint;
  joint.m_edgeA.other = joint.m_bodyB;
  joint.m_edgeA.prev = null;
  joint.m_edgeA.next = joint.m_bodyA.m_jointList;
  if (joint.m_bodyA.m_jointList)
    joint.m_bodyA.m_jointList.prev = joint.m_edgeA;
  joint.m_bodyA.m_jointList = joint.m_edgeA;

  joint.m_edgeB.joint = joint;
  joint.m_edgeB.other = joint.m_bodyA;
  joint.m_edgeB.prev = null;
  joint.m_edgeB.next = joint.m_bodyB.m_jointList;
  if (joint.m_bodyB.m_jointList)
    joint.m_bodyB.m_jointList.prev = joint.m_edgeB;
  joint.m_bodyB.m_jointList = joint.m_edgeB;

  // If the joint prevents collisions, then flag any contacts for filtering.
  if (joint.m_collideConnected == false) {
    for (var edge = joint.m_bodyB.getContactList(); edge; edge = edge.next) {
      if (edge.other == joint.m_bodyA) {
        // Flag the contact for filtering at the next time step (where either
        // body is awake).
        edge.contact.flagForFiltering();
      }
    }
  }

  // Note: creating a joint doesn't wake the bodies.

  return joint;
}

/**
 * Destroy a joint. This may cause the connected bodies to begin colliding.
 * Warning: This function is locked during callbacks.
 *
 * @param {Joint} join
 */
World.prototype.destroyJoint = function(joint) {
  _ASSERT && common.assert(this.isLocked() == false);
  if (this.isLocked()) {
    return;
  }

  // Remove from the doubly linked list.
  if (joint.m_prev) {
    joint.m_prev.m_next = joint.m_next;
  }

  if (joint.m_next) {
    joint.m_next.m_prev = joint.m_prev;
  }

  if (joint == this.m_jointList) {
    this.m_jointList = joint.m_next;
  }

  // Disconnect from bodies.
  var bodyA = joint.m_bodyA;
  var bodyB = joint.m_bodyB;

  // Wake up connected bodies.
  bodyA.setAwake(true);
  bodyB.setAwake(true);

  // Remove from body 1.
  if (joint.m_edgeA.prev) {
    joint.m_edgeA.prev.next = joint.m_edgeA.next;
  }

  if (joint.m_edgeA.next) {
    joint.m_edgeA.next.prev = joint.m_edgeA.prev;
  }

  if (joint.m_edgeA == bodyA.m_jointList) {
    bodyA.m_jointList = joint.m_edgeA.next;
  }

  joint.m_edgeA.prev = null;
  joint.m_edgeA.next = null;

  // Remove from body 2
  if (joint.m_edgeB.prev) {
    joint.m_edgeB.prev.next = joint.m_edgeB.next;
  }

  if (joint.m_edgeB.next) {
    joint.m_edgeB.next.prev = joint.m_edgeB.prev;
  }

  if (joint.m_edgeB == bodyB.m_jointList) {
    bodyB.m_jointList = joint.m_edgeB.next;
  }

  joint.m_edgeB.prev = null;
  joint.m_edgeB.next = null;

  _ASSERT && common.assert(this.m_jointCount > 0);
  --this.m_jointCount;

  // If the joint prevents collisions, then flag any contacts for filtering.
  if (joint.m_collideConnected == false) {
    var edge = bodyB.getContactList();
    while (edge) {
      if (edge.other == bodyA) {
        // Flag the contact for filtering at the next time step (where either
        // body is awake).
        edge.contact.flagForFiltering();
      }

      edge = edge.next;
    }
  }

  this.publish('remove-joint', joint);
}

var s_step = new Solver.TimeStep(); // reuse

/**
 * Take a time step. This performs collision detection, integration, and
 * constraint solution.
 *
 * Broad-phase, narrow-phase, solve and solve time of impacts.
 *
 * @param {float} timeStep Time step, this should not vary.
 * @param {int} velocityIterations
 * @param {int} positionIterations
 */
World.prototype.step = function(timeStep, velocityIterations, positionIterations) {
  this.publish('pre-step', timeStep);

  if ((velocityIterations | 0) !== velocityIterations) {
    // TODO: remove this in future
    velocityIterations = 0;
  }

  velocityIterations = velocityIterations || this.m_velocityIterations;
  positionIterations = positionIterations || this.m_positionIterations;

  // If new fixtures were added, we need to find the new contacts.
  if (this.m_newFixture) {
    this.findNewContacts();
    this.m_newFixture = false;
  }

  this.m_locked = true;

  s_step.reset(timeStep);
  s_step.velocityIterations = velocityIterations;
  s_step.positionIterations = positionIterations;
  s_step.warmStarting = this.m_warmStarting;
  s_step.blockSolve = this.m_blockSolve;

  // Update contacts. This is where some contacts are destroyed.
  this.updateContacts();

  // Integrate velocities, solve velocity constraints, and integrate positions.
  if (this.m_stepComplete && timeStep > 0.0) {
    this.m_solver.solveWorld(s_step);

    // Synchronize fixtures, check for out of range bodies.
    for (var b = this.m_bodyList; b; b = b.getNext()) {
      // If a body was not in an island then it did not move.
      if (b.m_islandFlag == false) {
        continue;
      }

      if (b.isStatic()) {
        continue;
      }

      // Update fixtures (for broad-phase).
      b.synchronizeFixtures();
    }
    // Look for new contacts.
    this.findNewContacts();
  }

  // Handle TOI events.
  if (this.m_continuousPhysics && timeStep > 0.0) {
    this.m_solver.solveWorldTOI(s_step);
  }

  if (this.m_clearForces) {
    this.clearForces();
  }

  this.m_locked = false;

  this.publish('post-step', timeStep);
}

/**
 * Call this method to find new contacts.
 */
World.prototype.findNewContacts = function() {
  this.m_broadPhase.updatePairs(this.addPair);
}

/**
 * @private
 *
 * @param {FixtureProxy} proxyA
 * @param {FixtureProxy} proxyB
 */
World.prototype.createContact = function(proxyA, proxyB) {
  var fixtureA = proxyA.fixture;
  var fixtureB = proxyB.fixture;

  var indexA = proxyA.childIndex;
  var indexB = proxyB.childIndex;

  var bodyA = fixtureA.getBody();
  var bodyB = fixtureB.getBody();

  // Are the fixtures on the same body?
  if (bodyA == bodyB) {
    return;
  }

  // TODO_ERIN use a hash table to remove a potential bottleneck when both
  // bodies have a lot of contacts.
  // Does a contact already exist?
  var edge = bodyB.getContactList(); // ContactEdge
  while (edge) {
    if (edge.other == bodyA) {
      var fA = edge.contact.getFixtureA();
      var fB = edge.contact.getFixtureB();
      var iA = edge.contact.getChildIndexA();
      var iB = edge.contact.getChildIndexB();

      if (fA == fixtureA && fB == fixtureB && iA == indexA && iB == indexB) {
        // A contact already exists.
        return;
      }

      if (fA == fixtureB && fB == fixtureA && iA == indexB && iB == indexA) {
        // A contact already exists.
        return;
      }
    }

    edge = edge.next;
  }

  if (bodyB.shouldCollide(bodyA) == false) {
    return;
  }
  if (fixtureB.shouldCollide(fixtureA) == false) {
    return;
  }

  // Call the factory.
  var contact = Contact.create(fixtureA, indexA, fixtureB, indexB);
  if (contact == null) {
    return;
  }

  // Insert into the world.
  contact.m_prev = null;
  if (this.m_contactList != null) {
    contact.m_next = this.m_contactList;
    this.m_contactList.m_prev = contact;
  }
  this.m_contactList = contact;

  ++this.m_contactCount;
}

/**
 * Removes old non-overlapping contacts, applies filters and updates contacts.
 */
World.prototype.updateContacts = function() {
  // Update awake contacts.
  var c, next_c = this.m_contactList;
  while (c = next_c) {
    next_c = c.getNext()
    var fixtureA = c.getFixtureA();
    var fixtureB = c.getFixtureB();
    var indexA = c.getChildIndexA();
    var indexB = c.getChildIndexB();
    var bodyA = fixtureA.getBody();
    var bodyB = fixtureB.getBody();

    // Is this contact flagged for filtering?
    if (c.m_filterFlag) {
      if (bodyB.shouldCollide(bodyA) == false) {
        this.destroyContact(c);
        continue;
      }

      if (fixtureB.shouldCollide(fixtureA) == false) {
        this.destroyContact(c);
        continue;
      }

      // Clear the filtering flag.
      c.m_filterFlag = false;
    }

    var activeA = bodyA.isAwake() && !bodyA.isStatic();
    var activeB = bodyB.isAwake() && !bodyB.isStatic();

    // At least one body must be awake and it must be dynamic or kinematic.
    if (activeA == false && activeB == false) {
      continue;
    }

    var proxyIdA = fixtureA.m_proxies[indexA].proxyId;
    var proxyIdB = fixtureB.m_proxies[indexB].proxyId;
    var overlap = this.m_broadPhase.testOverlap(proxyIdA, proxyIdB);

    // Here we destroy contacts that cease to overlap in the broad-phase.
    if (overlap == false) {
      this.destroyContact(c);
      continue;
    }

    // The contact persists.
    c.update(this);
  }
}

/**
 * @param {Contact} contact
 */
World.prototype.destroyContact = function(contact) {
  Contact.destroy(contact, this);

  // Remove from the world.
  if (contact.m_prev) {
    contact.m_prev.m_next = contact.m_next;
  }
  if (contact.m_next) {
    contact.m_next.m_prev = contact.m_prev;
  }
  if (contact == this.m_contactList) {
    this.m_contactList = contact.m_next;
  }

  --this.m_contactCount;
}

World.prototype._listeners = null;

/**
 * Register an event listener.
 *
 * @param {string} name
 * @param {function} listener
 */
World.prototype.on = function(name, listener) {
  if (typeof name !== 'string' || typeof listener !== 'function') {
    return this;
  }
  if (!this._listeners) {
    this._listeners = {};
  }
  if (!this._listeners[name]) {
    this._listeners[name] = [];
  }
  this._listeners[name].push(listener);
  return this;
};

/**
 * Remove an event listener.
 *
 * @param {string} name
 * @param {function} listener
 */
World.prototype.off = function(name, listener) {
  if (typeof name !== 'string' || typeof listener !== 'function') {
    return this;
  }
  var listeners = this._listeners && this._listeners[name];
  if (!listeners || !listeners.length) {
    return this;
  }
  var index = listeners.indexOf(listener);
  if (index >= 0) {
    listeners.splice(index, 1);
  }
  return this;
};

World.prototype.publish = function(name, arg1, arg2, arg3) {
  var listeners = this._listeners && this._listeners[name];
  if (!listeners || !listeners.length) {
    return 0;
  }
  for (var l = 0; l < listeners.length; l++) {
    listeners[l].call(this, arg1, arg2, arg3);
  }
  return listeners.length;
};

/**
 * @event World#remove-body
 * @event World#remove-joint
 * @event World#remove-fixture
 *
 * Joints and fixtures are destroyed when their associated body is destroyed.
 * Register a destruction listener so that you may nullify references to these
 * joints and shapes.
 *
 * `function(object)` is called when any joint or fixture is about to
 * be destroyed due to the destruction of one of its attached or parent bodies.
 */

/**
 * @private
 * @param {Contact} contact
 */
World.prototype.beginContact = function(contact) {
  this.publish('begin-contact', contact);
};

/**
 * @event World#begin-contact
 *
 * Called when two fixtures begin to touch.
 *
 * Implement contact callbacks to get contact information. You can use these
 * results for things like sounds and game logic. You can also get contact
 * results by traversing the contact lists after the time step. However, you
 * might miss some contacts because continuous physics leads to sub-stepping.
 * Additionally you may receive multiple callbacks for the same contact in a
 * single time step. You should strive to make your callbacks efficient because
 * there may be many callbacks per time step.
 *
 * Warning: You cannot create/destroy world entities inside these callbacks.
 */

/**
 * @private
 * @param {Contact} contact
 */
World.prototype.endContact = function(contact) {
  this.publish('end-contact', contact);
};

/**
 * @event World#end-contact
 *
 * Called when two fixtures cease to touch.
 *
 * Implement contact callbacks to get contact information. You can use these
 * results for things like sounds and game logic. You can also get contact
 * results by traversing the contact lists after the time step. However, you
 * might miss some contacts because continuous physics leads to sub-stepping.
 * Additionally you may receive multiple callbacks for the same contact in a
 * single time step. You should strive to make your callbacks efficient because
 * there may be many callbacks per time step.
 *
 * Warning: You cannot create/destroy world entities inside these callbacks.
 */

/**
 * @private
 * @param {Contact} contact
 * @param {Manifold} oldManifold
 */
World.prototype.preSolve = function(contact, oldManifold) {
  this.publish('pre-solve', contact, oldManifold);
};

/**
 * @event World#pre-solve
 *
 * This is called after a contact is updated. This allows you to inspect a
 * contact before it goes to the solver. If you are careful, you can modify the
 * contact manifold (e.g. disable contact). A copy of the old manifold is
 * provided so that you can detect changes. Note: this is called only for awake
 * bodies. Note: this is called even when the number of contact points is zero.
 * Note: this is not called for sensors. Note: if you set the number of contact
 * points to zero, you will not get an endContact callback. However, you may get
 * a beginContact callback the next step.
 *
 * Warning: You cannot create/destroy world entities inside these callbacks.
 */

/**
 * @private
 * @param {Contact} contact
 * @param {ContactImpulse} impulse
 */
World.prototype.postSolve = function(contact, impulse) {
  this.publish('post-solve', contact, impulse);
};

/**
 * @event World#post-solve
 *
 * This lets you inspect a contact after the solver is finished. This is useful
 * for inspecting impulses. Note: the contact manifold does not include time of
 * impact impulses, which can be arbitrarily large if the sub-step is small.
 * Hence the impulse is provided explicitly in a separate data structure. Note:
 * this is only called for contacts that are touching, solid, and awake.
 *
 * Warning: You cannot create/destroy world entities inside these callbacks.
 */

/**
 * Register a contact filter to provide specific control over collision.
 * Otherwise the default filter is used (defaultFilter). The listener is owned
 * by you and must remain in scope.
 *
 * Moved to Fixture.
 */


/***/ }),
/* 60 */
/***/ ((module) => {

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

var propIsEnumerable = Object.prototype.propertyIsEnumerable;

module.exports = function(input, defaults) {
  if (input === null || typeof input === 'undefined') {
    input = {};
  }

  var output = Object.assign({}, input);

  for ( var key in defaults) {
    if (defaults.hasOwnProperty(key) && typeof input[key] === 'undefined') {
      output[key] = defaults[key];
    }
  }

  if (typeof Object.getOwnPropertySymbols === 'function') {
    var symbols = Object.getOwnPropertySymbols(defaults);
    for (var i = 0; i < symbols.length; i++) {
      var symbol = symbols[i];
      if (defaults.propertyIsEnumerable(symbol) && typeof input[key] === 'undefined') {
        output[symbol] = defaults[symbol];
      }
    }
  }

  return output;
};


/***/ }),
/* 61 */
/***/ ((__unused_webpack_module, exports) => {

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

exports.debug = function() {
  if (!_DEBUG) return;
  console.log.apply(console, arguments);
};

exports.assert = function(statement, err, log) {
  if (!_ASSERT) return;
  if (statement) return;
  log && console.log(log);
  throw new Error(err);
};

/***/ }),
/* 62 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

module.exports = Vec2;

var common = __webpack_require__(61);
var Math = __webpack_require__(63);

function Vec2(x, y) {
  if (!(this instanceof Vec2)) {
    return new Vec2(x, y);
  }
  if (typeof x === 'undefined') {
    this.x = 0;
    this.y = 0;
  } else if (typeof x === 'object') {
    this.x = x.x;
    this.y = x.y;
  } else {
    this.x = x;
    this.y = y;
  }
  _ASSERT && Vec2.assert(this);
}

Vec2.prototype._serialize = function() {
  return {
    x: this.x,
    y: this.y
  };
};

Vec2._deserialize = function(data) {
  var obj = Object.create(Vec2.prototype);
  obj.x = data.x;
  obj.y = data.y;
  return obj;
};

Vec2.zero = function() {
  var obj = Object.create(Vec2.prototype);
  obj.x = 0;
  obj.y = 0;
  return obj;
};

Vec2.neo = function(x, y) {
  var obj = Object.create(Vec2.prototype);
  obj.x = x;
  obj.y = y;
  return obj;
};

Vec2.clone = function(v) {
  _ASSERT && Vec2.assert(v);
  return Vec2.neo(v.x, v.y);
};

Vec2.prototype.toString = function() {
  return JSON.stringify(this);
};

/**
 * Does this vector contain finite coordinates?
 */
Vec2.isValid = function(v) {
  return v && Math.isFinite(v.x) && Math.isFinite(v.y);
}

Vec2.assert = function(o) {
  if (!_ASSERT) return;
  if (!Vec2.isValid(o)) {
    _DEBUG && common.debug(o);
    throw new Error('Invalid Vec2!');
  }
}

Vec2.prototype.clone = function() {
  return Vec2.clone(this);
}

/**
 * Set this vector to all zeros.
 * 
 * @returns this
 */
Vec2.prototype.setZero = function() {
  this.x = 0.0;
  this.y = 0.0;
  return this;
}

/**
 * Set this vector to some specified coordinates.
 * 
 * @returns this
 */
Vec2.prototype.set = function(x, y) {
  if (typeof x === 'object') {
    _ASSERT && Vec2.assert(x);
    this.x = x.x;
    this.y = x.y;
  } else {
    _ASSERT && Math.assert(x);
    _ASSERT && Math.assert(y);
    this.x = x;
    this.y = y;
  }
  return this;
}

/**
 * @deprecated Use setCombine or setMul
 */
Vec2.prototype.wSet = function(a, v, b, w) {
  if (typeof b !== 'undefined' || typeof w !== 'undefined') {
    return this.setCombine(a, v, b, w);
  } else {
    return this.setMul(a, v);
  }
}

/**
 * Set linear combination of v and w: `a * v + b * w`
 */
Vec2.prototype.setCombine = function(a, v, b, w) {
  _ASSERT && Math.assert(a);
  _ASSERT && Vec2.assert(v);
  _ASSERT && Math.assert(b);
  _ASSERT && Vec2.assert(w);
  var x = a * v.x + b * w.x;
  var y = a * v.y + b * w.y;

  // `this` may be `w`
  this.x = x;
  this.y = y;
  return this;
}

Vec2.prototype.setMul = function(a, v) {
  _ASSERT && Math.assert(a);
  _ASSERT && Vec2.assert(v);
  var x = a * v.x;
  var y = a * v.y;

  this.x = x;
  this.y = y;
  return this;
}

/**
 * Add a vector to this vector.
 * 
 * @returns this
 */
Vec2.prototype.add = function(w) {
  _ASSERT && Vec2.assert(w);
  this.x += w.x;
  this.y += w.y;
  return this;
}

/**
 * @deprecated Use addCombine or addMul
 */
Vec2.prototype.wAdd = function(a, v, b, w) {
  if (typeof b !== 'undefined' || typeof w !== 'undefined') {
    return this.addCombine(a, v, b, w);
  } else {
    return this.addMul(a, v);
  }
}

/**
 * Add linear combination of v and w: `a * v + b * w`
 */
Vec2.prototype.addCombine = function(a, v, b, w) {
  _ASSERT && Math.assert(a);
  _ASSERT && Vec2.assert(v);
  _ASSERT && Math.assert(b);
  _ASSERT && Vec2.assert(w);

  var x = a * v.x + b * w.x;
  var y = a * v.y + b * w.y;

  // `this` may be `w`
  this.x += x;
  this.y += y;
  return this;
}

Vec2.prototype.addMul = function(a, v) {
  _ASSERT && Math.assert(a);
  _ASSERT && Vec2.assert(v);
  var x = a * v.x;
  var y = a * v.y;

  this.x += x;
  this.y += y;
  return this;
}

/**
 * @deprecated Use subCombine or subMul
 */
Vec2.prototype.wSub = function(a, v, b, w) {
  if (typeof b !== 'undefined' || typeof w !== 'undefined') {
    return this.subCombine(a, v, b, w);
  } else {
    return this.subMul(a, v);
  }}

/**
 * Subtract linear combination of v and w: `a * v + b * w`
 */
Vec2.prototype.subCombine = function(a, v, b, w) {
  _ASSERT && Math.assert(a);
  _ASSERT && Vec2.assert(v);
  _ASSERT && Math.assert(b);
  _ASSERT && Vec2.assert(w);
  var x = a * v.x + b * w.x;
  var y = a * v.y + b * w.y;

  // `this` may be `w`
  this.x -= x;
  this.y -= y;
  return this;
}

Vec2.prototype.subMul = function(a, v) {
  _ASSERT && Math.assert(a);
  _ASSERT && Vec2.assert(v);
  var x = a * v.x;
  var y = a * v.y;

  this.x -= x;
  this.y -= y;
  return this;
}

/**
 * Subtract a vector from this vector
 * 
 * @returns this
 */
Vec2.prototype.sub = function(w) {
  _ASSERT && Vec2.assert(w);
  this.x -= w.x;
  this.y -= w.y;
  return this;
}

/**
 * Multiply this vector by a scalar.
 * 
 * @returns this
 */
Vec2.prototype.mul = function(m) {
  _ASSERT && Math.assert(m);
  this.x *= m;
  this.y *= m;
  return this;
}

/**
 * Get the length of this vector (the norm).
 * 
 * For performance, use this instead of lengthSquared (if possible).
 */
Vec2.prototype.length = function() {
  return Vec2.lengthOf(this);
}

/**
 * Get the length squared.
 */
Vec2.prototype.lengthSquared = function() {
  return Vec2.lengthSquared(this);
}

/**
 * Convert this vector into a unit vector.
 * 
 * @returns old length
 */
Vec2.prototype.normalize = function() {
  var length = this.length();
  if (length < Math.EPSILON) {
    return 0.0;
  }
  var invLength = 1.0 / length;
  this.x *= invLength;
  this.y *= invLength;
  return length;
}

/**
 * Get the length of this vector (the norm).
 *
 * For performance, use this instead of lengthSquared (if possible).
 */
Vec2.lengthOf = function(v) {
  _ASSERT && Vec2.assert(v);
  return Math.sqrt(v.x * v.x + v.y * v.y);
}

/**
 * Get the length squared.
 */
Vec2.lengthSquared = function(v) {
  _ASSERT && Vec2.assert(v);
  return v.x * v.x + v.y * v.y;
}

Vec2.distance = function(v, w) {
  _ASSERT && Vec2.assert(v);
  _ASSERT && Vec2.assert(w);
  var dx = v.x - w.x, dy = v.y - w.y;
  return Math.sqrt(dx * dx + dy * dy);
}

Vec2.distanceSquared = function(v, w) {
  _ASSERT && Vec2.assert(v);
  _ASSERT && Vec2.assert(w);
  var dx = v.x - w.x, dy = v.y - w.y;
  return dx * dx + dy * dy;
}

Vec2.areEqual = function(v, w) {
  _ASSERT && Vec2.assert(v);
  _ASSERT && Vec2.assert(w);
  return v == w || typeof w === 'object' && w !== null && v.x === w.x && v.y === w.y;
}

/**
 * Get the skew vector such that dot(skew_vec, other) == cross(vec, other)
 */
Vec2.skew = function(v) {
  _ASSERT && Vec2.assert(v);
  return Vec2.neo(-v.y, v.x);
}

/**
 * Perform the dot product on two vectors.
 */
Vec2.dot = function(v, w) {
  _ASSERT && Vec2.assert(v);
  _ASSERT && Vec2.assert(w);
  return v.x * w.x + v.y * w.y;
}

/**
 * Perform the cross product on two vectors. In 2D this produces a scalar.
 * 
 * Perform the cross product on a vector and a scalar. In 2D this produces a
 * vector.
 */
Vec2.cross = function(v, w) {
  if (typeof w === 'number') {
    _ASSERT && Vec2.assert(v);
    _ASSERT && Math.assert(w);
    return Vec2.neo(w * v.y, -w * v.x);

  } else if (typeof v === 'number') {
    _ASSERT && Math.assert(v);
    _ASSERT && Vec2.assert(w);
    return Vec2.neo(-v * w.y, v * w.x);

  } else {
    _ASSERT && Vec2.assert(v);
    _ASSERT && Vec2.assert(w);
    return v.x * w.y - v.y * w.x
  }
}

/**
 * Returns `a + (v x w)`
 */
Vec2.addCross = function(a, v, w) {
  if (typeof w === 'number') {
    _ASSERT && Vec2.assert(v);
    _ASSERT && Math.assert(w);
    return Vec2.neo(w * v.y + a.x, -w * v.x + a.y);

  } else if (typeof v === 'number') {
    _ASSERT && Math.assert(v);
    _ASSERT && Vec2.assert(w);
    return Vec2.neo(-v * w.y + a.x, v * w.x + a.y);
  }

  _ASSERT && common.assert(false);
}

Vec2.add = function(v, w) {
  _ASSERT && Vec2.assert(v);
  _ASSERT && Vec2.assert(w);
  return Vec2.neo(v.x + w.x, v.y + w.y);
}

/**
 * @deprecated Use combine
 */
Vec2.wAdd = function(a, v, b, w) {
  if (typeof b !== 'undefined' || typeof w !== 'undefined') {
    return Vec2.combine(a, v, b, w);
  } else {
    return Vec2.mul(a, v);
  }
}

Vec2.combine = function(a, v, b, w) {
  return Vec2.zero().setCombine(a, v, b, w);
}

Vec2.sub = function(v, w) {
  _ASSERT && Vec2.assert(v);
  _ASSERT && Vec2.assert(w);
  return Vec2.neo(v.x - w.x, v.y - w.y);
}

Vec2.mul = function(a, b) {
  if (typeof a === 'object') {
    _ASSERT && Vec2.assert(a);
    _ASSERT && Math.assert(b);
    return Vec2.neo(a.x * b, a.y * b);

  } else if (typeof b === 'object') {
    _ASSERT && Math.assert(a);
    _ASSERT && Vec2.assert(b);
    return Vec2.neo(a * b.x, a * b.y);
  }
}

Vec2.prototype.neg = function() {
  this.x = -this.x;
  this.y = -this.y;
  return this;
}

Vec2.neg = function(v) {
  _ASSERT && Vec2.assert(v);
  return Vec2.neo(-v.x, -v.y);
}

Vec2.abs = function(v) {
  _ASSERT && Vec2.assert(v);
  return Vec2.neo(Math.abs(v.x), Math.abs(v.y));
}

Vec2.mid = function(v, w) {
  _ASSERT && Vec2.assert(v);
  _ASSERT && Vec2.assert(w);
  return Vec2.neo((v.x + w.x) * 0.5, (v.y + w.y) * 0.5);
}

Vec2.upper = function(v, w) {
  _ASSERT && Vec2.assert(v);
  _ASSERT && Vec2.assert(w);
  return Vec2.neo(Math.max(v.x, w.x), Math.max(v.y, w.y));
}

Vec2.lower = function(v, w) {
  _ASSERT && Vec2.assert(v);
  _ASSERT && Vec2.assert(w);
  return Vec2.neo(Math.min(v.x, w.x), Math.min(v.y, w.y));
}

Vec2.prototype.clamp = function(max) {
  var lengthSqr = this.x * this.x + this.y * this.y;
  if (lengthSqr > max * max) {
    var invLength = Math.invSqrt(lengthSqr);
    this.x *= invLength * max;
    this.y *= invLength * max;
  }
  return this;
}

Vec2.clamp = function(v, max) {
  v = Vec2.neo(v.x, v.y);
  v.clamp(max);
  return v;
}

/**
 * @experimental
 */
Vec2.scaleFn = function (x, y) {
  return function (v) {
    return Vec2.neo(v.x * x, v.y * y);
  };
}

/**
 * @experimental
 */
Vec2.translateFn = function(x, y) {
  return function (v) {
    return Vec2.neo(v.x + x, v.y + y);
  };
}


/***/ }),
/* 63 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

var common = __webpack_require__(61);
var create = __webpack_require__(64);
var native = Math;
var math = module.exports = create(native);

math.EPSILON = 1e-9; // TODO

/**
 * This function is used to ensure that a floating point number is not a NaN or
 * infinity.
 */
math.isFinite = function(x) {
  return (typeof x === 'number') && isFinite(x) && !isNaN(x);
}

math.assert = function(x) {
  if (!_ASSERT) return;
  if (!math.isFinite(x)) {
    _DEBUG && common.debug(x);
    throw new Error('Invalid Number!');
  }
}

/**
 * TODO: This is a approximate yet fast inverse square-root.
 */
math.invSqrt = function(x) {
  // TODO
  return 1 / native.sqrt(x);
}

/**
 * Next Largest Power of 2 Given a binary integer value x, the next largest
 * power of 2 can be computed by a SWAR algorithm that recursively "folds" the
 * upper bits into the lower bits. This process yields a bit vector with the
 * same most significant 1 as x, but all 1's below it. Adding 1 to that value
 * yields the next largest power of 2. For a 32-bit value:
 */
math.nextPowerOfTwo = function(x) {
  // TODO
  x |= (x >> 1);
  x |= (x >> 2);
  x |= (x >> 4);
  x |= (x >> 8);
  x |= (x >> 16);
  return x + 1;
}

math.isPowerOfTwo = function(x) {
  return x > 0 && (x & (x - 1)) == 0;
}

math.mod = function(num, min, max) {
  if (typeof min === 'undefined') {
    max = 1, min = 0;
  } else if (typeof max === 'undefined') {
    max = min, min = 0;
  }
  if (max > min) {
    num = (num - min) % (max - min);
    return num + (num < 0 ? max : min);
  } else {
    num = (num - max) % (min - max);
    return num + (num <= 0 ? min : max);
  }
};

math.clamp = function(num, min, max) {
  if (num < min) {
    return min;
  } else if (num > max) {
    return max;
  } else {
    return num;
  }
};

math.random = function(min, max) {
  if (typeof min === 'undefined') {
    max = 1;
    min = 0;
  } else if (typeof max === 'undefined') {
    max = min;
    min = 0;
  }
  return min == max ? min : native.random() * (max - min) + min;
};


/***/ }),
/* 64 */
/***/ ((module) => {

if (typeof Object.create == 'function') {
  module.exports = function(proto, props) {
    return Object.create.call(Object, proto, props);
  };
} else {
  module.exports = function(proto, props) {
    if (props)
      throw Error('Second argument is not supported!');
    if (typeof proto !== 'object' || proto === null)
      throw Error('Invalid prototype!');
    noop.prototype = proto;
    return new noop;
  };
  function noop() {
  }
}


/***/ }),
/* 65 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

var Settings = __webpack_require__(66);
var common = __webpack_require__(61);
var Math = __webpack_require__(63);
var AABB = __webpack_require__(67);
var DynamicTree = __webpack_require__(68);

module.exports = BroadPhase;

/**
 * The broad-phase wraps and extends a dynamic-tree to keep track of moved
 * objects and query them on update.
 */
function BroadPhase() {
  this.m_tree = new DynamicTree();
  this.m_proxyCount = 0;
  this.m_moveBuffer = [];
  this.queryCallback = this.queryCallback.bind(this);
};

/**
 * Get user data from a proxy. Returns null if the id is invalid.
 */
BroadPhase.prototype.getUserData = function(proxyId) {
  return this.m_tree.getUserData(proxyId);
}

/**
 * Test overlap of fat AABBs.
 */
BroadPhase.prototype.testOverlap = function(proxyIdA, proxyIdB) {
  var aabbA = this.m_tree.getFatAABB(proxyIdA);
  var aabbB = this.m_tree.getFatAABB(proxyIdB);
  return AABB.testOverlap(aabbA, aabbB);
}

/**
 * Get the fat AABB for a proxy.
 */
BroadPhase.prototype.getFatAABB = function(proxyId) {
  return this.m_tree.getFatAABB(proxyId);
}

/**
 * Get the number of proxies.
 */
BroadPhase.prototype.getProxyCount = function() {
  return this.m_proxyCount;
}

/**
 * Get the height of the embedded tree.
 */
BroadPhase.prototype.getTreeHeight = function() {
  return this.m_tree.getHeight();
}

/**
 * Get the balance (integer) of the embedded tree.
 */
BroadPhase.prototype.getTreeBalance = function() {
  return this.m_tree.getMaxBalance();
}

/**
 * Get the quality metric of the embedded tree.
 */
BroadPhase.prototype.getTreeQuality = function() {
  return this.m_tree.getAreaRatio();
}

/**
 * Query an AABB for overlapping proxies. The callback class is called for each
 * proxy that overlaps the supplied AABB.
 */
BroadPhase.prototype.query = function(aabb, queryCallback) {
  this.m_tree.query(aabb, queryCallback);
}

/**
 * Ray-cast against the proxies in the tree. This relies on the callback to
 * perform a exact ray-cast in the case were the proxy contains a shape. The
 * callback also performs the any collision filtering. This has performance
 * roughly equal to k * log(n), where k is the number of collisions and n is the
 * number of proxies in the tree.
 * 
 * @param input The ray-cast input data. The ray extends from p1 to p1 +
 *          maxFraction * (p2 - p1).
 * @param rayCastCallback A function that is called for each proxy that is hit by
 *          the ray.
 */
BroadPhase.prototype.rayCast = function(input, rayCastCallback) {
  this.m_tree.rayCast(input, rayCastCallback);
}

/**
 * Shift the world origin. Useful for large worlds. The shift formula is:
 * position -= newOrigin
 * 
 * @param newOrigin The new origin with respect to the old origin
 */
BroadPhase.prototype.shiftOrigin = function(newOrigin) {
  this.m_tree.shiftOrigin(newOrigin);
}

/**
 * Create a proxy with an initial AABB. Pairs are not reported until UpdatePairs
 * is called.
 */
BroadPhase.prototype.createProxy = function(aabb, userData) {
  _ASSERT && common.assert(AABB.isValid(aabb));
  var proxyId = this.m_tree.createProxy(aabb, userData);
  this.m_proxyCount++;
  this.bufferMove(proxyId);
  return proxyId;
}

/**
 * Destroy a proxy. It is up to the client to remove any pairs.
 */
BroadPhase.prototype.destroyProxy = function(proxyId) {
  this.unbufferMove(proxyId);
  this.m_proxyCount--;
  this.m_tree.destroyProxy(proxyId);
}

/**
 * Call moveProxy as many times as you like, then when you are done call
 * UpdatePairs to finalized the proxy pairs (for your time step).
 */
BroadPhase.prototype.moveProxy = function(proxyId, aabb, displacement) {
  _ASSERT && common.assert(AABB.isValid(aabb));
  var changed = this.m_tree.moveProxy(proxyId, aabb, displacement);
  if (changed) {
    this.bufferMove(proxyId);
  }
}

/**
 * Call to trigger a re-processing of it's pairs on the next call to
 * UpdatePairs.
 */
BroadPhase.prototype.touchProxy = function(proxyId) {
  this.bufferMove(proxyId);
}

BroadPhase.prototype.bufferMove = function(proxyId) {
  this.m_moveBuffer.push(proxyId);
}

BroadPhase.prototype.unbufferMove = function(proxyId) {
  for (var i = 0; i < this.m_moveBuffer.length; ++i) {
    if (this.m_moveBuffer[i] == proxyId) {
      this.m_moveBuffer[i] = null;
    }
  }
}

/**
 * @function BroadPhase~addPair
 * @param {Object} userDataA
 * @param {Object} userDataB
 */

/**
 * Update the pairs. This results in pair callbacks. This can only add pairs.
 * 
 * @param {BroadPhase~AddPair} addPairCallback
 */
BroadPhase.prototype.updatePairs = function(addPairCallback) {
  _ASSERT && common.assert(typeof addPairCallback === 'function');
  this.m_callback = addPairCallback;

  // Perform tree queries for all moving proxies.
  while (this.m_moveBuffer.length > 0) {
    this.m_queryProxyId = this.m_moveBuffer.pop();
    if (this.m_queryProxyId === null) {
      continue;
    }

    // We have to query the tree with the fat AABB so that
    // we don't fail to create a pair that may touch later.
    var fatAABB = this.m_tree.getFatAABB(this.m_queryProxyId);

    // Query tree, create pairs and add them pair buffer.
    this.m_tree.query(fatAABB, this.queryCallback);
  }

  // Try to keep the tree balanced.
  // this.m_tree.rebalance(4);
}

BroadPhase.prototype.queryCallback = function(proxyId) {
  // A proxy cannot form a pair with itself.
  if (proxyId == this.m_queryProxyId) {
    return true;
  }

  var proxyIdA = Math.min(proxyId, this.m_queryProxyId);
  var proxyIdB = Math.max(proxyId, this.m_queryProxyId);

  // TODO: Skip any duplicate pairs.

  var userDataA = this.m_tree.getUserData(proxyIdA);
  var userDataB = this.m_tree.getUserData(proxyIdB);

  // Send the pairs back to the client.
  this.m_callback(userDataA, userDataB);

  return true;
}


/***/ }),
/* 66 */
/***/ ((__unused_webpack_module, exports) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

// TODO merge with World options?

var Settings = exports;

/**
 * Tuning constants based on meters-kilograms-seconds (MKS) units.
 */

// Collision
/**
 * The maximum number of contact points between two convex shapes. Do not change
 * this value.
 */
Settings.maxManifoldPoints = 2;

/**
 * The maximum number of vertices on a convex polygon. You cannot increase this
 * too much because BlockAllocator has a maximum object size.
 */
Settings.maxPolygonVertices = 12;

/**
 * This is used to fatten AABBs in the dynamic tree. This allows proxies to move
 * by a small amount without triggering a tree adjustment. This is in meters.
 */
Settings.aabbExtension = 0.1;

/**
 * This is used to fatten AABBs in the dynamic tree. This is used to predict the
 * future position based on the current displacement. This is a dimensionless
 * multiplier.
 */
Settings.aabbMultiplier = 2.0;

/**
 * A small length used as a collision and constraint tolerance. Usually it is
 * chosen to be numerically significant, but visually insignificant.
 */
Settings.linearSlop = 0.005;
Settings.linearSlopSquared = Settings.linearSlop * Settings.linearSlop;

/**
 * A small angle used as a collision and constraint tolerance. Usually it is
 * chosen to be numerically significant, but visually insignificant.
 */
Settings.angularSlop = (2.0 / 180.0 * Math.PI);

/**
 * The radius of the polygon/edge shape skin. This should not be modified.
 * Making this smaller means polygons will have an insufficient buffer for
 * continuous collision. Making it larger may create artifacts for vertex
 * collision.
 */
Settings.polygonRadius = (2.0 * Settings.linearSlop);

/**
 * Maximum number of sub-steps per contact in continuous physics simulation.
 */
Settings.maxSubSteps = 8;

// Dynamics

/**
 * Maximum number of contacts to be handled to solve a TOI impact.
 */
Settings.maxTOIContacts = 32;

/**
 * Maximum iterations to solve a TOI.
 */
Settings.maxTOIIterations = 20;

/**
 * Maximum iterations to find Distance.
 */
Settings.maxDistnceIterations = 20;

/**
 * A velocity threshold for elastic collisions. Any collision with a relative
 * linear velocity below this threshold will be treated as inelastic.
 */
Settings.velocityThreshold = 1.0;

/**
 * The maximum linear position correction used when solving constraints. This
 * helps to prevent overshoot.
 */
Settings.maxLinearCorrection = 0.2;

/**
 * The maximum angular position correction used when solving constraints. This
 * helps to prevent overshoot.
 */
Settings.maxAngularCorrection = (8.0 / 180.0 * Math.PI);

/**
 * The maximum linear velocity of a body. This limit is very large and is used
 * to prevent numerical problems. You shouldn't need to adjust this.
 */
Settings.maxTranslation = 2.0;
Settings.maxTranslationSquared = (Settings.maxTranslation * Settings.maxTranslation);

/**
 * The maximum angular velocity of a body. This limit is very large and is used
 * to prevent numerical problems. You shouldn't need to adjust this.
 */
Settings.maxRotation = (0.5 * Math.PI)
Settings.maxRotationSquared = (Settings.maxRotation * Settings.maxRotation)

/**
 * This scale factor controls how fast overlap is resolved. Ideally this would
 * be 1 so that overlap is removed in one time step. However using values close
 * to 1 often lead to overshoot.
 */
Settings.baumgarte = 0.2;
Settings.toiBaugarte = 0.75;

// Sleep

/**
 * The time that a body must be still before it will go to sleep.
 */
Settings.timeToSleep = 0.5;

/**
 * A body cannot sleep if its linear velocity is above this tolerance.
 */
Settings.linearSleepTolerance = 0.01;

Settings.linearSleepToleranceSqr = Math.pow(Settings.linearSleepTolerance, 2);

/**
 * A body cannot sleep if its angular velocity is above this tolerance.
 */
Settings.angularSleepTolerance = (2.0 / 180.0 * Math.PI);

Settings.angularSleepToleranceSqr = Math.pow(Settings.angularSleepTolerance, 2);



/***/ }),
/* 67 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

var Settings = __webpack_require__(66);
var common = __webpack_require__(61);
var Math = __webpack_require__(63);
var Vec2 = __webpack_require__(62);

module.exports = AABB;

function AABB(lower, upper) {
  if (!(this instanceof AABB)) {
    return new AABB(lower, upper);
  }

  this.lowerBound = Vec2.zero();
  this.upperBound = Vec2.zero();

  if (typeof lower === 'object') {
    this.lowerBound.set(lower);
  }
  if (typeof upper === 'object') {
    this.upperBound.set(upper);
  } else if (typeof lower === 'object') {
    this.upperBound.set(lower);
  }
};

/**
 * Verify that the bounds are sorted.
 */
AABB.prototype.isValid = function() {
  return AABB.isValid(this);
}

AABB.isValid = function(aabb) {
  var d = Vec2.sub(aabb.upperBound, aabb.lowerBound);
  var valid = d.x >= 0.0 && d.y >= 0.0 && Vec2.isValid(aabb.lowerBound) && Vec2.isValid(aabb.upperBound);
  return valid;
}

AABB.assert = function(o) {
  if (!_ASSERT) return;
  if (!AABB.isValid(o)) {
    _DEBUG && common.debug(o);
    throw new Error('Invalid AABB!');
  }
}

/**
 * Get the center of the AABB.
 */
AABB.prototype.getCenter = function() {
  return Vec2.neo((this.lowerBound.x + this.upperBound.x) * 0.5, (this.lowerBound.y + this.upperBound.y) * 0.5);
}

/**
 * Get the extents of the AABB (half-widths).
 */
AABB.prototype.getExtents = function() {
  return Vec2.neo((this.upperBound.x - this.lowerBound.x) * 0.5, (this.upperBound.y - this.lowerBound.y) * 0.5);
}

/**
 * Get the perimeter length.
 */
AABB.prototype.getPerimeter = function() {
  return 2.0 * (this.upperBound.x - this.lowerBound.x + this.upperBound.y - this.lowerBound.y);
}

/**
 * Combine one or two AABB into this one.
 */
AABB.prototype.combine = function(a, b) {
  b = b || this;

  var lowerA = a.lowerBound;
  var upperA = a.upperBound;
  var lowerB = b.lowerBound;
  var upperB = b.upperBound;

  var lowerX = Math.min(lowerA.x, lowerB.x);
  var lowerY = Math.min(lowerA.y, lowerB.y);
  var upperX = Math.max(upperB.x, upperA.x);
  var upperY = Math.max(upperB.y, upperA.y);

  this.lowerBound.set(lowerX, lowerY);
  this.upperBound.set(upperX, upperY);
}

AABB.prototype.combinePoints = function(a, b) {
  this.lowerBound.set(Math.min(a.x, b.x), Math.min(a.y, b.y));
  this.upperBound.set(Math.max(a.x, b.x), Math.max(a.y, b.y));
}

AABB.prototype.set = function(aabb) {
  this.lowerBound.set(aabb.lowerBound.x, aabb.lowerBound.y);
  this.upperBound.set(aabb.upperBound.x, aabb.upperBound.y);
}

AABB.prototype.contains = function(aabb) {
  var result = true;
  result = result && this.lowerBound.x <= aabb.lowerBound.x;
  result = result && this.lowerBound.y <= aabb.lowerBound.y;
  result = result && aabb.upperBound.x <= this.upperBound.x;
  result = result && aabb.upperBound.y <= this.upperBound.y;
  return result;
}

AABB.prototype.extend = function(value) {
  AABB.extend(this, value);
  return this;
}

AABB.extend = function(aabb, value) {
  aabb.lowerBound.x -= value;
  aabb.lowerBound.y -= value;
  aabb.upperBound.x += value;
  aabb.upperBound.y += value;
}

AABB.testOverlap = function(a, b) {
  var d1x = b.lowerBound.x - a.upperBound.x;
  var d2x = a.lowerBound.x - b.upperBound.x;

  var d1y = b.lowerBound.y - a.upperBound.y;
  var d2y = a.lowerBound.y - b.upperBound.y;

  if (d1x > 0 || d1y > 0 || d2x > 0 || d2y > 0) {
    return false;
  }
  return true;
}

AABB.areEqual = function(a, b) {
  return Vec2.areEqual(a.lowerBound, b.lowerBound) && Vec2.areEqual(a.upperBound, b.upperBound);
}

AABB.diff = function(a, b) {
  var wD = Math.max(0, Math.min(a.upperBound.x, b.upperBound.x) - Math.max(b.lowerBound.x, a.lowerBound.x))
  var hD = Math.max(0, Math.min(a.upperBound.y, b.upperBound.y) - Math.max(b.lowerBound.y, a.lowerBound.y));

  var wA = a.upperBound.x - a.lowerBound.x;
  var hA = a.upperBound.y - a.lowerBound.y;

  var wB = b.upperBound.x - b.lowerBound.x;
  var hB = b.upperBound.y - b.lowerBound.y;

  return wA * hA + wB * hB - wD * hD;
};

/**
 * @typedef RayCastInput
 *
 * Ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).
 *
 * @prop {Vec2} p1
 * @prop {Vec2} p2
 * @prop {number} maxFraction
 */

/**
 * @typedef RayCastInput
 *
 * Ray-cast output data. The ray hits at p1 + fraction * (p2 - p1), where p1 and
 * p2 come from RayCastInput.
 *
 * @prop {Vec2} normal
 * @prop {number} fraction
 */

/**
 * @param {RayCastOutput} output
 * @param {RayCastInput} input
 * @returns {boolean}
 */
AABB.prototype.rayCast = function(output, input) {
  // From Real-time Collision Detection, p179.

  var tmin = -Infinity;
  var tmax = Infinity;

  var p = input.p1;
  var d = Vec2.sub(input.p2, input.p1);
  var absD = Vec2.abs(d);

  var normal = Vec2.zero();

  for (var f = 'x'; f !== null; f = (f === 'x' ? 'y' : null)) {
    if (absD.x < Math.EPSILON) {
      // Parallel.
      if (p[f] < this.lowerBound[f] || this.upperBound[f] < p[f]) {
        return false;
      }
    } else {
      var inv_d = 1.0 / d[f];
      var t1 = (this.lowerBound[f] - p[f]) * inv_d;
      var t2 = (this.upperBound[f] - p[f]) * inv_d;

      // Sign of the normal vector.
      var s = -1.0;

      if (t1 > t2) {
        var temp = t1;
        t1 = t2, t2 = temp;
        s = 1.0;
      }

      // Push the min up
      if (t1 > tmin) {
        normal.setZero();
        normal[f] = s;
        tmin = t1;
      }

      // Pull the max down
      tmax = Math.min(tmax, t2);

      if (tmin > tmax) {
        return false;
      }
    }
  }

  // Does the ray start inside the box?
  // Does the ray intersect beyond the max fraction?
  if (tmin < 0.0 || input.maxFraction < tmin) {
    return false;
  }

  // Intersection.
  output.fraction = tmin;
  output.normal = normal;
  return true;
}

AABB.prototype.toString = function() {
  return JSON.stringify(this);
}


/***/ }),
/* 68 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

var Settings = __webpack_require__(66);
var common = __webpack_require__(61);
var Pool = __webpack_require__(69);
var Vec2 = __webpack_require__(62);
var Math = __webpack_require__(63);
var AABB = __webpack_require__(67);

module.exports = DynamicTree;

/**
 * A node in the dynamic tree. The client does not interact with this directly.
 * 
 * @prop {AABB} aabb Enlarged AABB
 * @prop {integer} height 0: leaf, -1: free node
 */
function TreeNode(id) {
  this.id = id;
  this.aabb = new AABB();
  this.userData = null;
  this.parent = null;
  this.child1 = null;
  this.child2 = null;
  this.height = -1;

  this.toString = function() {
    return this.id + ": " + this.userData;
  }
};

TreeNode.prototype.isLeaf = function() {
  return this.child1 == null;
}
/**
 * A dynamic AABB tree broad-phase, inspired by Nathanael Presson's btDbvt. A
 * dynamic tree arranges data in a binary tree to accelerate queries such as
 * volume queries and ray casts. Leafs are proxies with an AABB. In the tree we
 * expand the proxy AABB by `aabbExtension` so that the proxy AABB is bigger
 * than the client object. This allows the client object to move by small
 * amounts without triggering a tree update.
 * 
 * Nodes are pooled and relocatable, so we use node indices rather than
 * pointers.
 */
function DynamicTree() {
  this.m_root = null;
  this.m_nodes = {}
  this.m_lastProxyId = 0;

  this.m_pool = new Pool({
    create : function() {
      return new TreeNode();
    }
  });
};

/**
 * Get proxy user data.
 * 
 * @return the proxy user data or 0 if the id is invalid.
 */
DynamicTree.prototype.getUserData = function(id) {
  var node = this.m_nodes[id];
  _ASSERT && common.assert(!!node);
  return node.userData;
}

/**
 * Get the fat AABB for a node id.
 * 
 * @return the proxy user data or 0 if the id is invalid.
 */
DynamicTree.prototype.getFatAABB = function(id) {
  var node = this.m_nodes[id];
  _ASSERT && common.assert(!!node);
  return node.aabb;
}

DynamicTree.prototype.allocateNode = function() {
  var node = this.m_pool.allocate();
  node.id = ++this.m_lastProxyId;
  node.userData = null;
  node.parent = null;
  node.child1 = null;
  node.child2 = null;
  node.height = -1;
  this.m_nodes[node.id] = node;
  return node;
}

DynamicTree.prototype.freeNode = function(node) {
  this.m_pool.release(node);
  node.height = -1;
  delete this.m_nodes[node.id];
}

/**
 * Create a proxy in the tree as a leaf node. We return the index of the node
 * instead of a pointer so that we can grow the node pool.
 * 
 * Create a proxy. Provide a tight fitting AABB and a userData pointer.
 */
DynamicTree.prototype.createProxy = function(aabb, userData) {
  _ASSERT && common.assert(AABB.isValid(aabb))

  var node = this.allocateNode()

  node.aabb.set(aabb);

  // Fatten the aabb.
  AABB.extend(node.aabb, Settings.aabbExtension);

  node.userData = userData;
  node.height = 0;

  this.insertLeaf(node);

  return node.id;
}

/**
 * Destroy a proxy. This asserts if the id is invalid.
 */
DynamicTree.prototype.destroyProxy = function(id) {
  var node = this.m_nodes[id];

  _ASSERT && common.assert(!!node);
  _ASSERT && common.assert(node.isLeaf());

  this.removeLeaf(node);
  this.freeNode(node);
}

/**
 * Move a proxy with a swepted AABB. If the proxy has moved outside of its
 * fattened AABB, then the proxy is removed from the tree and re-inserted.
 * Otherwise the function returns immediately.
 * 
 * @param id
 * @param aabb
 * @param {Vec2} d Displacement
 * 
 * @return true if the proxy was re-inserted.
 */
DynamicTree.prototype.moveProxy = function(id, aabb, d) {
  _ASSERT && common.assert(AABB.isValid(aabb));
  _ASSERT && common.assert(!d || Vec2.isValid(d));

  var node = this.m_nodes[id];

  _ASSERT && common.assert(!!node);
  _ASSERT && common.assert(node.isLeaf());

  if (node.aabb.contains(aabb)) {
    return false;
  }

  this.removeLeaf(node);

  node.aabb.set(aabb)

  // Extend AABB.
  aabb = node.aabb;
  AABB.extend(aabb, Settings.aabbExtension);

  // Predict AABB displacement.
  // var d = Vec2.mul(Settings.aabbMultiplier, displacement);

  if (d.x < 0.0) {
    aabb.lowerBound.x += d.x * Settings.aabbMultiplier;
  } else {
    aabb.upperBound.x += d.x * Settings.aabbMultiplier;
  }

  if (d.y < 0.0) {
    aabb.lowerBound.y += d.y * Settings.aabbMultiplier;
  } else {
    aabb.upperBound.y += d.y * Settings.aabbMultiplier;
  }

  this.insertLeaf(node);

  return true;
}

DynamicTree.prototype.insertLeaf = function(leaf) {
  _ASSERT && common.assert(AABB.isValid(leaf.aabb));

  if (this.m_root == null) {
    this.m_root = leaf;
    this.m_root.parent = null;
    return;
  }

  // Find the best sibling for this node
  var leafAABB = leaf.aabb;
  var index = this.m_root;
  while (index.isLeaf() == false) {
    var child1 = index.child1;
    var child2 = index.child2;

    var area = index.aabb.getPerimeter();

    var combinedAABB = new AABB();
    combinedAABB.combine(index.aabb, leafAABB);
    var combinedArea = combinedAABB.getPerimeter();

    // Cost of creating a new parent for this node and the new leaf
    var cost = 2.0 * combinedArea;

    // Minimum cost of pushing the leaf further down the tree
    var inheritanceCost = 2.0 * (combinedArea - area);

    // Cost of descending into child1
    var cost1;
    if (child1.isLeaf()) {
      var aabb = new AABB();
      aabb.combine(leafAABB, child1.aabb);
      cost1 = aabb.getPerimeter() + inheritanceCost;
    } else {
      var aabb = new AABB();
      aabb.combine(leafAABB, child1.aabb);
      var oldArea = child1.aabb.getPerimeter();
      var newArea = aabb.getPerimeter();
      cost1 = (newArea - oldArea) + inheritanceCost;
    }

    // Cost of descending into child2
    var cost2;
    if (child2.isLeaf()) {
      var aabb = new AABB();
      aabb.combine(leafAABB, child2.aabb);
      cost2 = aabb.getPerimeter() + inheritanceCost;
    } else {
      var aabb = new AABB();
      aabb.combine(leafAABB, child2.aabb);
      var oldArea = child2.aabb.getPerimeter();
      var newArea = aabb.getPerimeter();
      cost2 = newArea - oldArea + inheritanceCost;
    }

    // Descend according to the minimum cost.
    if (cost < cost1 && cost < cost2) {
      break;
    }

    // Descend
    if (cost1 < cost2) {
      index = child1;
    } else {
      index = child2;
    }
  }

  var sibling = index;

  // Create a new parent.
  var oldParent = sibling.parent;
  var newParent = this.allocateNode();
  newParent.parent = oldParent;
  newParent.userData = null;
  newParent.aabb.combine(leafAABB, sibling.aabb);
  newParent.height = sibling.height + 1;

  if (oldParent != null) {
    // The sibling was not the root.
    if (oldParent.child1 == sibling) {
      oldParent.child1 = newParent;
    } else {
      oldParent.child2 = newParent;
    }

    newParent.child1 = sibling;
    newParent.child2 = leaf;
    sibling.parent = newParent;
    leaf.parent = newParent;
  } else {
    // The sibling was the root.
    newParent.child1 = sibling;
    newParent.child2 = leaf;
    sibling.parent = newParent;
    leaf.parent = newParent;
    this.m_root = newParent;
  }

  // Walk back up the tree fixing heights and AABBs
  index = leaf.parent;
  while (index != null) {
    index = this.balance(index);

    var child1 = index.child1;
    var child2 = index.child2;

    _ASSERT && common.assert(child1 != null);
    _ASSERT && common.assert(child2 != null);

    index.height = 1 + Math.max(child1.height, child2.height);
    index.aabb.combine(child1.aabb, child2.aabb);

    index = index.parent;
  }

  // validate();
}

DynamicTree.prototype.removeLeaf = function(leaf) {
  if (leaf == this.m_root) {
    this.m_root = null;
    return;
  }

  var parent = leaf.parent;
  var grandParent = parent.parent;
  var sibling;
  if (parent.child1 == leaf) {
    sibling = parent.child2;
  } else {
    sibling = parent.child1;
  }

  if (grandParent != null) {
    // Destroy parent and connect sibling to grandParent.
    if (grandParent.child1 == parent) {
      grandParent.child1 = sibling;
    } else {
      grandParent.child2 = sibling;
    }
    sibling.parent = grandParent;
    this.freeNode(parent);

    // Adjust ancestor bounds.
    var index = grandParent;
    while (index != null) {
      index = this.balance(index);

      var child1 = index.child1;
      var child2 = index.child2;

      index.aabb.combine(child1.aabb, child2.aabb);
      index.height = 1 + Math.max(child1.height, child2.height);

      index = index.parent;
    }
  } else {
    this.m_root = sibling;
    sibling.parent = null;
    this.freeNode(parent);
  }

  // validate();
}

/**
 * Perform a left or right rotation if node A is imbalanced. Returns the new
 * root index.
 */
DynamicTree.prototype.balance = function(iA) {
  _ASSERT && common.assert(iA != null);

  var A = iA;
  if (A.isLeaf() || A.height < 2) {
    return iA;
  }

  var B = A.child1;
  var C = A.child2;

  var balance = C.height - B.height;

  // Rotate C up
  if (balance > 1) {
    var F = C.child1;
    var G = C.child2;

    // Swap A and C
    C.child1 = A;
    C.parent = A.parent;
    A.parent = C;

    // A's old parent should point to C
    if (C.parent != null) {
      if (C.parent.child1 == iA) {
        C.parent.child1 = C;
      } else {
        C.parent.child2 = C;
      }
    } else {
      this.m_root = C;
    }

    // Rotate
    if (F.height > G.height) {
      C.child2 = F;
      A.child2 = G;
      G.parent = A;
      A.aabb.combine(B.aabb, G.aabb);
      C.aabb.combine(A.aabb, F.aabb);

      A.height = 1 + Math.max(B.height, G.height);
      C.height = 1 + Math.max(A.height, F.height);
    } else {
      C.child2 = G;
      A.child2 = F;
      F.parent = A;
      A.aabb.combine(B.aabb, F.aabb);
      C.aabb.combine(A.aabb, G.aabb);

      A.height = 1 + Math.max(B.height, F.height);
      C.height = 1 + Math.max(A.height, G.height);
    }

    return C;
  }

  // Rotate B up
  if (balance < -1) {
    var D = B.child1;
    var E = B.child2;

    // Swap A and B
    B.child1 = A;
    B.parent = A.parent;
    A.parent = B;

    // A's old parent should point to B
    if (B.parent != null) {
      if (B.parent.child1 == A) {
        B.parent.child1 = B;
      } else {
        B.parent.child2 = B;
      }
    } else {
      this.m_root = B;
    }

    // Rotate
    if (D.height > E.height) {
      B.child2 = D;
      A.child1 = E;
      E.parent = A;
      A.aabb.combine(C.aabb, E.aabb);
      B.aabb.combine(A.aabb, D.aabb);

      A.height = 1 + Math.max(C.height, E.height);
      B.height = 1 + Math.max(A.height, D.height);
    } else {
      B.child2 = E;
      A.child1 = D;
      D.parent = A;
      A.aabb.combine(C.aabb, D.aabb);
      B.aabb.combine(A.aabb, E.aabb);

      A.height = 1 + Math.max(C.height, D.height);
      B.height = 1 + Math.max(A.height, E.height);
    }

    return B;
  }

  return A;
}

/**
 * Compute the height of the binary tree in O(N) time. Should not be called
 * often.
 */
DynamicTree.prototype.getHeight = function() {
  if (this.m_root == null) {
    return 0;
  }

  return this.m_root.height;
}

/**
 * Get the ratio of the sum of the node areas to the root area.
 */
DynamicTree.prototype.getAreaRatio = function() {
  if (this.m_root == null) {
    return 0.0;
  }

  var root = this.m_root;
  var rootArea = root.aabb.getPerimeter();

  var totalArea = 0.0;
  var node, it = iteratorPool.allocate().preorder(this.m_root);
  while (node = it.next()) {
    if (node.height < 0) {
      // Free node in pool
      continue;
    }

    totalArea += node.aabb.getPerimeter();
  }

  iteratorPool.release(it);

  return totalArea / rootArea;
}

/**
 * Compute the height of a sub-tree.
 */
DynamicTree.prototype.computeHeight = function(id) {
  var node;
  if (typeof id !== 'undefined') {
    node = this.m_nodes[id];
  } else {
    node = this.m_root;
  }

  // _ASSERT && common.assert(0 <= id && id < this.m_nodeCapacity);

  if (node.isLeaf()) {
    return 0;
  }

  var height1 = this.computeHeight(node.child1.id);
  var height2 = this.computeHeight(node.child2.id);
  return 1 + Math.max(height1, height2);
}

DynamicTree.prototype.validateStructure = function(node) {
  if (node == null) {
    return;
  }

  if (node == this.m_root) {
    _ASSERT && common.assert(node.parent == null);
  }

  var child1 = node.child1;
  var child2 = node.child2;

  if (node.isLeaf()) {
    _ASSERT && common.assert(child1 == null);
    _ASSERT && common.assert(child2 == null);
    _ASSERT && common.assert(node.height == 0);
    return;
  }

  // _ASSERT && common.assert(0 <= child1 && child1 < this.m_nodeCapacity);
  // _ASSERT && common.assert(0 <= child2 && child2 < this.m_nodeCapacity);

  _ASSERT && common.assert(child1.parent == node);
  _ASSERT && common.assert(child2.parent == node);

  this.validateStructure(child1);
  this.validateStructure(child2);
}

DynamicTree.prototype.validateMetrics = function(node) {
  if (node == null) {
    return;
  }

  var child1 = node.child1;
  var child2 = node.child2;

  if (node.isLeaf()) {
    _ASSERT && common.assert(child1 == null);
    _ASSERT && common.assert(child2 == null);
    _ASSERT && common.assert(node.height == 0);
    return;
  }

  // _ASSERT && common.assert(0 <= child1 && child1 < this.m_nodeCapacity);
  // _ASSERT && common.assert(0 <= child2 && child2 < this.m_nodeCapacity);

  var height1 = child1.height;
  var height2 = child2.height;
  var height = 1 + Math.max(height1, height2);
  _ASSERT && common.assert(node.height == height);

  var aabb = new AABB();
  aabb.combine(child1.aabb, child2.aabb);

  _ASSERT && common.assert(AABB.areEqual(aabb, node.aabb));

  this.validateMetrics(child1);
  this.validateMetrics(child2);
}

// Validate this tree. For testing.
DynamicTree.prototype.validate = function() {
  this.validateStructure(this.m_root);
  this.validateMetrics(this.m_root);

  _ASSERT && common.assert(this.getHeight() == this.computeHeight());
}

/**
 * Get the maximum balance of an node in the tree. The balance is the difference
 * in height of the two children of a node.
 */
DynamicTree.prototype.getMaxBalance = function() {
  var maxBalance = 0;
  var node, it = iteratorPool.allocate().preorder(this.m_root);
  while (node = it.next()) {
    if (node.height <= 1) {
      continue;
    }

    _ASSERT && common.assert(node.isLeaf() == false);

    var balance = Math.abs(node.child2.height - node.child1.height);
    maxBalance = Math.max(maxBalance, balance);
  }
  iteratorPool.release(it);

  return maxBalance;
}

/**
 * Build an optimal tree. Very expensive. For testing.
 */
DynamicTree.prototype.rebuildBottomUp = function() {
  var nodes = [];
  var count = 0;

  // Build array of leaves. Free the rest.
  var node, it = iteratorPool.allocate().preorder(this.m_root);
  while (node = it.next()) {
    if (node.height < 0) {
      // free node in pool
      continue;
    }

    if (node.isLeaf()) {
      node.parent = null;
      nodes[count] = node;
      ++count;
    } else {
      this.freeNode(node);
    }
  }
  iteratorPool.release(it);

  while (count > 1) {
    var minCost = Infinity;
    var iMin = -1, jMin = -1;
    for (var i = 0; i < count; ++i) {
      var aabbi = nodes[i].aabb;
      for (var j = i + 1; j < count; ++j) {
        var aabbj = nodes[j].aabb;
        var b = new AABB();
        b.combine(aabbi, aabbj);
        var cost = b.getPerimeter();
        if (cost < minCost) {
          iMin = i;
          jMin = j;
          minCost = cost;
        }
      }
    }

    var child1 = nodes[iMin];
    var child2 = nodes[jMin];

    var parent = this.allocateNode();
    parent.child1 = child1;
    parent.child2 = child2;
    parent.height = 1 + Math.max(child1.height, child2.height);
    parent.aabb.combine(child1.aabb, child2.aabb);
    parent.parent = null;

    child1.parent = parent;
    child2.parent = parent;

    nodes[jMin] = nodes[count - 1];
    nodes[iMin] = parent;
    --count;
  }

  this.m_root = nodes[0];

  this.validate();
}

/**
 * Shift the world origin. Useful for large worlds. The shift formula is:
 * position -= newOrigin
 * 
 * @param newOrigin The new origin with respect to the old origin
 */
DynamicTree.prototype.shiftOrigin = function(newOrigin) {
  // Build array of leaves. Free the rest.
  var node, it = iteratorPool.allocate().preorder(this.m_root);
  while (node = it.next()) {
    var aabb = node.aabb;
    aabb.lowerBound.x -= newOrigin.x;
    aabb.lowerBound.y -= newOrigin.y;
    aabb.upperBound.x -= newOrigin.x;
    aabb.upperBound.y -= newOrigin.y;
  }
  iteratorPool.release(it);
}

/**
 * @function {DynamicTree~queryCallback}
 * 
 * @param id Node id.
 */

/**
 * Query an AABB for overlapping proxies. The callback class is called for each
 * proxy that overlaps the supplied AABB.
 * 
 * @param {DynamicTree~queryCallback} queryCallback
 */
DynamicTree.prototype.query = function(aabb, queryCallback) {
  _ASSERT && common.assert(typeof queryCallback === 'function')
  var stack = stackPool.allocate();

  stack.push(this.m_root);
  while (stack.length > 0) {
    var node = stack.pop();
    if (node == null) {
      continue;
    }

    if (AABB.testOverlap(node.aabb, aabb)) {
      if (node.isLeaf()) {
        var proceed = queryCallback(node.id);
        if (proceed == false) {
          return;
        }
      } else {
        stack.push(node.child1);
        stack.push(node.child2);
      }
    }
  }

  stackPool.release(stack);
}

/**
 * Ray-cast against the proxies in the tree. This relies on the callback to
 * perform a exact ray-cast in the case were the proxy contains a shape. The
 * callback also performs the any collision filtering. This has performance
 * roughly equal to k * log(n), where k is the number of collisions and n is the
 * number of proxies in the tree.
 * 
 * @param input The ray-cast input data. The ray extends from p1 to p1 +
 *          maxFraction * (p2 - p1).
 * @param rayCastCallback A function that is called for each proxy that is hit by
 *          the ray.
 */
DynamicTree.prototype.rayCast = function(input, rayCastCallback) { // TODO GC
  _ASSERT && common.assert(typeof rayCastCallback === 'function')
  var p1 = input.p1;
  var p2 = input.p2;
  var r = Vec2.sub(p2, p1);
  _ASSERT && common.assert(r.lengthSquared() > 0.0);
  r.normalize();

  // v is perpendicular to the segment.
  var v = Vec2.cross(1.0, r);
  var abs_v = Vec2.abs(v);

  // Separating axis for segment (Gino, p80).
  // |dot(v, p1 - c)| > dot(|v|, h)

  var maxFraction = input.maxFraction;

  // Build a bounding box for the segment.
  var segmentAABB = new AABB();
  var t = Vec2.combine((1 - maxFraction), p1, maxFraction, p2);
  segmentAABB.combinePoints(p1, t);

  var stack = stackPool.allocate();
  var subInput = inputPool.allocate();

  stack.push(this.m_root);
  while (stack.length > 0) {
    var node = stack.pop();
    if (node == null) {
      continue;
    }

    if (AABB.testOverlap(node.aabb, segmentAABB) == false) {
      continue;
    }

    // Separating axis for segment (Gino, p80).
    // |dot(v, p1 - c)| > dot(|v|, h)
    var c = node.aabb.getCenter();
    var h = node.aabb.getExtents();
    var separation = Math.abs(Vec2.dot(v, Vec2.sub(p1, c)))
        - Vec2.dot(abs_v, h);
    if (separation > 0.0) {
      continue;
    }

    if (node.isLeaf()) {
      subInput.p1 = Vec2.clone(input.p1);
      subInput.p2 = Vec2.clone(input.p2);
      subInput.maxFraction = maxFraction;

      var value = rayCastCallback(subInput, node.id);

      if (value == 0.0) {
        // The client has terminated the ray cast.
        return;
      }

      if (value > 0.0) {
        // update segment bounding box.
        maxFraction = value;
        t = Vec2.combine((1 - maxFraction), p1, maxFraction, p2);
        segmentAABB.combinePoints(p1, t);
      }
    } else {
      stack.push(node.child1);
      stack.push(node.child2);
    }
  }

  stackPool.release(stack);
  inputPool.release(subInput);
}

var inputPool = new Pool({
  create : function() {
    return {};
  },
  release : function(stack) {
  }
});

var stackPool = new Pool({
  create : function() {
    return [];
  },
  release : function(stack) {
    stack.length = 0;
  }
});

var iteratorPool = new Pool({
  create : function() {
    return new Iterator();
  },
  release : function(iterator) {
    iterator.close();
  }
});

function Iterator() {
  var parents = [];
  var states = [];
  return {
    preorder : function(root) {
      parents.length = 0;
      parents.push(root);
      states.length = 0;
      states.push(0);
      return this;
    },
    next : function() {
      while (parents.length > 0) {
        var i = parents.length - 1;
        var node = parents[i];
        if (states[i] === 0) {
          states[i] = 1;
          return node;
        }
        if (states[i] === 1) {
          states[i] = 2;
          if (node.child1) {
            parents.push(node.child1);
            states.push(1);
            return node.child1;
          }
        }
        if (states[i] === 2) {
          states[i] = 3;
          if (node.child2) {
            parents.push(node.child2);
            states.push(1);
            return node.child2;
          }
        }
        parents.pop();
        states.pop();
      }
    },
    close : function() {
      parents.length = 0;
    }
  };
}


/***/ }),
/* 69 */
/***/ ((module) => {

/*
 * Copyright (c) 2016-2018 Ali Shakiba http://shakiba.me/planck.js
 *
 * This software is provided 'as-is', without any express or implied
 * warranty.  In no event will the authors be held liable for any damages
 * arising from the use of this software.
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 * 1. The origin of this software must not be misrepresented; you must not
 * claim that you wrote the original software. If you use this software
 * in a product, an acknowledgment in the product documentation would be
 * appreciated but is not required.
 * 2. Altered source versions must be plainly marked as such, and must not be
 * misrepresented as being the original software.
 * 3. This notice may not be removed or altered from any source distribution.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

module.exports = Pool;

function Pool(opts) {
  var _list = [];
  var _max = opts.max || Infinity;

  var _createFn = opts.create;
  var _outFn = opts.allocate;
  var _inFn = opts.release;
  var _discardFn = opts.discard;

  var _createCount = 0;
  var _outCount = 0;
  var _inCount = 0;
  var _discardCount = 0;

  this.max = function(n) {
    if (typeof n === 'number') {
      _max = n;
      return this;
    }
    return _max;
  };

  this.size = function() {
    return _list.length;
  };

  this.allocate = function() {
    var item;
    if (_list.length > 0) {
      item = _list.shift();
    } else {
      _createCount++;
      if (typeof _createFn === 'function') {
        item = _createFn();
      } else {
        item = {};
      }
    }
    _outCount++;
    if (typeof _outFn === 'function') {
      _outFn(item);
    }
    return item;
  };

  this.release = function(item) {
    if (_list.length < _max) {
      _inCount++;
      if (typeof _inFn === 'function') {
        _inFn(item);
      }
      _list.push(item);
    } else {
      _discardCount++;
      if (typeof _discardFn === 'function') {
        item = _discardFn(item);
      }
    }
  };

  this.toString = function() {
    return " +" + _createCount + " >" + _outCount + " <" + _inCount + " -"
        + _discardCount + " =" + _list.length + "/" + _max;
  };
}

/***/ }),
/* 70 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

module.exports = Solver;
module.exports.TimeStep = TimeStep;

var Settings = __webpack_require__(66);
var common = __webpack_require__(61);

var Vec2 = __webpack_require__(62);
var Math = __webpack_require__(63);

var Body = __webpack_require__(71);
var Contact = __webpack_require__(79);
var Joint = __webpack_require__(86);

var TimeOfImpact = __webpack_require__(87);
var TOIInput = TimeOfImpact.Input;
var TOIOutput = TimeOfImpact.Output;

var Distance = __webpack_require__(82);
var DistanceInput = Distance.Input;
var DistanceOutput = Distance.Output;
var DistanceProxy = Distance.Proxy;
var SimplexCache = Distance.Cache;

function TimeStep(dt) {
  this.dt = 0; // time step
  this.inv_dt = 0; // inverse time step (0 if dt == 0)
  this.velocityIterations = 0;
  this.positionIterations = 0;
  this.warmStarting = false;
  this.blockSolve = true;

  // timestep ratio for variable timestep
  this.inv_dt0 = 0.0;
  this.dtRatio = 1; // dt * inv_dt0
}

TimeStep.prototype.reset = function(dt) {
  if (this.dt > 0.0) {
    this.inv_dt0 = this.inv_dt;
  }
  this.dt = dt;
  this.inv_dt = dt == 0 ? 0 : 1 / dt;
  this.dtRatio = dt * this.inv_dt0;
}

/**
 * Finds and solves islands. An island is a connected subset of the world.
 * 
 * @param {World} world
 */
function Solver(world) {
  this.m_world = world;
  this.m_stack = [];
  this.m_bodies = [];
  this.m_contacts = [];
  this.m_joints = [];
}

Solver.prototype.clear = function() {
  this.m_stack.length = 0;
  this.m_bodies.length = 0;
  this.m_contacts.length = 0;
  this.m_joints.length = 0;
}

Solver.prototype.addBody = function(body) {
  _ASSERT && common.assert(body instanceof Body, 'Not a Body!', body);
  this.m_bodies.push(body);
  // why?
//  body.c_position.c.setZero();
//  body.c_position.a = 0;
//  body.c_velocity.v.setZero();
//  body.c_velocity.w = 0;
};

Solver.prototype.addContact = function(contact) {
  _ASSERT && common.assert(contact instanceof Contact, 'Not a Contact!', contact);
  this.m_contacts.push(contact);
};

Solver.prototype.addJoint = function(joint) {
  _ASSERT && common.assert(joint instanceof Joint, 'Not a Joint!', joint);
  this.m_joints.push(joint);
};

/**
 * @param {TimeStep} step
 */
Solver.prototype.solveWorld = function(step) {
  var world = this.m_world;

  // Clear all the island flags.
  for (var b = world.m_bodyList; b; b = b.m_next) {
    b.m_islandFlag = false;
  }
  for (var c = world.m_contactList; c; c = c.m_next) {
    c.m_islandFlag = false;
  }
  for (var j = world.m_jointList; j; j = j.m_next) {
    j.m_islandFlag = false;
  }

  // Build and simulate all awake islands.
  var stack = this.m_stack;
  var loop = -1;
  for (var seed = world.m_bodyList; seed; seed = seed.m_next) {
    loop++;
    if (seed.m_islandFlag) {
      continue;
    }

    if (seed.isAwake() == false || seed.isActive() == false) {
      continue;
    }

    // The seed can be dynamic or kinematic.
    if (seed.isStatic()) {
      continue;
    }

    // Reset island and stack.
    this.clear();

    stack.push(seed);

    seed.m_islandFlag = true;

    // Perform a depth first search (DFS) on the constraint graph.
    while (stack.length > 0) {
      // Grab the next body off the stack and add it to the island.
      var b = stack.pop();
      _ASSERT && common.assert(b.isActive() == true);
      this.addBody(b);

      // Make sure the body is awake.
      b.setAwake(true);

      // To keep islands as small as possible, we don't
      // propagate islands across static bodies.
      if (b.isStatic()) {
        continue;
      }
      
      // Search all contacts connected to this body.
      for (var ce = b.m_contactList; ce; ce = ce.next) {
        var contact = ce.contact;

        // Has this contact already been added to an island?
        if (contact.m_islandFlag) {
          continue;
        }

        // Is this contact solid and touching?
        if (contact.isEnabled() == false || contact.isTouching() == false) {
          continue;
        }

        // Skip sensors.
        var sensorA = contact.m_fixtureA.m_isSensor;
        var sensorB = contact.m_fixtureB.m_isSensor;
        if (sensorA || sensorB) {
          continue;
        }

        this.addContact(contact);
        contact.m_islandFlag = true;

        var other = ce.other;

        // Was the other body already added to this island?
        if (other.m_islandFlag) {
          continue;
        }

        // _ASSERT && common.assert(stack.length < world.m_bodyCount);
        stack.push(other);
        other.m_islandFlag = true;
      }

      // Search all joints connect to this body.
      for (var je = b.m_jointList; je; je = je.next) {
        if (je.joint.m_islandFlag == true) {
          continue;
        }

        var other = je.other;

        // Don't simulate joints connected to inactive bodies.
        if (other.isActive() == false) {
          continue;
        }

        this.addJoint(je.joint);
        je.joint.m_islandFlag = true;

        if (other.m_islandFlag) {
          continue;
        }

        // _ASSERT && common.assert(stack.length < world.m_bodyCount);
        stack.push(other);
        other.m_islandFlag = true;
      }
    }

    this.solveIsland(step);

    // Post solve cleanup.
    for (var i = 0; i < this.m_bodies.length; ++i) {
      // Allow static bodies to participate in other islands.
      // TODO: are they added at all?
      var b = this.m_bodies[i];
      if (b.isStatic()) {
        b.m_islandFlag = false;
      }
    }
  }
}

/**
 * @param {TimeStep} step
 */
Solver.prototype.solveIsland = function(step) {
  // B2: Island Solve
  var world = this.m_world;
  var gravity = world.m_gravity;
  var allowSleep = world.m_allowSleep;

  var h = step.dt;

  // Integrate velocities and apply damping. Initialize the body state.
  for (var i = 0; i < this.m_bodies.length; ++i) {
    var body = this.m_bodies[i];

    var c = Vec2.clone(body.m_sweep.c);
    var a = body.m_sweep.a;
    var v = Vec2.clone(body.m_linearVelocity);
    var w = body.m_angularVelocity;

    // Store positions for continuous collision.
    body.m_sweep.c0.set(body.m_sweep.c);
    body.m_sweep.a0 = body.m_sweep.a;

    if (body.isDynamic()) {
      // Integrate velocities.
      v.addMul(h * body.m_gravityScale, gravity);
      v.addMul(h * body.m_invMass, body.m_force);
      w += h * body.m_invI * body.m_torque;
      /**
       * <pre>
       * Apply damping.
       * ODE: dv/dt + c * v = 0
       * Solution: v(t) = v0 * exp(-c * t)
       * Time step: v(t + dt) = v0 * exp(-c * (t + dt)) = v0 * exp(-c * t) * exp(-c * dt) = v * exp(-c * dt)
       * v2 = exp(-c * dt) * v1
       * Pade approximation:
       * v2 = v1 * 1 / (1 + c * dt)
       * </pre>
       */
      v.mul(1.0 / (1.0 + h * body.m_linearDamping));
      w *= 1.0 / (1.0 + h * body.m_angularDamping);
    }

    body.c_position.c = c;
    body.c_position.a = a;
    body.c_velocity.v = v;
    body.c_velocity.w = w;
  }

  for (var i = 0; i < this.m_contacts.length; ++i) {
    var contact = this.m_contacts[i];
    contact.initConstraint(step);
  }

  _DEBUG && this.printBodies('M: ');

  for (var i = 0; i < this.m_contacts.length; ++i) {
    var contact = this.m_contacts[i];
    contact.initVelocityConstraint(step);
  }

  _DEBUG && this.printBodies('R: ');

  if (step.warmStarting) {
    // Warm start.
    for (var i = 0; i < this.m_contacts.length; ++i) {
      var contact = this.m_contacts[i];
      contact.warmStartConstraint(step);
    }
  }

  _DEBUG && this.printBodies('Q: ');
  
  for (var i = 0; i < this.m_joints.length; ++i) {
    var joint = this.m_joints[i];
    joint.initVelocityConstraints(step);
  }

  _DEBUG && this.printBodies('E: ');

  // Solve velocity constraints
  for (var i = 0; i < step.velocityIterations; ++i) {
    for (var j = 0; j < this.m_joints.length; ++j) {
      var joint = this.m_joints[j];
      joint.solveVelocityConstraints(step);
    }

    for (var j = 0; j < this.m_contacts.length; ++j) {
      var contact = this.m_contacts[j];
      contact.solveVelocityConstraint(step);
    }
  }

  _DEBUG && this.printBodies('D: ');

  // Store impulses for warm starting
  for (var i = 0; i < this.m_contacts.length; ++i) {
    var contact = this.m_contacts[i];
    contact.storeConstraintImpulses(step);
  }

  _DEBUG && this.printBodies('C: ');

  // Integrate positions
  for (var i = 0; i < this.m_bodies.length; ++i) {
    var body = this.m_bodies[i];

    var c = Vec2.clone(body.c_position.c);
    var a = body.c_position.a;
    var v = Vec2.clone(body.c_velocity.v);
    var w = body.c_velocity.w;

    // Check for large velocities
    var translation = Vec2.mul(h, v);
    if (Vec2.lengthSquared(translation) > Settings.maxTranslationSquared) {
      var ratio = Settings.maxTranslation / translation.length();
      v.mul(ratio);
    }

    var rotation = h * w;
    if (rotation * rotation > Settings.maxRotationSquared) {
      var ratio = Settings.maxRotation / Math.abs(rotation);
      w *= ratio;
    }

    // Integrate
    c.addMul(h, v);
    a += h * w;

    body.c_position.c.set(c);
    body.c_position.a = a;
    body.c_velocity.v.set(v);
    body.c_velocity.w = w;
  }

  _DEBUG && this.printBodies('B: ');

  // Solve position constraints
  var positionSolved = false;
  for (var i = 0; i < step.positionIterations; ++i) {
    var minSeparation = 0.0;
    for (var j = 0; j < this.m_contacts.length; ++j) {
      var contact = this.m_contacts[j];
      var separation = contact.solvePositionConstraint(step);
      minSeparation = Math.min(minSeparation, separation);
    }
    // We can't expect minSpeparation >= -Settings.linearSlop because we don't
    // push the separation above -Settings.linearSlop.
    var contactsOkay = minSeparation >= -3.0 * Settings.linearSlop;

    var jointsOkay = true;
    for (var j = 0; j < this.m_joints.length; ++j) {
      var joint = this.m_joints[j];
      var jointOkay = joint.solvePositionConstraints(step);
      jointsOkay = jointsOkay && jointOkay;
    }

    if (contactsOkay && jointsOkay) {
      // Exit early if the position errors are small.
      positionSolved = true;
      break;
    }
  }

  _DEBUG && this.printBodies('L: ');

  // Copy state buffers back to the bodies
  for (var i = 0; i < this.m_bodies.length; ++i) {
    var body = this.m_bodies[i];

    body.m_sweep.c.set(body.c_position.c);
    body.m_sweep.a = body.c_position.a;
    body.m_linearVelocity.set(body.c_velocity.v);
    body.m_angularVelocity = body.c_velocity.w;
    body.synchronizeTransform();
  }

  this.postSolveIsland();

  if (allowSleep) {
    var minSleepTime = Infinity;

    var linTolSqr = Settings.linearSleepToleranceSqr;
    var angTolSqr = Settings.angularSleepToleranceSqr;

    for (var i = 0; i < this.m_bodies.length; ++i) {
      var body = this.m_bodies[i];
      if (body.isStatic()) {
        continue;
      }

      if ((body.m_autoSleepFlag == false)
          || (body.m_angularVelocity * body.m_angularVelocity > angTolSqr)
          || (Vec2.lengthSquared(body.m_linearVelocity) > linTolSqr)) {
        body.m_sleepTime = 0.0;
        minSleepTime = 0.0;
      } else {
        body.m_sleepTime += h;
        minSleepTime = Math.min(minSleepTime, body.m_sleepTime);
      }
    }

    if (minSleepTime >= Settings.timeToSleep && positionSolved) {
      for (var i = 0; i < this.m_bodies.length; ++i) {
        var body = this.m_bodies[i];
        body.setAwake(false);
      }
    }
  }
};

Solver.prototype.printBodies = function(tag) {
  for (var i = 0; i < this.m_bodies.length; ++i) {
    var b = this.m_bodies[i];
    common.debug(tag, b.c_position.a, b.c_position.c.x, b.c_position.c.y, b.c_velocity.w, b.c_velocity.v.x, b.c_velocity.v.y);
  }
};

var s_subStep = new TimeStep(); // reuse

/**
 * Find TOI contacts and solve them.
 *
 * @param {TimeStep} step
 */
Solver.prototype.solveWorldTOI = function(step) {
  var world = this.m_world;

  if (world.m_stepComplete) {
    for (var b = world.m_bodyList; b; b = b.m_next) {
      b.m_islandFlag = false;
      b.m_sweep.alpha0 = 0.0;
    }

    for (var c = world.m_contactList; c; c = c.m_next) {
      // Invalidate TOI
      c.m_toiFlag = false;
      c.m_islandFlag = false;
      c.m_toiCount = 0;
      c.m_toi = 1.0;
    }
  }

  // Find TOI events and solve them.
  for (;;) {
    // Find the first TOI.
    var minContact = null; // Contact
    var minAlpha = 1.0;

    for (var c = world.m_contactList; c; c = c.m_next) {
      // Is this contact disabled?
      if (c.isEnabled() == false) {
        continue;
      }

      // Prevent excessive sub-stepping.
      if (c.m_toiCount > Settings.maxSubSteps) {
        continue;
      }

      var alpha = 1.0;
      if (c.m_toiFlag) {
        // This contact has a valid cached TOI.
        alpha = c.m_toi;
      } else {
        var fA = c.getFixtureA();
        var fB = c.getFixtureB();

        // Is there a sensor?
        if (fA.isSensor() || fB.isSensor()) {
          continue;
        }

        var bA = fA.getBody();
        var bB = fB.getBody();

        _ASSERT && common.assert(bA.isDynamic() || bB.isDynamic());

        var activeA = bA.isAwake() && !bA.isStatic();
        var activeB = bB.isAwake() && !bB.isStatic();

        // Is at least one body active (awake and dynamic or kinematic)?
        if (activeA == false && activeB == false) {
          continue;
        }

        var collideA = bA.isBullet() || !bA.isDynamic();
        var collideB = bB.isBullet() || !bB.isDynamic();

        // Are these two non-bullet dynamic bodies?
        if (collideA == false && collideB == false) {
          continue;
        }

        // Compute the TOI for this contact.
        // Put the sweeps onto the same time interval.
        var alpha0 = bA.m_sweep.alpha0;

        if (bA.m_sweep.alpha0 < bB.m_sweep.alpha0) {
          alpha0 = bB.m_sweep.alpha0;
          bA.m_sweep.advance(alpha0);
        } else if (bB.m_sweep.alpha0 < bA.m_sweep.alpha0) {
          alpha0 = bA.m_sweep.alpha0;
          bB.m_sweep.advance(alpha0);
        }

        _ASSERT && common.assert(alpha0 < 1.0);

        var indexA = c.getChildIndexA();
        var indexB = c.getChildIndexB();

        var sweepA = bA.m_sweep;
        var sweepB = bB.m_sweep;

        // Compute the time of impact in interval [0, minTOI]
        var input = new TOIInput(); // TODO: reuse
        input.proxyA.set(fA.getShape(), indexA);
        input.proxyB.set(fB.getShape(), indexB);
        input.sweepA.set(bA.m_sweep);
        input.sweepB.set(bB.m_sweep);
        input.tMax = 1.0;

        var output = new TOIOutput(); // TODO: reuse
        TimeOfImpact(output, input);

        // Beta is the fraction of the remaining portion of the [time?].
        var beta = output.t;
        if (output.state == TOIOutput.e_touching) {
          alpha = Math.min(alpha0 + (1.0 - alpha0) * beta, 1.0);
        } else {
          alpha = 1.0;
        }

        c.m_toi = alpha;
        c.m_toiFlag = true;
      }

      if (alpha < minAlpha) {
        // This is the minimum TOI found so far.
        minContact = c;
        minAlpha = alpha;
      }
    }

    if (minContact == null || 1.0 - 10.0 * Math.EPSILON < minAlpha) {
      // No more TOI events. Done!
      world.m_stepComplete = true;
      break;
    }

    // Advance the bodies to the TOI.
    var fA = minContact.getFixtureA();
    var fB = minContact.getFixtureB();
    var bA = fA.getBody();
    var bB = fB.getBody();

    var backup1 = bA.m_sweep.clone();
    var backup2 = bB.m_sweep.clone();

    bA.advance(minAlpha);
    bB.advance(minAlpha);

    // The TOI contact likely has some new contact points.
    minContact.update(world);
    minContact.m_toiFlag = false;
    ++minContact.m_toiCount;

    // Is the contact solid?
    if (minContact.isEnabled() == false || minContact.isTouching() == false) {
      // Restore the sweeps.
      minContact.setEnabled(false);
      bA.m_sweep.set(backup1);
      bB.m_sweep.set(backup2);
      bA.synchronizeTransform();
      bB.synchronizeTransform();
      continue;
    }

    bA.setAwake(true);
    bB.setAwake(true);

    // Build the island
    this.clear();
    this.addBody(bA);
    this.addBody(bB);
    this.addContact(minContact);

    bA.m_islandFlag = true;
    bB.m_islandFlag = true;
    minContact.m_islandFlag = true;

    // Get contacts on bodyA and bodyB.
    var bodies = [ bA, bB ];
    for (var i = 0; i < bodies.length; ++i) {
      var body = bodies[i];
      if (body.isDynamic()) {
        for (var ce = body.m_contactList; ce; ce = ce.next) {
          // if (this.m_bodyCount == this.m_bodyCapacity) { break; }
          // if (this.m_contactCount == this.m_contactCapacity) { break; }

          var contact = ce.contact;

          // Has this contact already been added to the island?
          if (contact.m_islandFlag) {
            continue;
          }

          // Only add if either is static, kinematic or bullet.
          var other = ce.other;
          if (other.isDynamic() && !body.isBullet() && !other.isBullet()) {
            continue;
          }

          // Skip sensors.
          var sensorA = contact.m_fixtureA.m_isSensor;
          var sensorB = contact.m_fixtureB.m_isSensor;
          if (sensorA || sensorB) {
            continue;
          }

          // Tentatively advance the body to the TOI.
          var backup = other.m_sweep.clone();
          if (other.m_islandFlag == false) {
            other.advance(minAlpha);
          }

          // Update the contact points
          contact.update(world);

          // Was the contact disabled by the user?
          // Are there contact points?
          if (contact.isEnabled() == false || contact.isTouching() == false) {
            other.m_sweep.set(backup);
            other.synchronizeTransform();
            continue;
          }

          // Add the contact to the island
          contact.m_islandFlag = true;
          this.addContact(contact);

          // Has the other body already been added to the island?
          if (other.m_islandFlag) {
            continue;
          }

          // Add the other body to the island.
          other.m_islandFlag = true;

          if (!other.isStatic()) {
            other.setAwake(true);
          }

          this.addBody(other);
        }
      }
    }

    s_subStep.reset((1.0 - minAlpha) * step.dt);
    s_subStep.dtRatio = 1.0;
    s_subStep.positionIterations = 20;
    s_subStep.velocityIterations = step.velocityIterations;
    s_subStep.warmStarting = false;

    this.solveIslandTOI(s_subStep, bA, bB);

    // Reset island flags and synchronize broad-phase proxies.
    for (var i = 0; i < this.m_bodies.length; ++i) {
      var body = this.m_bodies[i];
      body.m_islandFlag = false;

      if (!body.isDynamic()) {
        continue;
      }

      body.synchronizeFixtures();

      // Invalidate all contact TOIs on this displaced body.
      for (var ce = body.m_contactList; ce; ce = ce.next) {
        ce.contact.m_toiFlag = false;
        ce.contact.m_islandFlag = false;
      }
    }

    // Commit fixture proxy movements to the broad-phase so that new contacts
    // are created.
    // Also, some contacts can be destroyed.
    world.findNewContacts();

    if (world.m_subStepping) {
      world.m_stepComplete = false;
      break;
    }
  }

  if (_DEBUG) for (var b = world.m_bodyList; b; b = b.m_next) {
    var c = b.m_sweep.c;
    var a = b.m_sweep.a;
    var v = b.m_linearVelocity;
    var w = b.m_angularVelocity;
  }
}

/**
 * @param {TimeStep} subStep
 * @param toiA
 * @param toiB
 */
Solver.prototype.solveIslandTOI = function(subStep, toiA, toiB) {
  var world = this.m_world;

  // Initialize the body state.
  for (var i = 0; i < this.m_bodies.length; ++i) {
    var body = this.m_bodies[i];
    body.c_position.c.set(body.m_sweep.c);
    body.c_position.a = body.m_sweep.a;
    body.c_velocity.v.set(body.m_linearVelocity);
    body.c_velocity.w = body.m_angularVelocity;
  }

  for (var i = 0; i < this.m_contacts.length; ++i) {
    var contact = this.m_contacts[i];
    contact.initConstraint(subStep);
  }

  // Solve position constraints.
  for (var i = 0; i < subStep.positionIterations; ++i) {
    var minSeparation = 0.0;
    for (var j = 0; j < this.m_contacts.length; ++j) {
      var contact = this.m_contacts[j];
      var separation = contact.solvePositionConstraintTOI(subStep, toiA, toiB);
      minSeparation = Math.min(minSeparation, separation);
    }
    // We can't expect minSpeparation >= -Settings.linearSlop because we don't
    // push the separation above -Settings.linearSlop.
    var contactsOkay = minSeparation >= -1.5 * Settings.linearSlop;
    if (contactsOkay) {
      break;
    }
  }

  if (false) { var cache, output, input, indexB, indexA, bB, bA, fB, fA, c, i; }

  // Leap of faith to new safe state.
  toiA.m_sweep.c0.set(toiA.c_position.c);
  toiA.m_sweep.a0 = toiA.c_position.a;
  toiB.m_sweep.c0.set(toiB.c_position.c);
  toiB.m_sweep.a0 = toiB.c_position.a;

  // No warm starting is needed for TOI events because warm
  // starting impulses were applied in the discrete solver.
  for (var i = 0; i < this.m_contacts.length; ++i) {
    var contact = this.m_contacts[i];
    contact.initVelocityConstraint(subStep);
  }

  // Solve velocity constraints.
  for (var i = 0; i < subStep.velocityIterations; ++i) {
    for (var j = 0; j < this.m_contacts.length; ++j) {
      var contact = this.m_contacts[j];
      contact.solveVelocityConstraint(subStep);
    }
  }

  // Don't store the TOI contact forces for warm starting
  // because they can be quite large.

  var h = subStep.dt;

  // Integrate positions
  for (var i = 0; i < this.m_bodies.length; ++i) {
    var body = this.m_bodies[i];

    var c = Vec2.clone(body.c_position.c);
    var a = body.c_position.a;
    var v = Vec2.clone(body.c_velocity.v);
    var w = body.c_velocity.w;

    // Check for large velocities
    var translation = Vec2.mul(h, v);
    if (Vec2.dot(translation, translation) > Settings.maxTranslationSquared) {
      var ratio = Settings.maxTranslation / translation.length();
      v.mul(ratio);
    }

    var rotation = h * w;
    if (rotation * rotation > Settings.maxRotationSquared) {
      var ratio = Settings.maxRotation / Math.abs(rotation);
      w *= ratio;
    }

    // Integrate
    c.addMul(h, v);
    a += h * w;

    body.c_position.c = c;
    body.c_position.a = a;
    body.c_velocity.v = v;
    body.c_velocity.w = w;

    // Sync bodies
    body.m_sweep.c = c;
    body.m_sweep.a = a;
    body.m_linearVelocity = v;
    body.m_angularVelocity = w;
    body.synchronizeTransform();
  }

  this.postSolveIsland();
};

/**
 * Contact impulses for reporting. Impulses are used instead of forces because
 * sub-step forces may approach infinity for rigid body collisions. These match
 * up one-to-one with the contact points in Manifold.
 */
function ContactImpulse() {
  this.normalImpulses = [];
  this.tangentImpulses = [];
};

Solver.prototype.postSolveIsland = function() {
  // TODO: report contact.v_points instead of new object?
  var impulse = new ContactImpulse();
  for (var c = 0; c < this.m_contacts.length; ++c) {
    var contact = this.m_contacts[c];
    for (var p = 0; p < contact.v_points.length; ++p) {
      impulse.normalImpulses.push(contact.v_points[p].normalImpulse);
      impulse.tangentImpulses.push(contact.v_points[p].tangentImpulse);
    }
    this.m_world.postSolve(contact, impulse);
  }
};


/***/ }),
/* 71 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

module.exports = Body;

var common = __webpack_require__(61);
var options = __webpack_require__(60);

var Vec2 = __webpack_require__(62);
var Rot = __webpack_require__(72);
var Math = __webpack_require__(63);
var Sweep = __webpack_require__(73);
var Transform = __webpack_require__(74);
var Velocity = __webpack_require__(75);
var Position = __webpack_require__(76);

var Fixture = __webpack_require__(77);
var Shape = __webpack_require__(78);

var staticBody = Body.STATIC = 'static';
var kinematicBody = Body.KINEMATIC = 'kinematic';
var dynamicBody = Body.DYNAMIC = 'dynamic';

/**
 * @typedef {Object} BodyDef
 *
 * @prop type Body types are static, kinematic, or dynamic. Note: if a dynamic
 *       body would have zero mass, the mass is set to one.
 *
 * @prop position The world position of the body. Avoid creating bodies at the
 *       origin since this can lead to many overlapping shapes.
 *
 * @prop angle The world angle of the body in radians.
 *
 * @prop linearVelocity The linear velocity of the body's origin in world
 *       co-ordinates.
 *
 * @prop angularVelocity
 *
 * @prop linearDamping Linear damping is use to reduce the linear velocity. The
 *       damping parameter can be larger than 1.0 but the damping effect becomes
 *       sensitive to the time step when the damping parameter is large.
 *
 * @prop angularDamping Angular damping is use to reduce the angular velocity.
 *       The damping parameter can be larger than 1.0 but the damping effect
 *       becomes sensitive to the time step when the damping parameter is large.
 *
 * @prop fixedRotation Should this body be prevented from rotating? Useful for
 *       characters.
 *
 * @prop bullet Is this a fast moving body that should be prevented from
 *       tunneling through other moving bodies? Note that all bodies are
 *       prevented from tunneling through kinematic and static bodies. This
 *       setting is only considered on dynamic bodies. Warning: You should use
 *       this flag sparingly since it increases processing time.
 *
 * @prop active Does this body start out active?
 *
 * @prop awake Is this body initially awake or sleeping?
 *
 * @prop allowSleep Set this flag to false if this body should never fall
 *       asleep. Note that this increases CPU usage.
 */
var BodyDef = {
  type : staticBody,
  position : Vec2.zero(),
  angle : 0.0,

  linearVelocity : Vec2.zero(),
  angularVelocity : 0.0,

  linearDamping : 0.0,
  angularDamping : 0.0,

  fixedRotation : false,
  bullet : false,
  gravityScale : 1.0,

  allowSleep : true,
  awake : true,
  active : true,

  userData : null
};

/**
 * @class
 * 
 * A rigid body composed of one or more fixtures.
 * 
 * @param {World} world
 * @param {BodyDef} def
 */
function Body(world, def) {

  def = options(def, BodyDef);

  _ASSERT && common.assert(Vec2.isValid(def.position));
  _ASSERT && common.assert(Vec2.isValid(def.linearVelocity));
  _ASSERT && common.assert(Math.isFinite(def.angle));
  _ASSERT && common.assert(Math.isFinite(def.angularVelocity));
  _ASSERT && common.assert(Math.isFinite(def.angularDamping) && def.angularDamping >= 0.0);
  _ASSERT && common.assert(Math.isFinite(def.linearDamping) && def.linearDamping >= 0.0);

  this.m_world = world;

  this.m_awakeFlag = def.awake;
  this.m_autoSleepFlag = def.allowSleep;
  this.m_bulletFlag = def.bullet;
  this.m_fixedRotationFlag = def.fixedRotation;
  this.m_activeFlag = def.active;

  this.m_islandFlag = false;
  this.m_toiFlag = false;

  this.m_userData = def.userData;
  this.m_type = def.type;

  if (this.m_type == dynamicBody) {
    this.m_mass = 1.0;
    this.m_invMass = 1.0;
  } else {
    this.m_mass = 0.0;
    this.m_invMass = 0.0;
  }

  // Rotational inertia about the center of mass.
  this.m_I = 0.0;
  this.m_invI = 0.0;

  // the body origin transform
  this.m_xf = Transform.identity();
  this.m_xf.p = Vec2.clone(def.position);
  this.m_xf.q.setAngle(def.angle);

  // the swept motion for CCD
  this.m_sweep = new Sweep();
  this.m_sweep.setTransform(this.m_xf);

  // position and velocity correction
  this.c_velocity = new Velocity();
  this.c_position = new Position();

  this.m_force = Vec2.zero();
  this.m_torque = 0.0;

  this.m_linearVelocity = Vec2.clone(def.linearVelocity);
  this.m_angularVelocity = def.angularVelocity;

  this.m_linearDamping = def.linearDamping;
  this.m_angularDamping = def.angularDamping;
  this.m_gravityScale = def.gravityScale;

  this.m_sleepTime = 0.0;

  this.m_jointList = null;
  this.m_contactList = null;
  this.m_fixtureList = null;

  this.m_prev = null;
  this.m_next = null;

  this.m_destroyed = false;
}

Body.prototype._serialize = function() {
  var fixtures = [];
  for (var f = this.m_fixtureList; f; f = f.m_next) {
    fixtures.push(f);
  }
  return {
    type: this.m_type,
    bullet: this.m_bulletFlag,
    position: this.m_xf.p,
    angle: this.m_xf.q.getAngle(),
    linearVelocity: this.m_linearVelocity,
    angularVelocity: this.m_angularVelocity,
    fixtures: fixtures,
  };
};

Body._deserialize = function(data, world, restore) {
  var body = new Body(world, data);

  if (data.fixtures) {
    for (var i = data.fixtures.length - 1; i >= 0; i--) {
      var fixture = restore(Fixture, data.fixtures[i], body);
      body._addFixture(fixture);
    }
  }
  return body;
};

Body.prototype.isWorldLocked = function() {
  return this.m_world && this.m_world.isLocked() ? true : false;
};

Body.prototype.getWorld = function() {
  return this.m_world;
};

Body.prototype.getNext = function() {
  return this.m_next;
};

Body.prototype.setUserData = function(data) {
  this.m_userData = data;
};

Body.prototype.getUserData = function() {
  return this.m_userData;
};

Body.prototype.getFixtureList = function() {
  return this.m_fixtureList;
};

Body.prototype.getJointList = function() {
  return this.m_jointList;
};

/**
 * Warning: this list changes during the time step and you may miss some
 * collisions if you don't use ContactListener.
 */
Body.prototype.getContactList = function() {
  return this.m_contactList;
};

Body.prototype.isStatic = function() {
  return this.m_type == staticBody;
};

Body.prototype.isDynamic = function() {
  return this.m_type == dynamicBody;
};

Body.prototype.isKinematic = function() {
  return this.m_type == kinematicBody;
};

/**
 * This will alter the mass and velocity.
 */
Body.prototype.setStatic = function() {
  this.setType(staticBody);
  return this;
};

Body.prototype.setDynamic = function() {
  this.setType(dynamicBody);
  return this;
};

Body.prototype.setKinematic = function() {
  this.setType(kinematicBody);
  return this;
};

/**
 * @private
 */
Body.prototype.getType = function() {
  return this.m_type;
};

/**
 * 
 * @private
 */
Body.prototype.setType = function(type) {
  _ASSERT && common.assert(type === staticBody || type === kinematicBody || type === dynamicBody);
  _ASSERT && common.assert(this.isWorldLocked() == false);

  if (this.isWorldLocked() == true) {
    return;
  }

  if (this.m_type == type) {
    return;
  }

  this.m_type = type;

  this.resetMassData();

  if (this.m_type == staticBody) {
    this.m_linearVelocity.setZero();
    this.m_angularVelocity = 0.0;
    this.m_sweep.forward();
    this.synchronizeFixtures();
  }

  this.setAwake(true);

  this.m_force.setZero();
  this.m_torque = 0.0;

  // Delete the attached contacts.
  var ce = this.m_contactList;
  while (ce) {
    var ce0 = ce;
    ce = ce.next;
    this.m_world.destroyContact(ce0.contact);
  }
  this.m_contactList = null;

  // Touch the proxies so that new contacts will be created (when appropriate)
  var broadPhase = this.m_world.m_broadPhase;
  for (var f = this.m_fixtureList; f; f = f.m_next) {
    var proxyCount = f.m_proxyCount;
    for (var i = 0; i < proxyCount; ++i) {
      broadPhase.touchProxy(f.m_proxies[i].proxyId);
    }
  }
};

Body.prototype.isBullet = function() {
  return this.m_bulletFlag;
};

/**
 * Should this body be treated like a bullet for continuous collision detection?
 */
Body.prototype.setBullet = function(flag) {
  this.m_bulletFlag = !!flag;
};

Body.prototype.isSleepingAllowed = function() {
  return this.m_autoSleepFlag;
};

Body.prototype.setSleepingAllowed = function(flag) {
  this.m_autoSleepFlag = !!flag;
  if (this.m_autoSleepFlag == false) {
    this.setAwake(true);
  }
};

Body.prototype.isAwake = function() {
  return this.m_awakeFlag;
};

/**
 * Set the sleep state of the body. A sleeping body has very low CPU cost.
 * 
 * @param flag Set to true to wake the body, false to put it to sleep.
 */
Body.prototype.setAwake = function(flag) {
  if (flag) {
    if (this.m_awakeFlag == false) {
      this.m_awakeFlag = true;
      this.m_sleepTime = 0.0;
    }
  } else {
    this.m_awakeFlag = false;
    this.m_sleepTime = 0.0;
    this.m_linearVelocity.setZero();
    this.m_angularVelocity = 0.0;
    this.m_force.setZero();
    this.m_torque = 0.0;
  }
};

Body.prototype.isActive = function() {
  return this.m_activeFlag;
};

/**
 * Set the active state of the body. An inactive body is not simulated and
 * cannot be collided with or woken up. If you pass a flag of true, all fixtures
 * will be added to the broad-phase. If you pass a flag of false, all fixtures
 * will be removed from the broad-phase and all contacts will be destroyed.
 * Fixtures and joints are otherwise unaffected.
 * 
 * You may continue to create/destroy fixtures and joints on inactive bodies.
 * Fixtures on an inactive body are implicitly inactive and will not participate
 * in collisions, ray-casts, or queries. Joints connected to an inactive body
 * are implicitly inactive. An inactive body is still owned by a World object
 * and remains
 */
Body.prototype.setActive = function(flag) {
  _ASSERT && common.assert(this.isWorldLocked() == false);

  if (flag == this.m_activeFlag) {
    return;
  }

  this.m_activeFlag = !!flag;

  if (this.m_activeFlag) {
    // Create all proxies.
    var broadPhase = this.m_world.m_broadPhase;
    for (var f = this.m_fixtureList; f; f = f.m_next) {
      f.createProxies(broadPhase, this.m_xf);
    }
    // Contacts are created the next time step.

  } else {
    // Destroy all proxies.
    var broadPhase = this.m_world.m_broadPhase;
    for (var f = this.m_fixtureList; f; f = f.m_next) {
      f.destroyProxies(broadPhase);
    }

    // Destroy the attached contacts.
    var ce = this.m_contactList;
    while (ce) {
      var ce0 = ce;
      ce = ce.next;
      this.m_world.destroyContact(ce0.contact);
    }
    this.m_contactList = null;
  }
};

Body.prototype.isFixedRotation = function() {
  return this.m_fixedRotationFlag;
};

/**
 * Set this body to have fixed rotation. This causes the mass to be reset.
 */
Body.prototype.setFixedRotation = function(flag) {
  if (this.m_fixedRotationFlag == flag) {
    return;
  }

  this.m_fixedRotationFlag = !!flag;

  this.m_angularVelocity = 0.0;

  this.resetMassData();
};

/**
 * Get the world transform for the body's origin.
 */
Body.prototype.getTransform = function() {
  return this.m_xf;
};

/**
 * Set the position of the body's origin and rotation. Manipulating a body's
 * transform may cause non-physical behavior. Note: contacts are updated on the
 * next call to World.step.
 * 
 * @param position The world position of the body's local origin.
 * @param angle The world rotation in radians.
 */
Body.prototype.setTransform = function(position, angle) {
  _ASSERT && common.assert(this.isWorldLocked() == false);
  if (this.isWorldLocked() == true) {
    return;
  }

  this.m_xf.set(position, angle);
  this.m_sweep.setTransform(this.m_xf);

  var broadPhase = this.m_world.m_broadPhase;
  for (var f = this.m_fixtureList; f; f = f.m_next) {
    f.synchronize(broadPhase, this.m_xf, this.m_xf);
  }
};

Body.prototype.synchronizeTransform = function() {
  this.m_sweep.getTransform(this.m_xf, 1);
};

/**
 * Update fixtures in broad-phase.
 */
Body.prototype.synchronizeFixtures = function() {
  var xf = Transform.identity();

  this.m_sweep.getTransform(xf, 0);

  var broadPhase = this.m_world.m_broadPhase;
  for (var f = this.m_fixtureList; f; f = f.m_next) {
    f.synchronize(broadPhase, xf, this.m_xf);
  }
};

/**
 * Used in TOI.
 */
Body.prototype.advance = function(alpha) {
  // Advance to the new safe time. This doesn't sync the broad-phase.
  this.m_sweep.advance(alpha);
  this.m_sweep.c.set(this.m_sweep.c0);
  this.m_sweep.a = this.m_sweep.a0;
  this.m_sweep.getTransform(this.m_xf, 1);
};

/**
 * Get the world position for the body's origin.
 */
Body.prototype.getPosition = function() {
  return this.m_xf.p;
};

Body.prototype.setPosition = function(p) {
  this.setTransform(p, this.m_sweep.a);
};

/**
 * Get the current world rotation angle in radians.
 */
Body.prototype.getAngle = function() {
  return this.m_sweep.a;
};

Body.prototype.setAngle = function(angle) {
  this.setTransform(this.m_xf.p, angle);
};

/**
 * Get the world position of the center of mass.
 */
Body.prototype.getWorldCenter = function() {
  return this.m_sweep.c;
};

/**
 * Get the local position of the center of mass.
 */
Body.prototype.getLocalCenter = function() {
  return this.m_sweep.localCenter;
};

/**
 * Get the linear velocity of the center of mass.
 * 
 * @return the linear velocity of the center of mass.
 */
Body.prototype.getLinearVelocity = function() {
  return this.m_linearVelocity;
};

/**
 * Get the world linear velocity of a world point attached to this body.
 * 
 * @param worldPoint A point in world coordinates.
 */
Body.prototype.getLinearVelocityFromWorldPoint = function(worldPoint) {
  var localCenter = Vec2.sub(worldPoint, this.m_sweep.c);
  return Vec2.add(this.m_linearVelocity, Vec2.cross(this.m_angularVelocity,
      localCenter));
};

/**
 * Get the world velocity of a local point.
 * 
 * @param localPoint A point in local coordinates.
 */
Body.prototype.getLinearVelocityFromLocalPoint = function(localPoint) {
  return this.getLinearVelocityFromWorldPoint(this.getWorldPoint(localPoint));
};

/**
 * Set the linear velocity of the center of mass.
 * 
 * @param v The new linear velocity of the center of mass.
 */
Body.prototype.setLinearVelocity = function(v) {
  if (this.m_type == staticBody) {
    return;
  }
  if (Vec2.dot(v, v) > 0.0) {
    this.setAwake(true);
  }
  this.m_linearVelocity.set(v);
};

/**
 * Get the angular velocity.
 * 
 * @returns the angular velocity in radians/second.
 */
Body.prototype.getAngularVelocity = function() {
  return this.m_angularVelocity;
};

/**
 * Set the angular velocity.
 * 
 * @param omega The new angular velocity in radians/second.
 */
Body.prototype.setAngularVelocity = function(w) {
  if (this.m_type == staticBody) {
    return;
  }
  if (w * w > 0.0) {
    this.setAwake(true);
  }
  this.m_angularVelocity = w;
};

Body.prototype.getLinearDamping = function() {
  return this.m_linearDamping;
};

Body.prototype.setLinearDamping = function(linearDamping) {
  this.m_linearDamping = linearDamping;
};

Body.prototype.getAngularDamping = function() {
  return this.m_angularDamping;
};

Body.prototype.setAngularDamping = function(angularDamping) {
  this.m_angularDamping = angularDamping;
};

Body.prototype.getGravityScale = function() {
  return this.m_gravityScale;
};

/**
 * Scale the gravity applied to this body.
 */
Body.prototype.setGravityScale = function(scale) {
  this.m_gravityScale = scale;
};

/**
 * Get the total mass of the body.
 * 
 * @returns The mass, usually in kilograms (kg).
 */
Body.prototype.getMass = function() {
  return this.m_mass;
};

/**
 * Get the rotational inertia of the body about the local origin.
 * 
 * @return the rotational inertia, usually in kg-m^2.
 */
Body.prototype.getInertia = function() {
  return this.m_I + this.m_mass
      * Vec2.dot(this.m_sweep.localCenter, this.m_sweep.localCenter);
};

/**
 * @typedef {Object} MassData This holds the mass data computed for a shape.
 * 
 * @prop mass The mass of the shape, usually in kilograms.
 * @prop center The position of the shape's centroid relative to the shape's
 *       origin.
 * @prop I The rotational inertia of the shape about the local origin.
 */
function MassData() {
  this.mass = 0;
  this.center = Vec2.zero();
  this.I = 0;
};

/**
 * Copy the mass data of the body to data.
 */
Body.prototype.getMassData = function(data) {
  data.mass = this.m_mass;
  data.I = this.getInertia();
  data.center.set(this.m_sweep.localCenter);
};

/**
 * This resets the mass properties to the sum of the mass properties of the
 * fixtures. This normally does not need to be called unless you called
 * SetMassData to override the mass and you later want to reset the mass.
 */
Body.prototype.resetMassData = function() {
  // Compute mass data from shapes. Each shape has its own density.
  this.m_mass = 0.0;
  this.m_invMass = 0.0;
  this.m_I = 0.0;
  this.m_invI = 0.0;
  this.m_sweep.localCenter.setZero();

  // Static and kinematic bodies have zero mass.
  if (this.isStatic() || this.isKinematic()) {
    this.m_sweep.c0.set(this.m_xf.p);
    this.m_sweep.c.set(this.m_xf.p);
    this.m_sweep.a0 = this.m_sweep.a;
    return;
  }

  _ASSERT && common.assert(this.isDynamic());

  // Accumulate mass over all fixtures.
  var localCenter = Vec2.zero();
  for (var f = this.m_fixtureList; f; f = f.m_next) {
    if (f.m_density == 0.0) {
      continue;
    }

    var massData = new MassData();
    f.getMassData(massData);
    this.m_mass += massData.mass;
    localCenter.addMul(massData.mass, massData.center);
    this.m_I += massData.I;
  }

  // Compute center of mass.
  if (this.m_mass > 0.0) {
    this.m_invMass = 1.0 / this.m_mass;
    localCenter.mul(this.m_invMass);

  } else {
    // Force all dynamic bodies to have a positive mass.
    this.m_mass = 1.0;
    this.m_invMass = 1.0;
  }

  if (this.m_I > 0.0 && this.m_fixedRotationFlag == false) {
    // Center the inertia about the center of mass.
    this.m_I -= this.m_mass * Vec2.dot(localCenter, localCenter);
    _ASSERT && common.assert(this.m_I > 0.0);
    this.m_invI = 1.0 / this.m_I;

  } else {
    this.m_I = 0.0;
    this.m_invI = 0.0;
  }

  // Move center of mass.
  var oldCenter = Vec2.clone(this.m_sweep.c);
  this.m_sweep.setLocalCenter(localCenter, this.m_xf);

  // Update center of mass velocity.
  this.m_linearVelocity.add(Vec2.cross(this.m_angularVelocity, Vec2.sub(
      this.m_sweep.c, oldCenter)));
};

/**
 * Set the mass properties to override the mass properties of the fixtures. Note
 * that this changes the center of mass position. Note that creating or
 * destroying fixtures can also alter the mass. This function has no effect if
 * the body isn't dynamic.
 * 
 * @param massData The mass properties.
 */
Body.prototype.setMassData = function(massData) {
  _ASSERT && common.assert(this.isWorldLocked() == false);
  if (this.isWorldLocked() == true) {
    return;
  }

  if (this.m_type != dynamicBody) {
    return;
  }

  this.m_invMass = 0.0;
  this.m_I = 0.0;
  this.m_invI = 0.0;

  this.m_mass = massData.mass;
  if (this.m_mass <= 0.0) {
    this.m_mass = 1.0;
  }

  this.m_invMass = 1.0 / this.m_mass;

  if (massData.I > 0.0 && this.m_fixedRotationFlag == false) {
    this.m_I = massData.I - this.m_mass
        * Vec2.dot(massData.center, massData.center);
    _ASSERT && common.assert(this.m_I > 0.0);
    this.m_invI = 1.0 / this.m_I;
  }

  // Move center of mass.
  var oldCenter = Vec2.clone(this.m_sweep.c);
  this.m_sweep.setLocalCenter(massData.center, this.m_xf);

  // Update center of mass velocity.
  this.m_linearVelocity.add(Vec2.cross(this.m_angularVelocity, Vec2.sub(
      this.m_sweep.c, oldCenter)));
};

/**
 * Apply a force at a world point. If the force is not applied at the center of
 * mass, it will generate a torque and affect the angular velocity. This wakes
 * up the body.
 * 
 * @param force The world force vector, usually in Newtons (N).
 * @param point The world position of the point of application.
 * @param wake Also wake up the body
 */
Body.prototype.applyForce = function(force, point, wake) {
  if (this.m_type != dynamicBody) {
    return;
  }
  if (wake && this.m_awakeFlag == false) {
    this.setAwake(true);
  }
  // Don't accumulate a force if the body is sleeping.
  if (this.m_awakeFlag) {
    this.m_force.add(force);
    this.m_torque += Vec2.cross(Vec2.sub(point, this.m_sweep.c), force);
  }
};

/**
 * Apply a force to the center of mass. This wakes up the body.
 * 
 * @param force The world force vector, usually in Newtons (N).
 * @param wake Also wake up the body
 */
Body.prototype.applyForceToCenter = function(force, wake) {
  if (this.m_type != dynamicBody) {
    return;
  }
  if (wake && this.m_awakeFlag == false) {
    this.setAwake(true);
  }
  // Don't accumulate a force if the body is sleeping
  if (this.m_awakeFlag) {
    this.m_force.add(force);
  }
};

/**
 * Apply a torque. This affects the angular velocity without affecting the
 * linear velocity of the center of mass. This wakes up the body.
 * 
 * @param torque About the z-axis (out of the screen), usually in N-m.
 * @param wake Also wake up the body
 */
Body.prototype.applyTorque = function(torque, wake) {
  if (this.m_type != dynamicBody) {
    return;
  }
  if (wake && this.m_awakeFlag == false) {
    this.setAwake(true);
  }
  // Don't accumulate a force if the body is sleeping
  if (this.m_awakeFlag) {
    this.m_torque += torque;
  }
};

/**
 * Apply an impulse at a point. This immediately modifies the velocity. It also
 * modifies the angular velocity if the point of application is not at the
 * center of mass. This wakes up the body.
 * 
 * @param impulse The world impulse vector, usually in N-seconds or kg-m/s.
 * @param point The world position of the point of application.
 * @param wake Also wake up the body
 */
Body.prototype.applyLinearImpulse = function(impulse, point, wake) {
  if (this.m_type != dynamicBody) {
    return;
  }
  if (wake && this.m_awakeFlag == false) {
    this.setAwake(true);
  }

  // Don't accumulate velocity if the body is sleeping
  if (this.m_awakeFlag) {
    this.m_linearVelocity.addMul(this.m_invMass, impulse);
    this.m_angularVelocity += this.m_invI * Vec2.cross(Vec2.sub(point, this.m_sweep.c), impulse);
  }
};

/**
 * Apply an angular impulse.
 * 
 * @param impulse The angular impulse in units of kg*m*m/s
 * @param wake Also wake up the body
 */
Body.prototype.applyAngularImpulse = function(impulse, wake) {
  if (this.m_type != dynamicBody) {
    return;
  }

  if (wake && this.m_awakeFlag == false) {
    this.setAwake(true);
  }
  // Don't accumulate velocity if the body is sleeping
  if (this.m_awakeFlag) {
    this.m_angularVelocity += this.m_invI * impulse;
  }
};

/**
 * This is used to prevent connected bodies (by joints) from colliding,
 * depending on the joint's collideConnected flag.
 */
Body.prototype.shouldCollide = function(that) {
  // At least one body should be dynamic.
  if (this.m_type != dynamicBody && that.m_type != dynamicBody) {
    return false;
  }
  // Does a joint prevent collision?
  for (var jn = this.m_jointList; jn; jn = jn.next) {
    if (jn.other == that) {
      if (jn.joint.m_collideConnected == false) {
        return false;
      }
    }
  }
  return true;
};

/**
 * @internal Used for deserialize.
 */
Body.prototype._addFixture = function(fixture) {
  _ASSERT && common.assert(this.isWorldLocked() == false);

  if (this.isWorldLocked() == true) {
    return null;
  }

  if (this.m_activeFlag) {
    var broadPhase = this.m_world.m_broadPhase;
    fixture.createProxies(broadPhase, this.m_xf);
  }

  fixture.m_next = this.m_fixtureList;
  this.m_fixtureList = fixture;

  // Adjust mass properties if needed.
  if (fixture.m_density > 0.0) {
    this.resetMassData();
  }

  // Let the world know we have a new fixture. This will cause new contacts
  // to be created at the beginning of the next time step.
  this.m_world.m_newFixture = true;

  return fixture
};

/**
 * Creates a fixture and attach it to this body.
 * 
 * If the density is non-zero, this function automatically updates the mass of
 * the body.
 * 
 * Contacts are not created until the next time step.
 * 
 * Warning: This function is locked during callbacks.

 * @param {Shape|FixtureDef} shape Shape or fixture definition.
 * @param {FixtureDef|number} fixdef Fixture definition or just density.
 */
Body.prototype.createFixture = function(shape, fixdef) {
  _ASSERT && common.assert(this.isWorldLocked() == false);

  if (this.isWorldLocked() == true) {
    return null;
  }

  var fixture = new Fixture(this, shape, fixdef);
  this._addFixture(fixture);
  return fixture
};

/**
 * Destroy a fixture. This removes the fixture from the broad-phase and destroys
 * all contacts associated with this fixture. This will automatically adjust the
 * mass of the body if the body is dynamic and the fixture has positive density.
 * All fixtures attached to a body are implicitly destroyed when the body is
 * destroyed.
 * 
 * Warning: This function is locked during callbacks.
 * 
 * @param fixture The fixture to be removed.
 */
Body.prototype.destroyFixture = function(fixture) {
  _ASSERT && common.assert(this.isWorldLocked() == false);

  if (this.isWorldLocked() == true) {
    return;
  }

  _ASSERT && common.assert(fixture.m_body == this);

  // Remove the fixture from this body's singly linked list.
  var found = false;
  if (this.m_fixtureList === fixture) {
    this.m_fixtureList = fixture.m_next;
    found = true;

  } else {
    var node = this.m_fixtureList;
    while (node != null) {
      if (node.m_next === fixture) {
        node.m_next = fixture.m_next;
        found = true;
        break;
      }
      node = node.m_next;
    }
  }

  // You tried to remove a shape that is not attached to this body.
  _ASSERT && common.assert(found);

  // Destroy any contacts associated with the fixture.
  var edge = this.m_contactList;
  while (edge) {
    var c = edge.contact;
    edge = edge.next;

    var fixtureA = c.getFixtureA();
    var fixtureB = c.getFixtureB();

    if (fixture == fixtureA || fixture == fixtureB) {
      // This destroys the contact and removes it from
      // this body's contact list.
      this.m_world.destroyContact(c);
    }
  }

  if (this.m_activeFlag) {
    var broadPhase = this.m_world.m_broadPhase;
    fixture.destroyProxies(broadPhase);
  }

  fixture.m_body = null;
  fixture.m_next = null;

  this.m_world.publish('remove-fixture', fixture);

  // Reset the mass data.
  this.resetMassData();
};

/**
 * Get the corresponding world point of a local point.
 */
Body.prototype.getWorldPoint = function(localPoint) {
  return Transform.mulVec2(this.m_xf, localPoint);
};

/**
 * Get the corresponding world vector of a local vector.
 */
Body.prototype.getWorldVector = function(localVector) {
  return Rot.mulVec2(this.m_xf.q, localVector);
};

/**
 * Gets the corresponding local point of a world point.
 */
Body.prototype.getLocalPoint = function(worldPoint) {
  return Transform.mulTVec2(this.m_xf, worldPoint);
};

/**
 * 
 * Gets the corresponding local vector of a world vector.
 */
Body.prototype.getLocalVector = function(worldVector) {
  return Rot.mulTVec2(this.m_xf.q, worldVector);
};


/***/ }),
/* 72 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

module.exports = Rot;

var common = __webpack_require__(61);
var Vec2 = __webpack_require__(62);
var Math = __webpack_require__(63);

// TODO merge with Transform

/**
 * Initialize from an angle in radians.
 */
function Rot(angle) {
  if (!(this instanceof Rot)) {
    return new Rot(angle);
  }
  if (typeof angle === 'number') {
    this.setAngle(angle);
  } else if (typeof angle === 'object') {
      this.set(angle);
  } else {
    this.setIdentity();
  }
}

Rot.neo = function(angle) {
  var obj = Object.create(Rot.prototype);
  obj.setAngle(angle);
  return obj;
};

Rot.clone = function(rot) {
  _ASSERT && Rot.assert(rot);
  var obj = Object.create(Rot.prototype);
  obj.s = rot.s;
  obj.c = rot.c;
  return obj;
};

Rot.identity = function() {
  var obj = Object.create(Rot.prototype);
  obj.s = 0.0;
  obj.c = 1.0;
  return obj;
};

Rot.isValid = function(o) {
  return o && Math.isFinite(o.s) && Math.isFinite(o.c);
}

Rot.assert = function(o) {
  if (!_ASSERT) return;
  if (!Rot.isValid(o)) {
    _DEBUG && common.debug(o);
    throw new Error('Invalid Rot!');
  }
}

/**
 * Set to the identity rotation.
 */
Rot.prototype.setIdentity = function() {
  this.s = 0.0;
  this.c = 1.0;
}

Rot.prototype.set = function(angle) {
  if (typeof angle === 'object') {
    _ASSERT && Rot.assert(angle);
    this.s = angle.s;
    this.c = angle.c;

  } else {
    _ASSERT && Math.assert(angle);
    // TODO_ERIN optimize
    this.s = Math.sin(angle);
    this.c = Math.cos(angle);
  }
}

/**
 * Set using an angle in radians.
 */
Rot.prototype.setAngle = function(angle) {
  _ASSERT && Math.assert(angle);
  // TODO_ERIN optimize
  this.s = Math.sin(angle);
  this.c = Math.cos(angle);
};

/**
 * Get the angle in radians.
 */
Rot.prototype.getAngle = function() {
  return Math.atan2(this.s, this.c);
}

/**
 * Get the x-axis.
 */
Rot.prototype.getXAxis = function() {
  return Vec2.neo(this.c, this.s);
}

/**
 * Get the u-axis.
 */
Rot.prototype.getYAxis = function() {
  return Vec2.neo(-this.s, this.c);
}

/**
 * Multiply two rotations: q * r
 * 
 * @returns Rot
 * 
 * Rotate a vector
 * 
 * @returns Vec2
 */
Rot.mul = function(rot, m) {
  _ASSERT && Rot.assert(rot);
  if ('c' in m && 's' in m) {
    _ASSERT && Rot.assert(m);
    // [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]
    // [qs qc] [rs rc] [qs*rc+qc*rs -qs*rs+qc*rc]
    // s = qs * rc + qc * rs
    // c = qc * rc - qs * rs
    var qr = Rot.identity();
    qr.s = rot.s * m.c + rot.c * m.s;
    qr.c = rot.c * m.c - rot.s * m.s;
    return qr;

  } else if ('x' in m && 'y' in m) {
    _ASSERT && Vec2.assert(m);
    return Vec2.neo(rot.c * m.x - rot.s * m.y, rot.s * m.x + rot.c * m.y);
  }
}

Rot.mulRot = function(rot, m) {
  _ASSERT && Rot.assert(rot);
  _ASSERT && Rot.assert(m);
  // [qc -qs] * [rc -rs] = [qc*rc-qs*rs -qc*rs-qs*rc]
  // [qs qc] [rs rc] [qs*rc+qc*rs -qs*rs+qc*rc]
  // s = qs * rc + qc * rs
  // c = qc * rc - qs * rs
  var qr = Rot.identity();
  qr.s = rot.s * m.c + rot.c * m.s;
  qr.c = rot.c * m.c - rot.s * m.s;
  return qr;
}

Rot.mulVec2 = function(rot, m) {
  _ASSERT && Rot.assert(rot);
  _ASSERT && Vec2.assert(m);
  return Vec2.neo(rot.c * m.x - rot.s * m.y, rot.s * m.x + rot.c * m.y);
}

Rot.mulSub = function(rot, v, w) {
  var x = rot.c * (v.x - w.x) - rot.s * (v.y - w.y);
  var y = rot.s * (v.x - w.x) + rot.c * (v.y - w.y);
  return Vec2.neo(x, y);
}

/**
 * Transpose multiply two rotations: qT * r
 * 
 * @returns Rot
 * 
 * Inverse rotate a vector
 * 
 * @returns Vec2
 */
Rot.mulT = function(rot, m) {
  if ('c' in m && 's' in m) {
    _ASSERT && Rot.assert(m);
    // [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]
    // [-qs qc] [rs rc] [-qs*rc+qc*rs qs*rs+qc*rc]
    // s = qc * rs - qs * rc
    // c = qc * rc + qs * rs
    var qr = Rot.identity();
    qr.s = rot.c * m.s - rot.s * m.c;
    qr.c = rot.c * m.c + rot.s * m.s;
    return qr;

  } else if ('x' in m && 'y' in m) {
    _ASSERT && Vec2.assert(m);
    return Vec2.neo(rot.c * m.x + rot.s * m.y, -rot.s * m.x + rot.c * m.y);
  }
}

Rot.mulTRot = function(rot, m) {
  _ASSERT && Rot.assert(m);
  // [ qc qs] * [rc -rs] = [qc*rc+qs*rs -qc*rs+qs*rc]
  // [-qs qc] [rs rc] [-qs*rc+qc*rs qs*rs+qc*rc]
  // s = qc * rs - qs * rc
  // c = qc * rc + qs * rs
  var qr = Rot.identity();
  qr.s = rot.c * m.s - rot.s * m.c;
  qr.c = rot.c * m.c + rot.s * m.s;
  return qr;
}

Rot.mulTVec2 = function(rot, m) {
  _ASSERT && Vec2.assert(m);
  return Vec2.neo(rot.c * m.x + rot.s * m.y, -rot.s * m.x + rot.c * m.y);
}


/***/ }),
/* 73 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

module.exports = Sweep;

var common = __webpack_require__(61);
var Math = __webpack_require__(63);
var Vec2 = __webpack_require__(62);
var Rot = __webpack_require__(72);
var Transform = __webpack_require__(74);

/**
 * This describes the motion of a body/shape for TOI computation. Shapes are
 * defined with respect to the body origin, which may not coincide with the
 * center of mass. However, to support dynamics we must interpolate the center
 * of mass position.
 * 
 * @prop {Vec2} localCenter Local center of mass position
 * @prop {Vec2} c World center position
 * @prop {float} a World angle
 * @prop {float} alpha0 Fraction of the current time step in the range [0,1], c0
 *       and a0 are c and a at alpha0.
 */
function Sweep(c, a) {
  _ASSERT && common.assert(typeof c === 'undefined');
  _ASSERT && common.assert(typeof a === 'undefined');
  this.localCenter = Vec2.zero();
  this.c = Vec2.zero();
  this.a = 0;
  this.alpha0 = 0;
  this.c0 = Vec2.zero();
  this.a0 = 0;
}

Sweep.prototype.setTransform = function(xf) {
  var c = Transform.mulVec2(xf, this.localCenter);
  this.c.set(c);
  this.c0.set(c);

  this.a = xf.q.getAngle();
  this.a0 = xf.q.getAngle();
};

Sweep.prototype.setLocalCenter = function(localCenter, xf) {
  this.localCenter.set(localCenter);

  var c = Transform.mulVec2(xf, this.localCenter);
  this.c.set(c);
  this.c0.set(c);
};

/**
 * Get the interpolated transform at a specific time.
 * 
 * @param xf
 * @param beta A factor in [0,1], where 0 indicates alpha0
 */
Sweep.prototype.getTransform = function(xf, beta) {
  beta = typeof beta === 'undefined' ? 0 : beta;
  xf.q.setAngle((1.0 - beta) * this.a0 + beta * this.a);
  xf.p.setCombine((1.0 - beta), this.c0, beta, this.c);

  // shift to origin
  xf.p.sub(Rot.mulVec2(xf.q, this.localCenter));
};

/**
 * Advance the sweep forward, yielding a new initial state.
 * 
 * @param {float} alpha The new initial time
 */
Sweep.prototype.advance = function(alpha) {
  _ASSERT && common.assert(this.alpha0 < 1.0);
  var beta = (alpha - this.alpha0) / (1.0 - this.alpha0);
  this.c0.setCombine(beta, this.c, 1 - beta, this.c0);
  this.a0 = beta * this.a + (1 - beta) * this.a0;
  this.alpha0 = alpha;
};

Sweep.prototype.forward = function() {
  this.a0 = this.a;
  this.c0.set(this.c);
};

/**
 * normalize the angles in radians to be between -pi and pi.
 */
Sweep.prototype.normalize = function() {
  var a0 = Math.mod(this.a0, -Math.PI, +Math.PI);
  this.a -= this.a0 - a0;
  this.a0 = a0;
};

Sweep.prototype.clone = function() {
  var clone = new Sweep();
  clone.localCenter.set(this.localCenter);
  clone.alpha0 = this.alpha0;
  clone.a0 = this.a0;
  clone.a = this.a;
  clone.c0.set(this.c0);
  clone.c.set(this.c);
  return clone;
};

Sweep.prototype.set = function(that) {
  this.localCenter.set(that.localCenter);
  this.alpha0 = that.alpha0;
  this.a0 = that.a0;
  this.a = that.a;
  this.c0.set(that.c0);
  this.c.set(that.c);
};


/***/ }),
/* 74 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

module.exports = Transform;

var common = __webpack_require__(61);
var Vec2 = __webpack_require__(62);
var Rot = __webpack_require__(72);

// TODO merge with Rot

/**
 * A transform contains translation and rotation. It is used to represent the
 * position and orientation of rigid frames. Initialize using a position vector
 * and a rotation.
 *
 * @prop {Vec2} position
 * @prop {Rot} rotation
 */
function Transform(position, rotation) {
  if (!(this instanceof Transform)) {
    return new Transform(position, rotation);
  }
  this.p = Vec2.zero();
  this.q = Rot.identity();
  if (typeof position !== 'undefined') {
    this.p.set(position);
  }
  if (typeof rotation !== 'undefined') {
    this.q.set(rotation);
  }
};

Transform.clone = function(xf) {
  var obj = Object.create(Transform.prototype);
  obj.p = Vec2.clone(xf.p);
  obj.q = Rot.clone(xf.q);
  return obj;
};

Transform.neo = function(position, rotation) {
  var obj = Object.create(Transform.prototype);
  obj.p = Vec2.clone(position);
  obj.q = Rot.clone(rotation);
  return obj;
};

Transform.identity = function() {
  var obj = Object.create(Transform.prototype);
  obj.p = Vec2.zero();
  obj.q = Rot.identity();
  return obj;
};

/**
 * Set this to the identity transform.
 */
Transform.prototype.setIdentity = function() {
  this.p.setZero();
  this.q.setIdentity();
}

/**
 * Set this based on the position and angle.
 */
Transform.prototype.set = function(a, b) {
  if (typeof b === 'undefined') {
    this.p.set(a.p);
    this.q.set(a.q);
  } else {
    this.p.set(a);
    this.q.set(b);
  }
}

Transform.isValid = function(o) {
  return o && Vec2.isValid(o.p) && Rot.isValid(o.q);
}

Transform.assert = function(o) {
  if (!_ASSERT) return;
  if (!Transform.isValid(o)) {
    _DEBUG && common.debug(o);
    throw new Error('Invalid Transform!');
  }
}

/**
 * @param {Transform} a
 * @param {Vec2} b
 * @returns {Vec2}
 *
 * @param {Transform} a
 * @param {Transform} b
 * @returns {Transform}
 */
Transform.mul = function(a, b) {
  _ASSERT && Transform.assert(a);
  if (Array.isArray(b)) {
    var arr = [];
    for (var i = 0; i < b.length; i++) {
      arr[i] = Transform.mul(a, b[i]);
    }
    return arr;

  } else if ('x' in b && 'y' in b) {
    _ASSERT && Vec2.assert(b);
    var x = (a.q.c * b.x - a.q.s * b.y) + a.p.x;
    var y = (a.q.s * b.x + a.q.c * b.y) + a.p.y;
    return Vec2.neo(x, y);

  } else if ('p' in b && 'q' in b) {
    _ASSERT && Transform.assert(b);
    // v2 = A.q.Rot(B.q.Rot(v1) + B.p) + A.p
    // = (A.q * B.q).Rot(v1) + A.q.Rot(B.p) + A.p
    var xf = Transform.identity();
    xf.q = Rot.mulRot(a.q, b.q);
    xf.p = Vec2.add(Rot.mulVec2(a.q, b.p), a.p);
    return xf;
  }
}

/**
 * @deprecated Use mulFn instead.
 */
Transform.mulAll = function(a, b) {
  _ASSERT && Transform.assert(a);
  var arr = [];
  for (var i = 0; i < b.length; i++) {
    arr[i] = Transform.mul(a, b[i]);
  }
  return arr;
}

/**
 * @experimental
 */
Transform.mulFn = function(a) {
  _ASSERT && Transform.assert(a);
  return function(b) {
    return Transform.mul(a, b);
  };
}

Transform.mulVec2 = function(a, b) {
  _ASSERT && Transform.assert(a);
  _ASSERT && Vec2.assert(b);
  var x = (a.q.c * b.x - a.q.s * b.y) + a.p.x;
  var y = (a.q.s * b.x + a.q.c * b.y) + a.p.y;
  return Vec2.neo(x, y);
}

Transform.mulXf = function(a, b) {
  _ASSERT && Transform.assert(a);
  _ASSERT && Transform.assert(b);
  // v2 = A.q.Rot(B.q.Rot(v1) + B.p) + A.p
  // = (A.q * B.q).Rot(v1) + A.q.Rot(B.p) + A.p
  var xf = Transform.identity();
  xf.q = Rot.mulRot(a.q, b.q);
  xf.p = Vec2.add(Rot.mulVec2(a.q, b.p), a.p);
  return xf;
}

/**
 * @param {Transform} a
 * @param {Vec2} b
 * @returns {Vec2}
 *
 * @param {Transform} a
 * @param {Transform} b
 * @returns {Transform}
 */
Transform.mulT = function(a, b) {
  _ASSERT && Transform.assert(a);
  if ('x' in b && 'y' in b) {
    _ASSERT && Vec2.assert(b)
    var px = b.x - a.p.x;
    var py = b.y - a.p.y;
    var x = (a.q.c * px + a.q.s * py);
    var y = (-a.q.s * px + a.q.c * py);
    return Vec2.neo(x, y);

  } else if ('p' in b && 'q' in b) {
    _ASSERT && Transform.assert(b);
    // v2 = A.q' * (B.q * v1 + B.p - A.p)
    // = A.q' * B.q * v1 + A.q' * (B.p - A.p)
    var xf = Transform.identity();
    xf.q.set(Rot.mulTRot(a.q, b.q));
    xf.p.set(Rot.mulTVec2(a.q, Vec2.sub(b.p, a.p)));
    return xf;
  }
}

Transform.mulTVec2 = function(a, b) {
  _ASSERT && Transform.assert(a);
  _ASSERT && Vec2.assert(b)
  var px = b.x - a.p.x;
  var py = b.y - a.p.y;
  var x = (a.q.c * px + a.q.s * py);
  var y = (-a.q.s * px + a.q.c * py);
  return Vec2.neo(x, y);
}

Transform.mulTXf = function(a, b) {
  _ASSERT && Transform.assert(a);
  _ASSERT && Transform.assert(b);
  // v2 = A.q' * (B.q * v1 + B.p - A.p)
  // = A.q' * B.q * v1 + A.q' * (B.p - A.p)
  var xf = Transform.identity();
  xf.q.set(Rot.mulTRot(a.q, b.q));
  xf.p.set(Rot.mulTVec2(a.q, Vec2.sub(b.p, a.p)));
  return xf;
}


/***/ }),
/* 75 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

module.exports = Velocity;

var Vec2 = __webpack_require__(62);

/**
 * @prop {Vec2} v linear
 * @prop {float} w angular
 */
function Velocity() {
  this.v = Vec2.zero();
  this.w = 0;
}


/***/ }),
/* 76 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

module.exports = Position;

var Vec2 = __webpack_require__(62);
var Rot = __webpack_require__(72);

/**
 * @prop {Vec2} c location
 * @prop {float} a angle
 */
function Position() {
  this.c = Vec2.zero();
  this.a = 0;
}

Position.prototype.getTransform = function(xf, p) {
  xf.q.set(this.a);
  xf.p.set(Vec2.sub(this.c, Rot.mulVec2(xf.q, p)));
  return xf;
}


/***/ }),
/* 77 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

module.exports = Fixture;

var common = __webpack_require__(61);
var options = __webpack_require__(60);

var Math = __webpack_require__(63);
var Vec2 = __webpack_require__(62);

var AABB = __webpack_require__(67);

var Shape = __webpack_require__(78);

/**
 * @typedef {Object} FixtureDef
 *
 * A fixture definition is used to create a fixture. This class defines an
 * abstract fixture definition. You can reuse fixture definitions safely.
 * 
 * @prop friction The friction coefficient, usually in the range [0,1]
 * @prop restitution The restitution (elasticity) usually in the range [0,1]
 * @prop density The density, usually in kg/m^2
 * @prop isSensor A sensor shape collects contact information but never
 *       generates a collision response
 * @prop userData
 * @prop filterGroupIndex Zero, positive or negative collision group. Fixtures with same positive groupIndex always collide and fixtures with same
 * negative groupIndex never collide.
 * @prop filterCategoryBits Collision category bit or bits that this fixture belongs
 *       to. If groupIndex is zero or not matching, then at least one bit in this fixture
 * categoryBits should match other fixture maskBits and vice versa.
 * @prop filterMaskBits Collision category bit or bits that this fixture accept for
 *       collision.
 */
var FixtureDef = {
  userData : null,
  friction : 0.2,
  restitution : 0.0,
  density : 0.0,
  isSensor : false,

  filterGroupIndex : 0,
  filterCategoryBits : 0x0001,
  filterMaskBits : 0xFFFF
};

/**
 * This proxy is used internally to connect shape children to the broad-phase.
 */
function FixtureProxy(fixture, childIndex) {
  this.aabb = new AABB();
  this.fixture = fixture;
  this.childIndex = childIndex;
  this.proxyId;
};

/**
 * A fixture is used to attach a shape to a body for collision detection. A
 * fixture inherits its transform from its parent. Fixtures hold additional
 * non-geometric data such as friction, collision filters, etc. Fixtures are
 * created via Body.createFixture.
 * 
 * @param {Body} body
 * @param {Shape|FixtureDef} shape Shape of fixture definition.
 * @param {FixtureDef|number} def Fixture definition or number.
 */
function Fixture(body, shape, def) {
  if (shape.shape) {
    def = shape;
    shape = shape.shape;

  } else if (typeof def === 'number') {
    def = {density : def};
  }

  def = options(def, FixtureDef);

  this.m_body = body;

  this.m_friction = def.friction;
  this.m_restitution = def.restitution;
  this.m_density = def.density;
  this.m_isSensor = def.isSensor;

  this.m_filterGroupIndex = def.filterGroupIndex;
  this.m_filterCategoryBits = def.filterCategoryBits;
  this.m_filterMaskBits = def.filterMaskBits;

  // TODO validate shape
  this.m_shape = shape; //.clone();

  this.m_next = null;

  this.m_proxies = [];
  this.m_proxyCount = 0;

  var childCount = this.m_shape.getChildCount();
  for (var i = 0; i < childCount; ++i) {
    this.m_proxies[i] = new FixtureProxy(this, i);
  }

  this.m_userData = def.userData;
};

/**
 * Re-setup fixture.
 * @private
 */
Fixture.prototype._reset = function() {
  var body = this.getBody();
  var broadPhase = body.m_world.m_broadPhase;
  this.destroyProxies(broadPhase);
  if (this.m_shape._reset) {
    this.m_shape._reset();
  }
  var childCount = this.m_shape.getChildCount();
  for (var i = 0; i < childCount; ++i) {
    this.m_proxies[i] = new FixtureProxy(this, i);
  }
  this.createProxies(broadPhase, body.m_xf);
  body.resetMassData();
};

Fixture.prototype._serialize = function() {
  return {
    friction: this.m_friction,
    restitution: this.m_restitution,
    density: this.m_density,
    isSensor: this.m_isSensor,

    filterGroupIndex: this.m_filterGroupIndex,
    filterCategoryBits: this.m_filterCategoryBits,
    filterMaskBits: this.m_filterMaskBits,

    shape: this.m_shape,
  };
};

Fixture._deserialize = function(data, body, restore) {
  var shape = restore(Shape, data.shape);
  var fixture = shape && new Fixture(body, shape, data);
  return fixture;
};

/**
 * Get the type of the child shape. You can use this to down cast to the
 * concrete shape.
 */
Fixture.prototype.getType = function() {
  return this.m_shape.getType();
}

/**
 * Get the child shape. You can modify the child shape, however you should not
 * change the number of vertices because this will crash some collision caching
 * mechanisms. Manipulating the shape may lead to non-physical behavior.
 */
Fixture.prototype.getShape = function() {
  return this.m_shape;
}
/**
 * A sensor shape collects contact information but never generates a collision
 * response.
 */
Fixture.prototype.isSensor = function() {
  return this.m_isSensor;
}

/**
 * Set if this fixture is a sensor.
 */
Fixture.prototype.setSensor = function(sensor) {
  if (sensor != this.m_isSensor) {
    this.m_body.setAwake(true);
    this.m_isSensor = sensor;
  }
}

/**
 * Get the contact filtering data.
 */
// Fixture.prototype.getFilterData = function() {
//   return this.m_filter;
// }

/**
 * Get the user data that was assigned in the fixture definition. Use this to
 * store your application specific data.
 */
Fixture.prototype.getUserData = function() {
  return this.m_userData;
}

/**
 * Set the user data. Use this to store your application specific data.
 */
Fixture.prototype.setUserData = function(data) {
  this.m_userData = data;
}

/**
 * Get the parent body of this fixture. This is null if the fixture is not
 * attached.
 */
Fixture.prototype.getBody = function() {
  return this.m_body;
}

/**
 * Get the next fixture in the parent body's fixture list.
 */
Fixture.prototype.getNext = function() {
  return this.m_next;
}

/**
 * Get the density of this fixture.
 */
Fixture.prototype.getDensity = function() {
  return this.m_density;
}

/**
 * Set the density of this fixture. This will _not_ automatically adjust the
 * mass of the body. You must call Body.resetMassData to update the body's mass.
 */
Fixture.prototype.setDensity = function(density) {
  _ASSERT && common.assert(Math.isFinite(density) && density >= 0.0);
  this.m_density = density;
}

/**
 * Get the coefficient of friction, usually in the range [0,1].
 */
Fixture.prototype.getFriction = function() {
  return this.m_friction;
}

/**
 * Set the coefficient of friction. This will not change the friction of
 * existing contacts.
 */
Fixture.prototype.setFriction = function(friction) {
  this.m_friction = friction;
}

/**
 * Get the coefficient of restitution.
 */
Fixture.prototype.getRestitution = function() {
  return this.m_restitution;
}

/**
 * Set the coefficient of restitution. This will not change the restitution of
 * existing contacts.
 */
Fixture.prototype.setRestitution = function(restitution) {
  this.m_restitution = restitution;
}

/**
 * Test a point in world coordinates for containment in this fixture.
 */
Fixture.prototype.testPoint = function(p) {
  return this.m_shape.testPoint(this.m_body.getTransform(), p);
}

/**
 * Cast a ray against this shape.
 */
Fixture.prototype.rayCast = function(output, input, childIndex) {
  return this.m_shape.rayCast(output, input, this.m_body.getTransform(), childIndex);
}

/**
 * Get the mass data for this fixture. The mass data is based on the density and
 * the shape. The rotational inertia is about the shape's origin. This operation
 * may be expensive.
 */
Fixture.prototype.getMassData = function(massData) {
  this.m_shape.computeMass(massData, this.m_density);
}

/**
 * Get the fixture's AABB. This AABB may be enlarge and/or stale. If you need a
 * more accurate AABB, compute it using the shape and the body transform.
 */
Fixture.prototype.getAABB = function(childIndex) {
  _ASSERT && common.assert(0 <= childIndex && childIndex < this.m_proxyCount);
  return this.m_proxies[childIndex].aabb;
}

/**
 * These support body activation/deactivation.
 */
Fixture.prototype.createProxies = function(broadPhase, xf) {
  _ASSERT && common.assert(this.m_proxyCount == 0);

  // Create proxies in the broad-phase.
  this.m_proxyCount = this.m_shape.getChildCount();

  for (var i = 0; i < this.m_proxyCount; ++i) {
    var proxy = this.m_proxies[i];
    this.m_shape.computeAABB(proxy.aabb, xf, i);
    proxy.proxyId = broadPhase.createProxy(proxy.aabb, proxy);
  }
}

Fixture.prototype.destroyProxies = function(broadPhase) {
  // Destroy proxies in the broad-phase.
  for (var i = 0; i < this.m_proxyCount; ++i) {
    var proxy = this.m_proxies[i];
    broadPhase.destroyProxy(proxy.proxyId);
    proxy.proxyId = null;
  }

  this.m_proxyCount = 0;
}

/**
 * Updates this fixture proxy in broad-phase (with combined AABB of current and
 * next transformation).
 */
Fixture.prototype.synchronize = function(broadPhase, xf1, xf2) {
  for (var i = 0; i < this.m_proxyCount; ++i) {
    var proxy = this.m_proxies[i];
    // Compute an AABB that covers the swept shape (may miss some rotation
    // effect).
    var aabb1 = new AABB();
    var aabb2 = new AABB();
    this.m_shape.computeAABB(aabb1, xf1, proxy.childIndex);
    this.m_shape.computeAABB(aabb2, xf2, proxy.childIndex);

    proxy.aabb.combine(aabb1, aabb2);

    var displacement = Vec2.sub(xf2.p, xf1.p);

    broadPhase.moveProxy(proxy.proxyId, proxy.aabb, displacement);
  }
}

/**
 * Set the contact filtering data. This will not update contacts until the next
 * time step when either parent body is active and awake. This automatically
 * calls refilter.
 */
Fixture.prototype.setFilterData = function(filter) {
  this.m_filterGroupIndex = filter.groupIndex;
  this.m_filterCategoryBits = filter.categoryBits;
  this.m_filterMaskBits = filter.maskBits;
  this.refilter();
}

Fixture.prototype.getFilterGroupIndex = function() {
  return this.m_filterGroupIndex;
}

Fixture.prototype.setFilterGroupIndex = function(groupIndex) {
  return this.m_filterGroupIndex = groupIndex;
}

Fixture.prototype.getFilterCategoryBits = function() {
  return this.m_filterCategoryBits;
}

Fixture.prototype.setFilterCategoryBits = function(categoryBits) {
  this.m_filterCategoryBits = categoryBits;
}

Fixture.prototype.getFilterMaskBits = function() {
  return this.m_filterMaskBits;
}

Fixture.prototype.setFilterMaskBits = function(maskBits) {
  this.m_filterMaskBits = maskBits;
}

/**
 * Call this if you want to establish collision that was previously disabled by
 * ContactFilter.
 */
Fixture.prototype.refilter = function() {
  if (this.m_body == null) {
    return;
  }

  // Flag associated contacts for filtering.
  var edge = this.m_body.getContactList();
  while (edge) {
    var contact = edge.contact;
    var fixtureA = contact.getFixtureA();
    var fixtureB = contact.getFixtureB();
    if (fixtureA == this || fixtureB == this) {
      contact.flagForFiltering();
    }

    edge = edge.next;
  }

  var world = this.m_body.getWorld();

  if (world == null) {
    return;
  }

  // Touch each proxy so that new pairs may be created
  var broadPhase = world.m_broadPhase;
  for (var i = 0; i < this.m_proxyCount; ++i) {
    broadPhase.touchProxy(this.m_proxies[i].proxyId);
  }
}

/**
 * Implement this method to provide collision filtering, if you want finer
 * control over contact creation.
 * 
 * Return true if contact calculations should be performed between these two
 * fixtures.
 * 
 * Warning: for performance reasons this is only called when the AABBs begin to
 * overlap.
 * 
 * @param {Fixture} that
 */
Fixture.prototype.shouldCollide = function(that) {

  if (that.m_filterGroupIndex === this.m_filterGroupIndex && that.m_filterGroupIndex !== 0) {
    return that.m_filterGroupIndex > 0;
  }

  var collideA = (that.m_filterMaskBits & this.m_filterCategoryBits) !== 0;
  var collideB = (that.m_filterCategoryBits & this.m_filterMaskBits) !== 0;
  var collide = collideA && collideB;
  return collide;
}


/***/ }),
/* 78 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

module.exports = Shape;

var Math = __webpack_require__(63);

/**
 * A shape is used for collision detection. You can create a shape however you
 * like. Shapes used for simulation in World are created automatically when a
 * Fixture is created. Shapes may encapsulate one or more child shapes.
 */
function Shape() {
  this.m_type;
  this.m_radius;
}

Shape.prototype._reset = function() {
};

Shape.prototype._serialize = function() {
  return {};
};

Shape.TYPES = {};

Shape._deserialize = function(data, context, restore) {
  var clazz = Shape.TYPES[data.type];
  return clazz && restore(clazz, data);
};

Shape.isValid = function(shape) {
  return !!shape;
};

Shape.prototype.getRadius = function() {
  return this.m_radius;
};

/**
 * Get the type of this shape. You can use this to down cast to the concrete
 * shape.
 * 
 * @return the shape type.
 */
Shape.prototype.getType = function() {
  return this.m_type;
};

/**
 * @deprecated Shapes should be treated as immutable.
 *
 * clone the concrete shape.
 */
Shape.prototype._clone = function() {
};

/**
 * // Get the number of child primitives.
 */
Shape.prototype.getChildCount = function() {
};

/**
 * Test a point for containment in this shape. This only works for convex
 * shapes.
 * 
 * @param {Transform} xf The shape world transform.
 * @param p A point in world coordinates.
 */
Shape.prototype.testPoint = function(xf, p) {
};

/**
 * Cast a ray against a child shape.
 * 
 * @param {RayCastOutput} output The ray-cast results.
 * @param {RayCastInput} input The ray-cast input parameters.
 * @param {Transform} transform The transform to be applied to the shape.
 * @param childIndex The child shape index
 */
Shape.prototype.rayCast = function(output, input, transform, childIndex) {
};

/**
 * Given a transform, compute the associated axis aligned bounding box for a
 * child shape.
 * 
 * @param {AABB} aabb Returns the axis aligned box.
 * @param {Transform} xf The world transform of the shape.
 * @param childIndex The child shape
 */
Shape.prototype.computeAABB = function(aabb, xf, childIndex) {
};

/**
 * Compute the mass properties of this shape using its dimensions and density.
 * The inertia tensor is computed about the local origin.
 * 
 * @param {MassData} massData Returns the mass data for this shape.
 * @param density The density in kilograms per meter squared.
 */
Shape.prototype.computeMass = function(massData, density) {
};

/**
 * @param {DistanceProxy} proxy
 */
Shape.prototype.computeDistanceProxy = function(proxy) {
};


/***/ }),
/* 79 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

var DEBUG_SOLVER = false;

var common = __webpack_require__(61);

var Math = __webpack_require__(63);
var Vec2 = __webpack_require__(62);
var Transform = __webpack_require__(74);
var Mat22 = __webpack_require__(80);
var Rot = __webpack_require__(72);

var Settings = __webpack_require__(66);
var Manifold = __webpack_require__(81);
var Distance = __webpack_require__(82);

module.exports = Contact;

/**
 * A contact edge is used to connect bodies and contacts together in a contact
 * graph where each body is a node and each contact is an edge. A contact edge
 * belongs to a doubly linked list maintained in each attached body. Each
 * contact has two contact nodes, one for each attached body.
 * 
 * @prop {Contact} contact The contact
 * @prop {ContactEdge} prev The previous contact edge in the body's contact list
 * @prop {ContactEdge} next The next contact edge in the body's contact list
 * @prop {Body} other Provides quick access to the other body attached.
 */
function ContactEdge(contact) {
  this.contact = contact;
  this.prev;
  this.next;
  this.other;
};

/**
 * @function Contact~evaluate
 * 
 * @param manifold
 * @param xfA
 * @param fixtureA
 * @param indexA
 * @param xfB
 * @param fixtureB
 * @param indexB
 */

/**
 * The class manages contact between two shapes. A contact exists for each
 * overlapping AABB in the broad-phase (except if filtered). Therefore a contact
 * object may exist that has no contact points.
 * 
 * @param {Fixture} fA
 * @param {int} indexA
 * @param {Fixture} fB
 * @param {int} indexB
 * @param {Contact~evaluate} evaluateFcn
 */
function Contact(fA, indexA, fB, indexB, evaluateFcn) {
  // Nodes for connecting bodies.
  this.m_nodeA = new ContactEdge(this);
  this.m_nodeB = new ContactEdge(this);

  this.m_fixtureA = fA;
  this.m_fixtureB = fB;

  this.m_indexA = indexA;
  this.m_indexB = indexB;

  this.m_evaluateFcn = evaluateFcn;

  this.m_manifold = new Manifold();

  this.m_prev = null;
  this.m_next = null;

  this.m_toi = 1.0;
  this.m_toiCount = 0;
  // This contact has a valid TOI in m_toi
  this.m_toiFlag = false;

  this.m_friction = mixFriction(this.m_fixtureA.m_friction,
      this.m_fixtureB.m_friction);
  this.m_restitution = mixRestitution(this.m_fixtureA.m_restitution,
      this.m_fixtureB.m_restitution);

  this.m_tangentSpeed = 0.0;

  // This contact can be disabled (by user)
  this.m_enabledFlag = true;

  // Used when crawling contact graph when forming islands.
  this.m_islandFlag = false;

  // Set when the shapes are touching.
  this.m_touchingFlag = false;

  // This contact needs filtering because a fixture filter was changed.
  this.m_filterFlag = false;

  // This bullet contact had a TOI event
  this.m_bulletHitFlag = false;

  this.v_points = []; // VelocityConstraintPoint[maxManifoldPoints]
  this.v_normal = Vec2.zero();
  this.v_normalMass = new Mat22();
  this.v_K = new Mat22();
  this.v_pointCount;

  this.v_tangentSpeed;
  this.v_friction;
  this.v_restitution;

  this.v_invMassA;
  this.v_invMassB;
  this.v_invIA;
  this.v_invIB;

  this.p_localPoints = [] // Vec2[maxManifoldPoints];
  this.p_localNormal = Vec2.zero();
  this.p_localPoint = Vec2.zero();
  this.p_localCenterA = Vec2.zero();
  this.p_localCenterB = Vec2.zero();
  this.p_type; // Manifold.Type
  this.p_radiusA;
  this.p_radiusB;
  this.p_pointCount;

  this.p_invMassA;
  this.p_invMassB;
  this.p_invIA;
  this.p_invIB;
}

Contact.prototype.initConstraint = function(step) {
  var fixtureA = this.m_fixtureA;
  var fixtureB = this.m_fixtureB;

  var shapeA = fixtureA.getShape();
  var shapeB = fixtureB.getShape();

  var bodyA = fixtureA.getBody();
  var bodyB = fixtureB.getBody();

  var manifold = this.getManifold();

  var pointCount = manifold.pointCount;
  _ASSERT && common.assert(pointCount > 0);

  this.v_invMassA = bodyA.m_invMass;
  this.v_invMassB = bodyB.m_invMass;
  this.v_invIA = bodyA.m_invI;
  this.v_invIB = bodyB.m_invI;

  this.v_friction = this.m_friction;
  this.v_restitution = this.m_restitution;
  this.v_tangentSpeed = this.m_tangentSpeed;

  this.v_pointCount = pointCount;

  this.v_K.setZero();
  this.v_normalMass.setZero();

  this.p_invMassA = bodyA.m_invMass;
  this.p_invMassB = bodyB.m_invMass;
  this.p_invIA = bodyA.m_invI;
  this.p_invIB = bodyB.m_invI;
  this.p_localCenterA = Vec2.clone(bodyA.m_sweep.localCenter);
  this.p_localCenterB = Vec2.clone(bodyB.m_sweep.localCenter);

  this.p_radiusA = shapeA.m_radius;
  this.p_radiusB = shapeB.m_radius;

  this.p_type = manifold.type;
  this.p_localNormal = Vec2.clone(manifold.localNormal);
  this.p_localPoint = Vec2.clone(manifold.localPoint);
  this.p_pointCount = pointCount;

  for (var j = 0; j < pointCount; ++j) {
    var cp = manifold.points[j]; // ManifoldPoint
    var vcp = this.v_points[j] = new VelocityConstraintPoint();

    if (step.warmStarting) {
      vcp.normalImpulse = step.dtRatio * cp.normalImpulse;
      vcp.tangentImpulse = step.dtRatio * cp.tangentImpulse;

    } else {
      vcp.normalImpulse = 0.0;
      vcp.tangentImpulse = 0.0;
    }

    vcp.rA.setZero();
    vcp.rB.setZero();
    vcp.normalMass = 0.0;
    vcp.tangentMass = 0.0;
    vcp.velocityBias = 0.0;

    this.p_localPoints[j] = Vec2.clone(cp.localPoint);

  }
};

/**
 * Get the contact manifold. Do not modify the manifold unless you understand
 * the internals of the library.
 */
Contact.prototype.getManifold = function() {
  return this.m_manifold;
}

/**
 * Get the world manifold.
 * 
 * @param {WorldManifold} [worldManifold]
 */
Contact.prototype.getWorldManifold = function(worldManifold) {
  var bodyA = this.m_fixtureA.getBody();
  var bodyB = this.m_fixtureB.getBody();
  var shapeA = this.m_fixtureA.getShape();
  var shapeB = this.m_fixtureB.getShape();

  return this.m_manifold.getWorldManifold(worldManifold, bodyA.getTransform(),
      shapeA.m_radius, bodyB.getTransform(), shapeB.m_radius);
}

/**
 * Enable/disable this contact. This can be used inside the pre-solve contact
 * listener. The contact is only disabled for the current time step (or sub-step
 * in continuous collisions).
 */
Contact.prototype.setEnabled = function(flag) {
  this.m_enabledFlag = !!flag;
}

/**
 * Has this contact been disabled?
 */
Contact.prototype.isEnabled = function() {
  return this.m_enabledFlag;
}

/**
 * Is this contact touching?
 */
Contact.prototype.isTouching = function() {
  return this.m_touchingFlag;
}

/**
 * Get the next contact in the world's contact list.
 */
Contact.prototype.getNext = function() {
  return this.m_next;
}

/**
 * Get fixture A in this contact.
 */
Contact.prototype.getFixtureA = function() {
  return this.m_fixtureA;
}

/**
 * Get fixture B in this contact.
 */
Contact.prototype.getFixtureB = function() {
  return this.m_fixtureB;
}

/**
 * Get the child primitive index for fixture A.
 */
Contact.prototype.getChildIndexA = function() {
  return this.m_indexA;
}

/**
 * Get the child primitive index for fixture B.
 */
Contact.prototype.getChildIndexB = function() {
  return this.m_indexB;
}

/**
 * Flag this contact for filtering. Filtering will occur the next time step.
 */
Contact.prototype.flagForFiltering = function() {
  this.m_filterFlag = true;
}

/**
 * Override the default friction mixture. You can call this in
 * ContactListener.preSolve. This value persists until set or reset.
 */
Contact.prototype.setFriction = function(friction) {
  this.m_friction = friction;
}

/**
 * Get the friction.
 */
Contact.prototype.getFriction = function() {
  return this.m_friction;
}

/**
 * Reset the friction mixture to the default value.
 */
Contact.prototype.resetFriction = function() {
  this.m_friction = mixFriction(this.m_fixtureA.m_friction,
      this.m_fixtureB.m_friction);
}

/**
 * Override the default restitution mixture. You can call this in
 * ContactListener.preSolve. The value persists until you set or reset.
 */
Contact.prototype.setRestitution = function(restitution) {
  this.m_restitution = restitution;
}

/**
 * Get the restitution.
 */
Contact.prototype.getRestitution = function() {
  return this.m_restitution;
}

/**
 * Reset the restitution to the default value.
 */
Contact.prototype.resetRestitution = function() {
  this.m_restitution = mixRestitution(this.m_fixtureA.m_restitution,
      this.m_fixtureB.m_restitution);
}

/**
 * Set the desired tangent speed for a conveyor belt behavior. In meters per
 * second.
 */
Contact.prototype.setTangentSpeed = function(speed) {
  this.m_tangentSpeed = speed;
}

/**
 * Get the desired tangent speed. In meters per second.
 */
Contact.prototype.getTangentSpeed = function() {
  return this.m_tangentSpeed;
}

/**
 * Called by Update method, and implemented by subclasses.
 */
Contact.prototype.evaluate = function(manifold, xfA, xfB) {
  this.m_evaluateFcn(manifold, xfA, this.m_fixtureA, this.m_indexA, xfB,
      this.m_fixtureB, this.m_indexB);
};

/**
 * Updates the contact manifold and touching status.
 * 
 * Note: do not assume the fixture AABBs are overlapping or are valid.
 * 
 * @param {function} listener.beginContact
 * @param {function} listener.endContact
 * @param {function} listener.preSolve
 */
Contact.prototype.update = function(listener) {

  // Re-enable this contact.
  this.m_enabledFlag = true;

  var touching = false;
  var wasTouching = this.m_touchingFlag;

  var sensorA = this.m_fixtureA.isSensor();
  var sensorB = this.m_fixtureB.isSensor();
  var sensor = sensorA || sensorB;

  var bodyA = this.m_fixtureA.getBody();
  var bodyB = this.m_fixtureB.getBody();
  var xfA = bodyA.getTransform();
  var xfB = bodyB.getTransform();

  // Is this contact a sensor?
  if (sensor) {
    var shapeA = this.m_fixtureA.getShape();
    var shapeB = this.m_fixtureB.getShape();
    touching = Distance.testOverlap(shapeA, this.m_indexA, shapeB,
        this.m_indexB, xfA, xfB);

    // Sensors don't generate manifolds.
    this.m_manifold.pointCount = 0;
  } else {

    // TODO reuse manifold
    var oldManifold = this.m_manifold;
    this.m_manifold = new Manifold();

    this.evaluate(this.m_manifold, xfA, xfB);
    touching = this.m_manifold.pointCount > 0;

    // Match old contact ids to new contact ids and copy the
    // stored impulses to warm start the solver.
    for (var i = 0; i < this.m_manifold.pointCount; ++i) {
      var nmp = this.m_manifold.points[i];
      nmp.normalImpulse = 0.0;
      nmp.tangentImpulse = 0.0;

      for (var j = 0; j < oldManifold.pointCount; ++j) {
        var omp = oldManifold.points[j];
        if (omp.id.key == nmp.id.key) { // ContactID.key
          nmp.normalImpulse = omp.normalImpulse;
          nmp.tangentImpulse = omp.tangentImpulse;
          break;
        }
      }
    }

    if (touching != wasTouching) {
      bodyA.setAwake(true);
      bodyB.setAwake(true);
    }
  }

  this.m_touchingFlag = touching;

  if (wasTouching == false && touching == true && listener) {
    listener.beginContact(this);
  }

  if (wasTouching == true && touching == false && listener) {
    listener.endContact(this);
  }

  if (sensor == false && touching && listener) {
    listener.preSolve(this, oldManifold);
  }
}

Contact.prototype.solvePositionConstraint = function(step) {
  return this._solvePositionConstraint(step, false);
}

Contact.prototype.solvePositionConstraintTOI = function(step, toiA, toiB) {
  return this._solvePositionConstraint(step, true, toiA, toiB);
}

Contact.prototype._solvePositionConstraint = function(step, toi, toiA, toiB) {

  var fixtureA = this.m_fixtureA;
  var fixtureB = this.m_fixtureB;

  var bodyA = fixtureA.getBody();
  var bodyB = fixtureB.getBody();

  var velocityA = bodyA.c_velocity;
  var velocityB = bodyB.c_velocity;
  var positionA = bodyA.c_position;
  var positionB = bodyB.c_position;

  var localCenterA = Vec2.clone(this.p_localCenterA);
  var localCenterB = Vec2.clone(this.p_localCenterB);

  var mA = 0.0;
  var iA = 0.0;
  if (!toi || (bodyA == toiA || bodyA == toiB)) {
    mA = this.p_invMassA;
    iA = this.p_invIA;
  }

  var mB = 0.0;
  var iB = 0.0;
  if (!toi || (bodyB == toiA || bodyB == toiB)) {
    mB = this.p_invMassB;
    iB = this.p_invIB;
  }

  var cA = Vec2.clone(positionA.c);
  var aA = positionA.a;

  var cB = Vec2.clone(positionB.c);
  var aB = positionB.a;

  var minSeparation = 0.0;

  // Solve normal constraints
  for (var j = 0; j < this.p_pointCount; ++j) {
    var xfA = Transform.identity();
    var xfB = Transform.identity();
    xfA.q.set(aA);
    xfB.q.set(aB);
    xfA.p = Vec2.sub(cA, Rot.mulVec2(xfA.q, localCenterA));
    xfB.p = Vec2.sub(cB, Rot.mulVec2(xfB.q, localCenterB));

    // PositionSolverManifold
    var normal, point, separation;
    switch (this.p_type) {
    case Manifold.e_circles:
      var pointA = Transform.mulVec2(xfA, this.p_localPoint);
      var pointB = Transform.mulVec2(xfB, this.p_localPoints[0]);
      normal = Vec2.sub(pointB, pointA);
      normal.normalize();
      point = Vec2.combine(0.5, pointA, 0.5, pointB);
      separation = Vec2.dot(Vec2.sub(pointB, pointA), normal) - this.p_radiusA
          - this.p_radiusB;
      break;

    case Manifold.e_faceA:
      normal = Rot.mulVec2(xfA.q, this.p_localNormal);
      var planePoint = Transform.mulVec2(xfA, this.p_localPoint);
      var clipPoint = Transform.mulVec2(xfB, this.p_localPoints[j]);
      separation = Vec2.dot(Vec2.sub(clipPoint, planePoint), normal)
          - this.p_radiusA - this.p_radiusB;
      point = clipPoint;
      break;

    case Manifold.e_faceB:
      normal = Rot.mulVec2(xfB.q, this.p_localNormal);
      var planePoint = Transform.mulVec2(xfB, this.p_localPoint);
      var clipPoint = Transform.mulVec2(xfA, this.p_localPoints[j]);
      separation = Vec2.dot(Vec2.sub(clipPoint, planePoint), normal)
          - this.p_radiusA - this.p_radiusB;
      point = clipPoint;

      // Ensure normal points from A to B
      normal.mul(-1);
      break;
    }

    var rA = Vec2.sub(point, cA);
    var rB = Vec2.sub(point, cB);

    // Track max constraint error.
    minSeparation = Math.min(minSeparation, separation);

    var baumgarte = toi ? Settings.toiBaugarte : Settings.baumgarte;
    var linearSlop = Settings.linearSlop;
    var maxLinearCorrection = Settings.maxLinearCorrection;

    // Prevent large corrections and allow slop.
    var C = Math.clamp(baumgarte * (separation + linearSlop),
        -maxLinearCorrection, 0.0);

    // Compute the effective mass.
    var rnA = Vec2.cross(rA, normal);
    var rnB = Vec2.cross(rB, normal);
    var K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;

    // Compute normal impulse
    var impulse = K > 0.0 ? -C / K : 0.0;

    var P = Vec2.mul(impulse, normal);

    cA.subMul(mA, P);
    aA -= iA * Vec2.cross(rA, P);

    cB.addMul(mB, P);
    aB += iB * Vec2.cross(rB, P);
  }

  positionA.c.set(cA);
  positionA.a = aA;

  positionB.c.set(cB);
  positionB.a = aB;

  return minSeparation;
}

// TODO merge with ManifoldPoint
function VelocityConstraintPoint() {
  this.rA = Vec2.zero();
  this.rB = Vec2.zero();
  this.normalImpulse = 0;
  this.tangentImpulse = 0;
  this.normalMass = 0;
  this.tangentMass = 0;
  this.velocityBias = 0;
}

Contact.prototype.initVelocityConstraint = function(step) {
  var fixtureA = this.m_fixtureA;
  var fixtureB = this.m_fixtureB;

  var bodyA = fixtureA.getBody();
  var bodyB = fixtureB.getBody();

  var velocityA = bodyA.c_velocity;
  var velocityB = bodyB.c_velocity;

  var positionA = bodyA.c_position;
  var positionB = bodyB.c_position;

  var radiusA = this.p_radiusA;
  var radiusB = this.p_radiusB;
  var manifold = this.getManifold();

  var mA = this.v_invMassA;
  var mB = this.v_invMassB;
  var iA = this.v_invIA;
  var iB = this.v_invIB;
  var localCenterA = Vec2.clone(this.p_localCenterA);
  var localCenterB = Vec2.clone(this.p_localCenterB);

  var cA = Vec2.clone(positionA.c);
  var aA = positionA.a;
  var vA = Vec2.clone(velocityA.v);
  var wA = velocityA.w;

  var cB = Vec2.clone(positionB.c);
  var aB = positionB.a;
  var vB = Vec2.clone(velocityB.v);
  var wB = velocityB.w;

  _ASSERT && common.assert(manifold.pointCount > 0);

  var xfA = Transform.identity();
  var xfB = Transform.identity();
  xfA.q.set(aA);
  xfB.q.set(aB);
  xfA.p.setCombine(1, cA, -1, Rot.mulVec2(xfA.q, localCenterA));
  xfB.p.setCombine(1, cB, -1, Rot.mulVec2(xfB.q, localCenterB));

  var worldManifold = manifold.getWorldManifold(null, xfA, radiusA, xfB, radiusB);

  this.v_normal.set(worldManifold.normal);

  for (var j = 0; j < this.v_pointCount; ++j) {
    var vcp = this.v_points[j]; // VelocityConstraintPoint

    vcp.rA.set(Vec2.sub(worldManifold.points[j], cA));
    vcp.rB.set(Vec2.sub(worldManifold.points[j], cB));

    var rnA = Vec2.cross(vcp.rA, this.v_normal);
    var rnB = Vec2.cross(vcp.rB, this.v_normal);

    var kNormal = mA + mB + iA * rnA * rnA + iB * rnB * rnB;

    vcp.normalMass = kNormal > 0.0 ? 1.0 / kNormal : 0.0;

    var tangent = Vec2.cross(this.v_normal, 1.0);

    var rtA = Vec2.cross(vcp.rA, tangent);
    var rtB = Vec2.cross(vcp.rB, tangent);

    var kTangent = mA + mB + iA * rtA * rtA + iB * rtB * rtB;

    vcp.tangentMass = kTangent > 0.0 ? 1.0 / kTangent : 0.0;

    // Setup a velocity bias for restitution.
    vcp.velocityBias = 0.0;
    var vRel = Vec2.dot(this.v_normal, vB)
        + Vec2.dot(this.v_normal, Vec2.cross(wB, vcp.rB))
        - Vec2.dot(this.v_normal, vA)
        - Vec2.dot(this.v_normal, Vec2.cross(wA, vcp.rA));
    if (vRel < -Settings.velocityThreshold) {
      vcp.velocityBias = -this.v_restitution * vRel;
    }
  }

  // If we have two points, then prepare the block solver.
  if (this.v_pointCount == 2 && step.blockSolve) {
    var vcp1 = this.v_points[0]; // VelocityConstraintPoint
    var vcp2 = this.v_points[1]; // VelocityConstraintPoint

    var rn1A = Vec2.cross(vcp1.rA, this.v_normal);
    var rn1B = Vec2.cross(vcp1.rB, this.v_normal);
    var rn2A = Vec2.cross(vcp2.rA, this.v_normal);
    var rn2B = Vec2.cross(vcp2.rB, this.v_normal);

    var k11 = mA + mB + iA * rn1A * rn1A + iB * rn1B * rn1B;
    var k22 = mA + mB + iA * rn2A * rn2A + iB * rn2B * rn2B;
    var k12 = mA + mB + iA * rn1A * rn2A + iB * rn1B * rn2B;

    // Ensure a reasonable condition number.
    var k_maxConditionNumber = 1000.0;
    if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {
      // K is safe to invert.
      this.v_K.ex.set(k11, k12);
      this.v_K.ey.set(k12, k22);
      this.v_normalMass.set(this.v_K.getInverse());
    } else {
      // The constraints are redundant, just use one.
      // TODO_ERIN use deepest?
      this.v_pointCount = 1;
    }
  }

  positionA.c.set(cA);
  positionA.a = aA;
  velocityA.v.set(vA);
  velocityA.w = wA;

  positionB.c.set(cB);
  positionB.a = aB;
  velocityB.v.set(vB);
  velocityB.w = wB;
};

Contact.prototype.warmStartConstraint = function(step) {
  var fixtureA = this.m_fixtureA;
  var fixtureB = this.m_fixtureB;

  var bodyA = fixtureA.getBody();
  var bodyB = fixtureB.getBody();

  var velocityA = bodyA.c_velocity;
  var velocityB = bodyB.c_velocity;
  var positionA = bodyA.c_position;
  var positionB = bodyB.c_position;

  var mA = this.v_invMassA;
  var iA = this.v_invIA;
  var mB = this.v_invMassB;
  var iB = this.v_invIB;

  var vA = Vec2.clone(velocityA.v);
  var wA = velocityA.w;
  var vB = Vec2.clone(velocityB.v);
  var wB = velocityB.w;

  var normal = this.v_normal;
  var tangent = Vec2.cross(normal, 1.0);

  for (var j = 0; j < this.v_pointCount; ++j) {
    var vcp = this.v_points[j]; // VelocityConstraintPoint

    var P = Vec2.combine(vcp.normalImpulse, normal, vcp.tangentImpulse, tangent);
    wA -= iA * Vec2.cross(vcp.rA, P);
    vA.subMul(mA, P);
    wB += iB * Vec2.cross(vcp.rB, P);
    vB.addMul(mB, P);
  }

  velocityA.v.set(vA);
  velocityA.w = wA;
  velocityB.v.set(vB);
  velocityB.w = wB;
};

Contact.prototype.storeConstraintImpulses = function(step) {
  var manifold = this.m_manifold;
  for (var j = 0; j < this.v_pointCount; ++j) {
    manifold.points[j].normalImpulse = this.v_points[j].normalImpulse;
    manifold.points[j].tangentImpulse = this.v_points[j].tangentImpulse;
  }
};

Contact.prototype.solveVelocityConstraint = function(step) {
  var bodyA = this.m_fixtureA.m_body;
  var bodyB = this.m_fixtureB.m_body;

  var velocityA = bodyA.c_velocity;
  var positionA = bodyA.c_position;

  var velocityB = bodyB.c_velocity;
  var positionB = bodyB.c_position;

  var mA = this.v_invMassA;
  var iA = this.v_invIA;
  var mB = this.v_invMassB;
  var iB = this.v_invIB;

  var vA = Vec2.clone(velocityA.v);
  var wA = velocityA.w;
  var vB = Vec2.clone(velocityB.v);
  var wB = velocityB.w;

  var normal = this.v_normal;
  var tangent = Vec2.cross(normal, 1.0);
  var friction = this.v_friction;

  _ASSERT && common.assert(this.v_pointCount == 1 || this.v_pointCount == 2);

  // Solve tangent constraints first because non-penetration is more important
  // than friction.
  for (var j = 0; j < this.v_pointCount; ++j) {
    var vcp = this.v_points[j]; // VelocityConstraintPoint

    // Relative velocity at contact
    var dv = Vec2.zero();
    dv.addCombine(1, vB, 1, Vec2.cross(wB, vcp.rB));
    dv.subCombine(1, vA, 1, Vec2.cross(wA, vcp.rA));

    // Compute tangent force
    var vt = Vec2.dot(dv, tangent) - this.v_tangentSpeed;
    var lambda = vcp.tangentMass * (-vt);

    // Clamp the accumulated force
    var maxFriction = friction * vcp.normalImpulse;
    var newImpulse = Math.clamp(vcp.tangentImpulse + lambda, -maxFriction,
        maxFriction);
    lambda = newImpulse - vcp.tangentImpulse;
    vcp.tangentImpulse = newImpulse;

    // Apply contact impulse
    var P = Vec2.mul(lambda, tangent);

    vA.subMul(mA, P);
    wA -= iA * Vec2.cross(vcp.rA, P);

    vB.addMul(mB, P);
    wB += iB * Vec2.cross(vcp.rB, P);
  }

  // Solve normal constraints
  if (this.v_pointCount == 1 || step.blockSolve == false) {
    for (var i = 0; i < this.v_pointCount; ++i) {
      var vcp = this.v_points[i]; // VelocityConstraintPoint

      // Relative velocity at contact
      var dv = Vec2.zero();
      dv.addCombine(1, vB, 1, Vec2.cross(wB, vcp.rB));
      dv.subCombine(1, vA, 1, Vec2.cross(wA, vcp.rA));

      // Compute normal impulse
      var vn = Vec2.dot(dv, normal);
      var lambda = -vcp.normalMass * (vn - vcp.velocityBias);

      // Clamp the accumulated impulse
      var newImpulse = Math.max(vcp.normalImpulse + lambda, 0.0);
      lambda = newImpulse - vcp.normalImpulse;
      vcp.normalImpulse = newImpulse;

      // Apply contact impulse
      var P = Vec2.mul(lambda, normal);

      vA.subMul(mA, P);
      wA -= iA * Vec2.cross(vcp.rA, P);

      vB.addMul(mB, P);
      wB += iB * Vec2.cross(vcp.rB, P);
    }
  } else {
    // Block solver developed in collaboration with Dirk Gregorius (back in
    // 01/07 on Box2D_Lite).
    // Build the mini LCP for this contact patch
    //
    // vn = A * x + b, vn >= 0, , vn >= 0, x >= 0 and vn_i * x_i = 0 with i =
    // 1..2
    //
    // A = J * W * JT and J = ( -n, -r1 x n, n, r2 x n )
    // b = vn0 - velocityBias
    //
    // The system is solved using the "Total enumeration method" (s. Murty).
    // The complementary constraint vn_i * x_i
    // implies that we must have in any solution either vn_i = 0 or x_i = 0.
    // So for the 2D contact problem the cases
    // vn1 = 0 and vn2 = 0, x1 = 0 and x2 = 0, x1 = 0 and vn2 = 0, x2 = 0 and
    // vn1 = 0 need to be tested. The first valid
    // solution that satisfies the problem is chosen.
    // 
    // In order to account of the accumulated impulse 'a' (because of the
    // iterative nature of the solver which only requires
    // that the accumulated impulse is clamped and not the incremental
    // impulse) we change the impulse variable (x_i).
    //
    // Substitute:
    // 
    // x = a + d
    // 
    // a := old total impulse
    // x := new total impulse
    // d := incremental impulse
    //
    // For the current iteration we extend the formula for the incremental
    // impulse
    // to compute the new total impulse:
    //
    // vn = A * d + b
    // = A * (x - a) + b
    // = A * x + b - A * a
    // = A * x + b'
    // b' = b - A * a;

    var vcp1 = this.v_points[0]; // VelocityConstraintPoint
    var vcp2 = this.v_points[1]; // VelocityConstraintPoint

    var a = Vec2.neo(vcp1.normalImpulse, vcp2.normalImpulse);
    _ASSERT && common.assert(a.x >= 0.0 && a.y >= 0.0);

    // Relative velocity at contact
    var dv1 = Vec2.zero().add(vB).add(Vec2.cross(wB, vcp1.rB)).sub(vA).sub(Vec2.cross(wA, vcp1.rA));
    var dv2 = Vec2.zero().add(vB).add(Vec2.cross(wB, vcp2.rB)).sub(vA).sub(Vec2.cross(wA, vcp2.rA));

    // Compute normal velocity
    var vn1 = Vec2.dot(dv1, normal);
    var vn2 = Vec2.dot(dv2, normal);

    var b = Vec2.neo(vn1 - vcp1.velocityBias, vn2 - vcp2.velocityBias);

    // Compute b'
    b.sub(Mat22.mulVec2(this.v_K, a));

    var k_errorTol = 1e-3;
    // NOT_USED(k_errorTol);

    for (;;) {
      //
      // Case 1: vn = 0
      //
      // 0 = A * x + b'
      //
      // Solve for x:
      //
      // x = - inv(A) * b'
      //
      var x = Mat22.mulVec2(this.v_normalMass, b).neg();

      if (x.x >= 0.0 && x.y >= 0.0) {
        // Get the incremental impulse
        var d = Vec2.sub(x, a);

        // Apply incremental impulse
        var P1 = Vec2.mul(d.x, normal);
        var P2 = Vec2.mul(d.y, normal);

        vA.subCombine(mA, P1, mA, P2);
        wA -= iA * (Vec2.cross(vcp1.rA, P1) + Vec2.cross(vcp2.rA, P2));

        vB.addCombine(mB, P1, mB, P2);
        wB += iB * (Vec2.cross(vcp1.rB, P1) + Vec2.cross(vcp2.rB, P2));

        // Accumulate
        vcp1.normalImpulse = x.x;
        vcp2.normalImpulse = x.y;

        if (DEBUG_SOLVER) {
          // Postconditions
          dv1 = vB + Vec2.cross(wB, vcp1.rB) - vA - Vec2.cross(wA, vcp1.rA);
          dv2 = vB + Vec2.cross(wB, vcp2.rB) - vA - Vec2.cross(wA, vcp2.rA);

          // Compute normal velocity
          vn1 = Dot(dv1, normal);
          vn2 = Dot(dv2, normal);

          _ASSERT && common.assert(Abs(vn1 - vcp1.velocityBias) < k_errorTol);
          _ASSERT && common.assert(Abs(vn2 - vcp2.velocityBias) < k_errorTol);
        }
        break;
      }

      //
      // Case 2: vn1 = 0 and x2 = 0
      //
      // 0 = a11 * x1 + a12 * 0 + b1'
      // vn2 = a21 * x1 + a22 * 0 + b2'
      //
      x.x = -vcp1.normalMass * b.x;
      x.y = 0.0;
      vn1 = 0.0;
      vn2 = this.v_K.ex.y * x.x + b.y;

      if (x.x >= 0.0 && vn2 >= 0.0) {
        // Get the incremental impulse
        var d = Vec2.sub(x, a);

        // Apply incremental impulse
        var P1 = Vec2.mul(d.x, normal);
        var P2 = Vec2.mul(d.y, normal);
        vA.subCombine(mA, P1, mA, P2);
        wA -= iA * (Vec2.cross(vcp1.rA, P1) + Vec2.cross(vcp2.rA, P2));

        vB.addCombine(mB, P1, mB, P2);
        wB += iB * (Vec2.cross(vcp1.rB, P1) + Vec2.cross(vcp2.rB, P2));

        // Accumulate
        vcp1.normalImpulse = x.x;
        vcp2.normalImpulse = x.y;

        if (DEBUG_SOLVER) {
          // Postconditions
          var dv1B = Vec2.add(vB, Vec2.cross(wB, vcp1.rB));
          var dv1A = Vec2.add(vA, Vec2.cross(wA, vcp1.rA));
          var dv1 = Vec2.sub(dv1B, dv1A);

          // Compute normal velocity
          vn1 = Vec2.dot(dv1, normal);

          _ASSERT && common.assert(Math.abs(vn1 - vcp1.velocityBias) < k_errorTol);
        }
        break;
      }

      //
      // Case 3: vn2 = 0 and x1 = 0
      //
      // vn1 = a11 * 0 + a12 * x2 + b1'
      // 0 = a21 * 0 + a22 * x2 + b2'
      //
      x.x = 0.0;
      x.y = -vcp2.normalMass * b.y;
      vn1 = this.v_K.ey.x * x.y + b.x;
      vn2 = 0.0;

      if (x.y >= 0.0 && vn1 >= 0.0) {
        // Resubstitute for the incremental impulse
        var d = Vec2.sub(x, a);

        // Apply incremental impulse
        var P1 = Vec2.mul(d.x, normal);
        var P2 = Vec2.mul(d.y, normal);
        vA.subCombine(mA, P1, mA, P2);
        wA -= iA * (Vec2.cross(vcp1.rA, P1) + Vec2.cross(vcp2.rA, P2));

        vB.addCombine(mB, P1, mB, P2);
        wB += iB * (Vec2.cross(vcp1.rB, P1) + Vec2.cross(vcp2.rB, P2));

        // Accumulate
        vcp1.normalImpulse = x.x;
        vcp2.normalImpulse = x.y;

        if (DEBUG_SOLVER) {
          // Postconditions
          var dv2B = Vec2.add(vB, Vec2.cross(wB, vcp2.rB));
          var dv2A = Vec2.add(vA, Vec2.cross(wA, vcp2.rA));
          var dv1 = Vec2.sub(dv2B, dv2A);

          // Compute normal velocity
          vn2 = Vec2.dot(dv2, normal);

          _ASSERT && common.assert(Math.abs(vn2 - vcp2.velocityBias) < k_errorTol);
        }
        break;
      }

      //
      // Case 4: x1 = 0 and x2 = 0
      // 
      // vn1 = b1
      // vn2 = b2;
      //
      x.x = 0.0;
      x.y = 0.0;
      vn1 = b.x;
      vn2 = b.y;

      if (vn1 >= 0.0 && vn2 >= 0.0) {
        // Resubstitute for the incremental impulse
        var d = Vec2.sub(x, a);

        // Apply incremental impulse
        var P1 = Vec2.mul(d.x, normal);
        var P2 = Vec2.mul(d.y, normal);
        vA.subCombine(mA, P1, mA, P2);
        wA -= iA * (Vec2.cross(vcp1.rA, P1) + Vec2.cross(vcp2.rA, P2));

        vB.addCombine(mB, P1, mB, P2);
        wB += iB * (Vec2.cross(vcp1.rB, P1) + Vec2.cross(vcp2.rB, P2));

        // Accumulate
        vcp1.normalImpulse = x.x;
        vcp2.normalImpulse = x.y;

        break;
      }

      // No solution, give up. This is hit sometimes, but it doesn't seem to
      // matter.
      break;
    }
  }

  velocityA.v.set(vA);
  velocityA.w = wA;

  velocityB.v.set(vB);
  velocityB.w = wB;
};

/**
 * Friction mixing law. The idea is to allow either fixture to drive the
 * restitution to zero. For example, anything slides on ice.
 */
function mixFriction(friction1, friction2) {
  return Math.sqrt(friction1 * friction2);
}

/**
 * Restitution mixing law. The idea is allow for anything to bounce off an
 * inelastic surface. For example, a superball bounces on anything.
 */
function mixRestitution(restitution1, restitution2) {
  return restitution1 > restitution2 ? restitution1 : restitution2;
}

var s_registers = [];

/**
 * @param fn function(fixtureA, indexA, fixtureB, indexB) Contact
 */
Contact.addType = function(type1, type2, callback) {

  s_registers[type1] = s_registers[type1] || {};
  s_registers[type1][type2] = callback;
}

Contact.create = function(fixtureA, indexA, fixtureB, indexB) {
  var typeA = fixtureA.getType(); // Shape.Type
  var typeB = fixtureB.getType(); // Shape.Type

  // TODO: pool contacts
  var contact, evaluateFcn;
  if (evaluateFcn = s_registers[typeA] && s_registers[typeA][typeB]) {
    contact = new Contact(fixtureA, indexA, fixtureB, indexB, evaluateFcn);
  } else if (evaluateFcn = s_registers[typeB] && s_registers[typeB][typeA]) {
    contact = new Contact(fixtureB, indexB, fixtureA, indexA, evaluateFcn);
  } else {
    return null;
  }

  // Contact creation may swap fixtures.
  fixtureA = contact.getFixtureA();
  fixtureB = contact.getFixtureB();
  indexA = contact.getChildIndexA();
  indexB = contact.getChildIndexB();
  var bodyA = fixtureA.getBody();
  var bodyB = fixtureB.getBody();

  // Connect to body A
  contact.m_nodeA.contact = contact;
  contact.m_nodeA.other = bodyB;

  contact.m_nodeA.prev = null;
  contact.m_nodeA.next = bodyA.m_contactList;
  if (bodyA.m_contactList != null) {
    bodyA.m_contactList.prev = contact.m_nodeA;
  }
  bodyA.m_contactList = contact.m_nodeA;

  // Connect to body B
  contact.m_nodeB.contact = contact;
  contact.m_nodeB.other = bodyA;

  contact.m_nodeB.prev = null;
  contact.m_nodeB.next = bodyB.m_contactList;
  if (bodyB.m_contactList != null) {
    bodyB.m_contactList.prev = contact.m_nodeB;
  }
  bodyB.m_contactList = contact.m_nodeB;

  // Wake up the bodies
  if (fixtureA.isSensor() == false && fixtureB.isSensor() == false) {
    bodyA.setAwake(true);
    bodyB.setAwake(true);
  }

  return contact;
}

Contact.destroy = function(contact, listener) {
  var fixtureA = contact.m_fixtureA;
  var fixtureB = contact.m_fixtureB;

  var bodyA = fixtureA.getBody();
  var bodyB = fixtureB.getBody();

  if (contact.isTouching()) {
    listener.endContact(contact);
  }

  // Remove from body 1
  if (contact.m_nodeA.prev) {
    contact.m_nodeA.prev.next = contact.m_nodeA.next;
  }

  if (contact.m_nodeA.next) {
    contact.m_nodeA.next.prev = contact.m_nodeA.prev;
  }

  if (contact.m_nodeA == bodyA.m_contactList) {
    bodyA.m_contactList = contact.m_nodeA.next;
  }

  // Remove from body 2
  if (contact.m_nodeB.prev) {
    contact.m_nodeB.prev.next = contact.m_nodeB.next;
  }

  if (contact.m_nodeB.next) {
    contact.m_nodeB.next.prev = contact.m_nodeB.prev;
  }

  if (contact.m_nodeB == bodyB.m_contactList) {
    bodyB.m_contactList = contact.m_nodeB.next;
  }

  if (contact.m_manifold.pointCount > 0 && fixtureA.isSensor() == false
      && fixtureB.isSensor() == false) {
    bodyA.setAwake(true);
    bodyB.setAwake(true);
  }

  var typeA = fixtureA.getType(); // Shape.Type
  var typeB = fixtureB.getType(); // Shape.Type

  var destroyFcn = s_registers[typeA][typeB].destroyFcn;
  if (typeof destroyFcn === 'function') {
    destroyFcn(contact);
  }
};


/***/ }),
/* 80 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

module.exports = Mat22;

var common = __webpack_require__(61);
var Math = __webpack_require__(63);
var Vec2 = __webpack_require__(62);

/**
 * A 2-by-2 matrix. Stored in column-major order.
 */
function Mat22(a, b, c, d) {
  if (typeof a === 'object' && a !== null) {
    this.ex = Vec2.clone(a);
    this.ey = Vec2.clone(b);
  } else if (typeof a === 'number') {
    this.ex = Vec2.neo(a, c);
    this.ey = Vec2.neo(b, d)
  } else {
    this.ex = Vec2.zero();
    this.ey = Vec2.zero()
  }
};

Mat22.prototype.toString = function() {
  return JSON.stringify(this);
};

Mat22.isValid = function(o) {
  return o && Vec2.isValid(o.ex) && Vec2.isValid(o.ey);
};

Mat22.assert = function(o) {
  if (!_ASSERT) return;
  if (!Mat22.isValid(o)) {
    _DEBUG && common.debug(o);
    throw new Error('Invalid Mat22!');
  }
};

Mat22.prototype.set = function(a, b, c, d) {
  if (typeof a === 'number' && typeof b === 'number' && typeof c === 'number'
      && typeof d === 'number') {
    this.ex.set(a, c);
    this.ey.set(b, d);

  } else if (typeof a === 'object' && typeof b === 'object') {
    this.ex.set(a);
    this.ey.set(b);

  } else if (typeof a === 'object') {
    _ASSERT && Mat22.assert(a);
    this.ex.set(a.ex);
    this.ey.set(a.ey);

  } else {
    _ASSERT && common.assert(false);
  }
}

Mat22.prototype.setIdentity = function() {
  this.ex.x = 1.0;
  this.ey.x = 0.0;
  this.ex.y = 0.0;
  this.ey.y = 1.0;
}

Mat22.prototype.setZero = function() {
  this.ex.x = 0.0;
  this.ey.x = 0.0;
  this.ex.y = 0.0;
  this.ey.y = 0.0;
}

Mat22.prototype.getInverse = function() {
  var a = this.ex.x;
  var b = this.ey.x;
  var c = this.ex.y;
  var d = this.ey.y;
  var det = a * d - b * c;
  if (det != 0.0) {
    det = 1.0 / det;
  }
  var imx = new Mat22();
  imx.ex.x = det * d;
  imx.ey.x = -det * b;
  imx.ex.y = -det * c;
  imx.ey.y = det * a;
  return imx;
}

/**
 * Solve A * x = b, where b is a column vector. This is more efficient than
 * computing the inverse in one-shot cases.
 */
Mat22.prototype.solve = function(v) {
  _ASSERT && Vec2.assert(v);
  var a = this.ex.x;
  var b = this.ey.x;
  var c = this.ex.y;
  var d = this.ey.y;
  var det = a * d - b * c;
  if (det != 0.0) {
    det = 1.0 / det;
  }
  var w = Vec2.zero();
  w.x = det * (d * v.x - b * v.y);
  w.y = det * (a * v.y - c * v.x);
  return w;
}

/**
 * Multiply a matrix times a vector. If a rotation matrix is provided, then this
 * transforms the vector from one frame to another.
 */
Mat22.mul = function(mx, v) {
  if (v && 'x' in v && 'y' in v) {
    _ASSERT && Vec2.assert(v);
    var x = mx.ex.x * v.x + mx.ey.x * v.y;
    var y = mx.ex.y * v.x + mx.ey.y * v.y;
    return Vec2.neo(x, y);

  } else if (v && 'ex' in v && 'ey' in v) { // Mat22
    _ASSERT && Mat22.assert(v);
    // return new Mat22(Vec2.mul(mx, v.ex), Vec2.mul(mx, v.ey));
    var a = mx.ex.x * v.ex.x + mx.ey.x * v.ex.y;
    var b = mx.ex.x * v.ey.x + mx.ey.x * v.ey.y;
    var c = mx.ex.y * v.ex.x + mx.ey.y * v.ex.y;
    var d = mx.ex.y * v.ey.x + mx.ey.y * v.ey.y;
    return new Mat22(a, b, c, d);
  }

  _ASSERT && common.assert(false);
}

Mat22.mulVec2 = function(mx, v) {
  _ASSERT && Vec2.assert(v);
  var x = mx.ex.x * v.x + mx.ey.x * v.y;
  var y = mx.ex.y * v.x + mx.ey.y * v.y;
  return Vec2.neo(x, y);
}

Mat22.mulMat22 = function(mx, v) {
  _ASSERT && Mat22.assert(v);
  // return new Mat22(Vec2.mul(mx, v.ex), Vec2.mul(mx, v.ey));
  var a = mx.ex.x * v.ex.x + mx.ey.x * v.ex.y;
  var b = mx.ex.x * v.ey.x + mx.ey.x * v.ey.y;
  var c = mx.ex.y * v.ex.x + mx.ey.y * v.ex.y;
  var d = mx.ex.y * v.ey.x + mx.ey.y * v.ey.y;
  return new Mat22(a, b, c, d);
  _ASSERT && common.assert(false);
}

/**
 * Multiply a matrix transpose times a vector. If a rotation matrix is provided,
 * then this transforms the vector from one frame to another (inverse
 * transform).
 */
Mat22.mulT = function(mx, v) {
  if (v && 'x' in v && 'y' in v) { // Vec2
    _ASSERT && Vec2.assert(v);
    return Vec2.neo(Vec2.dot(v, mx.ex), Vec2.dot(v, mx.ey));

  } else if (v && 'ex' in v && 'ey' in v) { // Mat22
    _ASSERT && Mat22.assert(v);
    var c1 = Vec2.neo(Vec2.dot(mx.ex, v.ex), Vec2.dot(mx.ey, v.ex));
    var c2 = Vec2.neo(Vec2.dot(mx.ex, v.ey), Vec2.dot(mx.ey, v.ey));
    return new Mat22(c1, c2);
  }

  _ASSERT && common.assert(false);
}

Mat22.mulTVec2 = function(mx, v) {
  _ASSERT && Mat22.assert(mx);
  _ASSERT && Vec2.assert(v);
  return Vec2.neo(Vec2.dot(v, mx.ex), Vec2.dot(v, mx.ey));
}

Mat22.mulTMat22 = function(mx, v) {
  _ASSERT && Mat22.assert(mx);
  _ASSERT && Mat22.assert(v);
  var c1 = Vec2.neo(Vec2.dot(mx.ex, v.ex), Vec2.dot(mx.ey, v.ex));
  var c2 = Vec2.neo(Vec2.dot(mx.ex, v.ey), Vec2.dot(mx.ey, v.ey));
  return new Mat22(c1, c2);
}

Mat22.abs = function(mx) {
  _ASSERT && Mat22.assert(mx);
  return new Mat22(Vec2.abs(mx.ex), Vec2.abs(mx.ey));
}

Mat22.add = function(mx1, mx2) {
  _ASSERT && Mat22.assert(mx1);
  _ASSERT && Mat22.assert(mx2);
  return new Mat22(Vec2.add(mx1.ex, mx2.ex), Vec2.add(mx1.ey, mx2.ey));
}


/***/ }),
/* 81 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

var common = __webpack_require__(61);

var Vec2 = __webpack_require__(62);
var Transform = __webpack_require__(74);
var Math = __webpack_require__(63);
var Rot = __webpack_require__(72);

module.exports = Manifold;
module.exports.clipSegmentToLine = clipSegmentToLine;
module.exports.clipVertex = ClipVertex;
module.exports.getPointStates = getPointStates;
module.exports.PointState = PointState;

// Manifold Type
Manifold.e_circles = 0;
Manifold.e_faceA = 1;
Manifold.e_faceB = 2;

// ContactFeature Type
Manifold.e_vertex = 0;
Manifold.e_face = 1;

/**
 * A manifold for two touching convex shapes. Manifolds are created in `evaluate`
 * method of Contact subclasses.
 * 
 * Supported manifold types are e_faceA or e_faceB for clip point versus plane
 * with radius and e_circles point versus point with radius.
 * 
 * We store contacts in this way so that position correction can account for
 * movement, which is critical for continuous physics. All contact scenarios
 * must be expressed in one of these types. This structure is stored across time
 * steps, so we keep it small.
 * 
 * @prop type e_circle, e_faceA, e_faceB
 * @prop localPoint Usage depends on manifold type:<br>
 *       e_circles: the local center of circleA <br>
 *       e_faceA: the center of faceA <br>
 *       e_faceB: the center of faceB
 * @prop localNormal Usage depends on manifold type:<br>
 *       e_circles: not used <br>
 *       e_faceA: the normal on polygonA <br>
 *       e_faceB: the normal on polygonB
 * @prop points The points of contact {ManifoldPoint[]}
 * @prop pointCount The number of manifold points
 */
function Manifold() {
  this.type;
  this.localNormal = Vec2.zero();
  this.localPoint = Vec2.zero();
  this.points = [ new ManifoldPoint(), new ManifoldPoint() ];
  this.pointCount = 0;
};

/**
 * A manifold point is a contact point belonging to a contact manifold. It holds
 * details related to the geometry and dynamics of the contact points.
 * 
 * This structure is stored across time steps, so we keep it small.
 * 
 * Note: impulses are used for internal caching and may not provide reliable
 * contact forces, especially for high speed collisions.
 * 
 * @prop {Vec2} localPoint Usage depends on manifold type:<br>
 *       e_circles: the local center of circleB<br>
 *       e_faceA: the local center of cirlceB or the clip point of polygonB<br>
 *       e_faceB: the clip point of polygonA.
 * @prop normalImpulse The non-penetration impulse
 * @prop tangentImpulse The friction impulse
 * @prop {ContactID} id Uniquely identifies a contact point between two shapes
 *       to facilatate warm starting
 */
function ManifoldPoint() {
  this.localPoint = Vec2.zero();
  this.normalImpulse = 0;
  this.tangentImpulse = 0;
  this.id = new ContactID();
};

/**
 * Contact ids to facilitate warm starting.
 * 
 * @prop {ContactFeature} cf
 * @prop key Used to quickly compare contact ids.
 * 
 */
function ContactID() {
  this.cf = new ContactFeature();
};

Object.defineProperty(ContactID.prototype, 'key', {
  get: function() {
    return this.cf.indexA + this.cf.indexB * 4 + this.cf.typeA * 16 + this.cf.typeB * 64;
  },
  enumerable: true,
  configurable: true
});

ContactID.prototype.set = function(o) {
  // this.key = o.key;
  this.cf.set(o.cf);
};

/**
 * The features that intersect to form the contact point.
 * 
 * @prop indexA Feature index on shapeA
 * @prop indexB Feature index on shapeB
 * @prop typeA The feature type on shapeA
 * @prop typeB The feature type on shapeB
 */
function ContactFeature() {
  this.indexA;
  this.indexB;
  this.typeA;
  this.typeB;
};

ContactFeature.prototype.set = function(o) {
  this.indexA = o.indexA;
  this.indexB = o.indexB;
  this.typeA = o.typeA;
  this.typeB = o.typeB;
};

/**
 * This is used to compute the current state of a contact manifold.
 * 
 * @prop normal World vector pointing from A to B
 * @prop points World contact point (point of intersection)
 * @prop separations A negative value indicates overlap, in meters
 */
function WorldManifold() {
  this.normal;
  this.points = []; // [maxManifoldPoints]
  this.separations = []; // float[maxManifoldPoints]
};

/**
 * Evaluate the manifold with supplied transforms. This assumes modest motion
 * from the original state. This does not change the point count, impulses, etc.
 * The radii must come from the shapes that generated the manifold.
 * 
 * @param {WorldManifold} [wm]
 */
Manifold.prototype.getWorldManifold = function(wm, xfA, radiusA, xfB, radiusB) {
  if (this.pointCount == 0) {
    return;
  }

  wm = wm || new WorldManifold();

  var normal = wm.normal;
  var points = wm.points;
  var separations = wm.separations;

  // TODO: improve
  switch (this.type) {
  case Manifold.e_circles:
    normal = Vec2.neo(1.0, 0.0);
    var pointA = Transform.mulVec2(xfA, this.localPoint);
    var pointB = Transform.mulVec2(xfB, this.points[0].localPoint);
    var dist = Vec2.sub(pointB, pointA);
    if (Vec2.lengthSquared(dist) > Math.EPSILON * Math.EPSILON) {
      normal.set(dist);
      normal.normalize();
    }
    var cA = pointA.clone().addMul(radiusA, normal);
    var cB = pointB.clone().addMul(-radiusB, normal);
    points[0] = Vec2.mid(cA, cB);
    separations[0] = Vec2.dot(Vec2.sub(cB, cA), normal);
    points.length = 1;
    separations.length = 1;
    break;

  case Manifold.e_faceA:
    normal = Rot.mulVec2(xfA.q, this.localNormal);
    var planePoint = Transform.mulVec2(xfA, this.localPoint);

    for (var i = 0; i < this.pointCount; ++i) {
      var clipPoint = Transform.mulVec2(xfB, this.points[i].localPoint);
      var cA = Vec2.clone(clipPoint).addMul(radiusA - Vec2.dot(Vec2.sub(clipPoint, planePoint), normal), normal);
      var cB = Vec2.clone(clipPoint).subMul(radiusB, normal);
      points[i] = Vec2.mid(cA, cB);
      separations[i] = Vec2.dot(Vec2.sub(cB, cA), normal);
    }
    points.length = this.pointCount;
    separations.length = this.pointCount;
    break;

  case Manifold.e_faceB:
    normal = Rot.mulVec2(xfB.q, this.localNormal);
    var planePoint = Transform.mulVec2(xfB, this.localPoint);

    for (var i = 0; i < this.pointCount; ++i) {
      var clipPoint = Transform.mulVec2(xfA, this.points[i].localPoint);
      var cB = Vec2.combine(1, clipPoint, radiusB - Vec2.dot(Vec2.sub(clipPoint, planePoint), normal), normal);
      var cA = Vec2.combine(1, clipPoint, -radiusA, normal);
      points[i] = Vec2.mid(cA, cB);
      separations[i] = Vec2.dot(Vec2.sub(cA, cB), normal);
    }
    points.length = this.pointCount;
    separations.length = this.pointCount;
    // Ensure normal points from A to B.
    normal.mul(-1);
    break;
  }

  wm.normal = normal;
  wm.points = points;
  wm.separations = separations;
  return wm;
}

/**
 * This is used for determining the state of contact points.
 * 
 * @prop {0} nullState Point does not exist
 * @prop {1} addState Point was added in the update
 * @prop {2} persistState Point persisted across the update
 * @prop {3} removeState Point was removed in the update
 */
var PointState = {
  // TODO: use constants
  nullState : 0,
  addState : 1,
  persistState : 2,
  removeState : 3
};

/**
 * Compute the point states given two manifolds. The states pertain to the
 * transition from manifold1 to manifold2. So state1 is either persist or remove
 * while state2 is either add or persist.
 * 
 * @param {PointState[Settings.maxManifoldPoints]} state1
 * @param {PointState[Settings.maxManifoldPoints]} state2
 */
function getPointStates(state1, state2, manifold1, manifold2) {
  // for (var i = 0; i < Settings.maxManifoldPoints; ++i) {
  // state1[i] = PointState.nullState;
  // state2[i] = PointState.nullState;
  // }

  // Detect persists and removes.
  for (var i = 0; i < manifold1.pointCount; ++i) {
    var id = manifold1.points[i].id;// ContactID

    state1[i] = PointState.removeState;

    for (var j = 0; j < manifold2.pointCount; ++j) {
      if (manifold2.points[j].id.key == id.key) {
        state1[i] = PointState.persistState;
        break;
      }
    }
  }

  // Detect persists and adds.
  for (var i = 0; i < manifold2.pointCount; ++i) {
    var id = manifold2.points[i].id;// ContactID

    state2[i] = PointState.addState;

    for (var j = 0; j < manifold1.pointCount; ++j) {
      if (manifold1.points[j].id.key == id.key) {
        state2[i] = PointState.persistState;
        break;
      }
    }
  }
}

/**
 * Used for computing contact manifolds.
 * 
 * @prop {Vec2} v
 * @prop {ContactID} id
 */
function ClipVertex() {
  this.v = Vec2.zero();
  this.id = new ContactID();
};

ClipVertex.prototype.set = function(o) {
  this.v.set(o.v);
  this.id.set(o.id);
};

/**
 * Clipping for contact manifolds. Sutherland-Hodgman clipping.
 * 
 * @param {ClipVertex[2]} vOut
 * @param {ClipVertex[2]} vIn
 */
function clipSegmentToLine(vOut, vIn, normal, offset, vertexIndexA) {
  // Start with no output points
  var numOut = 0;

  // Calculate the distance of end points to the line
  var distance0 = Vec2.dot(normal, vIn[0].v) - offset;
  var distance1 = Vec2.dot(normal, vIn[1].v) - offset;

  // If the points are behind the plane
  if (distance0 <= 0.0)
    vOut[numOut++].set(vIn[0]);
  if (distance1 <= 0.0)
    vOut[numOut++].set(vIn[1]);

  // If the points are on different sides of the plane
  if (distance0 * distance1 < 0.0) {
    // Find intersection point of edge and plane
    var interp = distance0 / (distance0 - distance1);
    vOut[numOut].v.setCombine(1 - interp, vIn[0].v, interp, vIn[1].v);

    // VertexA is hitting edgeB.
    vOut[numOut].id.cf.indexA = vertexIndexA;
    vOut[numOut].id.cf.indexB = vIn[0].id.cf.indexB;
    vOut[numOut].id.cf.typeA = Manifold.e_vertex;
    vOut[numOut].id.cf.typeB = Manifold.e_face;
    ++numOut;
  }

  return numOut;
}


/***/ }),
/* 82 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

module.exports = Distance;

module.exports.Input = DistanceInput;
module.exports.Output = DistanceOutput;
module.exports.Proxy = DistanceProxy;
module.exports.Cache = SimplexCache;

var Settings = __webpack_require__(66);
var common = __webpack_require__(61);

var stats = __webpack_require__(83);

var Math = __webpack_require__(63);
var Vec2 = __webpack_require__(62);
var Vec3 = __webpack_require__(84);
var Mat22 = __webpack_require__(80);
var Mat33 = __webpack_require__(85);
var Rot = __webpack_require__(72);
var Sweep = __webpack_require__(73);
var Transform = __webpack_require__(74);
var Velocity = __webpack_require__(75);
var Position = __webpack_require__(76);

/**
 * GJK using Voronoi regions (Christer Ericson) and Barycentric coordinates.
 */

stats.gjkCalls = 0;
stats.gjkIters = 0;
stats.gjkMaxIters = 0;

/**
 * Input for Distance. You have to option to use the shape radii in the
 * computation. Even
 */
function DistanceInput() {
  this.proxyA = new DistanceProxy();
  this.proxyB = new DistanceProxy();
  this.transformA = null;
  this.transformB = null;
  this.useRadii = false;
};

/**
 * Output for Distance.
 *
 * @prop {Vec2} pointA closest point on shapeA
 * @prop {Vec2} pointB closest point on shapeB
 * @prop distance
 * @prop iterations number of GJK iterations used
 */
function DistanceOutput() {
  this.pointA = Vec2.zero();
  this.pointB = Vec2.zero();
  this.distance;
  this.iterations;
}

/**
 * Used to warm start Distance. Set count to zero on first call.
 *
 * @prop {number} metric length or area
 * @prop {array} indexA vertices on shape A
 * @prop {array} indexB vertices on shape B
 * @prop {number} count
 */
function SimplexCache() {
  this.metric = 0;
  this.indexA = [];
  this.indexB = [];
  this.count = 0;
};

/**
 * Compute the closest points between two shapes. Supports any combination of:
 * CircleShape, PolygonShape, EdgeShape. The simplex cache is input/output. On
 * the first call set SimplexCache.count to zero.
 *
 * @param {DistanceOutput} output
 * @param {SimplexCache} cache
 * @param {DistanceInput} input
 */
function Distance(output, cache, input) {
  ++stats.gjkCalls;

  var proxyA = input.proxyA;
  var proxyB = input.proxyB;
  var xfA = input.transformA;
  var xfB = input.transformB;

  // Initialize the simplex.
  var simplex = new Simplex();
  simplex.readCache(cache, proxyA, xfA, proxyB, xfB);

  // Get simplex vertices as an array.
  var vertices = simplex.m_v;// SimplexVertex
  var k_maxIters = Settings.maxDistnceIterations;

  // These store the vertices of the last simplex so that we
  // can check for duplicates and prevent cycling.
  var saveA = [];
  var saveB = []; // int[3]
  var saveCount = 0;

  var distanceSqr1 = Infinity;
  var distanceSqr2 = Infinity;

  // Main iteration loop.
  var iter = 0;
  while (iter < k_maxIters) {
    // Copy simplex so we can identify duplicates.
    saveCount = simplex.m_count;
    for (var i = 0; i < saveCount; ++i) {
      saveA[i] = vertices[i].indexA;
      saveB[i] = vertices[i].indexB;
    }

    simplex.solve();

    // If we have 3 points, then the origin is in the corresponding triangle.
    if (simplex.m_count == 3) {
      break;
    }

    // Compute closest point.
    var p = simplex.getClosestPoint();
    distanceSqr2 = p.lengthSquared();

    // Ensure progress
    if (distanceSqr2 >= distanceSqr1) {
      // break;
    }
    distanceSqr1 = distanceSqr2;

    // Get search direction.
    var d = simplex.getSearchDirection();

    // Ensure the search direction is numerically fit.
    if (d.lengthSquared() < Math.EPSILON * Math.EPSILON) {
      // The origin is probably contained by a line segment
      // or triangle. Thus the shapes are overlapped.

      // We can't return zero here even though there may be overlap.
      // In case the simplex is a point, segment, or triangle it is difficult
      // to determine if the origin is contained in the CSO or very close to it.
      break;
    }

    // Compute a tentative new simplex vertex using support points.
    var vertex = vertices[simplex.m_count]; // SimplexVertex

    vertex.indexA = proxyA.getSupport(Rot.mulTVec2(xfA.q, Vec2.neg(d)));
    vertex.wA = Transform.mulVec2(xfA, proxyA.getVertex(vertex.indexA));

    vertex.indexB = proxyB.getSupport(Rot.mulTVec2(xfB.q, d));
    vertex.wB = Transform.mulVec2(xfB, proxyB.getVertex(vertex.indexB));

    vertex.w = Vec2.sub(vertex.wB, vertex.wA);

    // Iteration count is equated to the number of support point calls.
    ++iter;
    ++stats.gjkIters;

    // Check for duplicate support points. This is the main termination
    // criteria.
    var duplicate = false;
    for (var i = 0; i < saveCount; ++i) {
      if (vertex.indexA == saveA[i] && vertex.indexB == saveB[i]) {
        duplicate = true;
        break;
      }
    }

    // If we found a duplicate support point we must exit to avoid cycling.
    if (duplicate) {
      break;
    }

    // New vertex is ok and needed.
    ++simplex.m_count;
  }

  stats.gjkMaxIters = Math.max(stats.gjkMaxIters, iter);

  // Prepare output.
  simplex.getWitnessPoints(output.pointA, output.pointB);
  output.distance = Vec2.distance(output.pointA, output.pointB);
  output.iterations = iter;

  // Cache the simplex.
  simplex.writeCache(cache);

  // Apply radii if requested.
  if (input.useRadii) {
    var rA = proxyA.m_radius;
    var rB = proxyB.m_radius;

    if (output.distance > rA + rB && output.distance > Math.EPSILON) {
      // Shapes are still no overlapped.
      // Move the witness points to the outer surface.
      output.distance -= rA + rB;
      var normal = Vec2.sub(output.pointB, output.pointA);
      normal.normalize();
      output.pointA.addMul(rA, normal);
      output.pointB.subMul(rB, normal);
    } else {
      // Shapes are overlapped when radii are considered.
      // Move the witness points to the middle.
      var p = Vec2.mid(output.pointA, output.pointB);
      output.pointA.set(p);
      output.pointB.set(p);
      output.distance = 0.0;
    }
  }
}

/**
 * A distance proxy is used by the GJK algorithm. It encapsulates any shape.
 */
function DistanceProxy() {
  this.m_buffer = []; // Vec2[2]
  this.m_vertices = []; // Vec2[]
  this.m_count = 0;
  this.m_radius = 0;
};

/**
 * Get the vertex count.
 */
DistanceProxy.prototype.getVertexCount = function() {
  return this.m_count;
}

/**
 * Get a vertex by index. Used by Distance.
 */
DistanceProxy.prototype.getVertex = function(index) {
  _ASSERT && common.assert(0 <= index && index < this.m_count);
  return this.m_vertices[index];
}

/**
 * Get the supporting vertex index in the given direction.
 */
DistanceProxy.prototype.getSupport = function(d) {
  var bestIndex = 0;
  var bestValue = Vec2.dot(this.m_vertices[0], d);
  for (var i = 0; i < this.m_count; ++i) {
    var value = Vec2.dot(this.m_vertices[i], d);
    if (value > bestValue) {
      bestIndex = i;
      bestValue = value;
    }
  }
  return bestIndex;
}

/**
 * Get the supporting vertex in the given direction.
 */
DistanceProxy.prototype.getSupportVertex = function(d) {
  return this.m_vertices[this.getSupport(d)];
}

/**
 * Initialize the proxy using the given shape. The shape must remain in scope
 * while the proxy is in use.
 */
DistanceProxy.prototype.set = function(shape, index) {
  // TODO remove, use shape instead
  _ASSERT && common.assert(typeof shape.computeDistanceProxy === 'function');
  shape.computeDistanceProxy(this, index);
}

function SimplexVertex() {
  this.indexA; // wA index
  this.indexB; // wB index
  this.wA = Vec2.zero(); // support point in proxyA
  this.wB = Vec2.zero(); // support point in proxyB
  this.w = Vec2.zero(); // wB - wA
  this.a; // barycentric coordinate for closest point
};

SimplexVertex.prototype.set = function(v) {
  this.indexA = v.indexA;
  this.indexB = v.indexB;
  this.wA = Vec2.clone(v.wA);
  this.wB = Vec2.clone(v.wB);
  this.w = Vec2.clone(v.w);
  this.a = v.a;
};

function Simplex() {
  this.m_v1 = new SimplexVertex();
  this.m_v2 = new SimplexVertex();
  this.m_v3 = new SimplexVertex();
  this.m_v = [ this.m_v1, this.m_v2, this.m_v3 ];
  this.m_count;
};

Simplex.prototype.print = function() {
  if (this.m_count == 3) {
    return ["+" + this.m_count,
      this.m_v1.a, this.m_v1.wA.x, this.m_v1.wA.y, this.m_v1.wB.x, this.m_v1.wB.y,
      this.m_v2.a, this.m_v2.wA.x, this.m_v2.wA.y, this.m_v2.wB.x, this.m_v2.wB.y,
      this.m_v3.a, this.m_v3.wA.x, this.m_v3.wA.y, this.m_v3.wB.x, this.m_v3.wB.y
    ].toString();

  } else if (this.m_count == 2) {
    return ["+" + this.m_count,
      this.m_v1.a, this.m_v1.wA.x, this.m_v1.wA.y, this.m_v1.wB.x, this.m_v1.wB.y,
      this.m_v2.a, this.m_v2.wA.x, this.m_v2.wA.y, this.m_v2.wB.x, this.m_v2.wB.y
    ].toString();

  } else if (this.m_count == 1) {
    return ["+" + this.m_count,
      this.m_v1.a, this.m_v1.wA.x, this.m_v1.wA.y, this.m_v1.wB.x, this.m_v1.wB.y
    ].toString();

  } else {
    return "+" + this.m_count;
  }
};

// (SimplexCache, DistanceProxy, ...)
Simplex.prototype.readCache = function(cache, proxyA, transformA, proxyB, transformB) {
  _ASSERT && common.assert(cache.count <= 3);

  // Copy data from cache.
  this.m_count = cache.count;
  for (var i = 0; i < this.m_count; ++i) {
    var v = this.m_v[i];
    v.indexA = cache.indexA[i];
    v.indexB = cache.indexB[i];
    var wALocal = proxyA.getVertex(v.indexA);
    var wBLocal = proxyB.getVertex(v.indexB);
    v.wA = Transform.mulVec2(transformA, wALocal);
    v.wB = Transform.mulVec2(transformB, wBLocal);
    v.w = Vec2.sub(v.wB, v.wA);
    v.a = 0.0;
  }

  // Compute the new simplex metric, if it is substantially different than
  // old metric then flush the simplex.
  if (this.m_count > 1) {
    var metric1 = cache.metric;
    var metric2 = this.getMetric();
    if (metric2 < 0.5 * metric1 || 2.0 * metric1 < metric2
        || metric2 < Math.EPSILON) {
      // Reset the simplex.
      this.m_count = 0;
    }
  }

  // If the cache is empty or invalid...
  if (this.m_count == 0) {
    var v = this.m_v[0];// SimplexVertex
    v.indexA = 0;
    v.indexB = 0;
    var wALocal = proxyA.getVertex(0);
    var wBLocal = proxyB.getVertex(0);
    v.wA = Transform.mulVec2(transformA, wALocal);
    v.wB = Transform.mulVec2(transformB, wBLocal);
    v.w = Vec2.sub(v.wB, v.wA);
    v.a = 1.0;
    this.m_count = 1;
  }
}

// (SimplexCache)
Simplex.prototype.writeCache = function(cache) {
  cache.metric = this.getMetric();
  cache.count = this.m_count;
  for (var i = 0; i < this.m_count; ++i) {
    cache.indexA[i] = this.m_v[i].indexA;
    cache.indexB[i] = this.m_v[i].indexB;
  }
}

Simplex.prototype.getSearchDirection = function() {
  switch (this.m_count) {
  case 1:
    return Vec2.neg(this.m_v1.w);

  case 2: {
    var e12 = Vec2.sub(this.m_v2.w, this.m_v1.w);
    var sgn = Vec2.cross(e12, Vec2.neg(this.m_v1.w));
    if (sgn > 0.0) {
      // Origin is left of e12.
      return Vec2.cross(1.0, e12);
    } else {
      // Origin is right of e12.
      return Vec2.cross(e12, 1.0);
    }
  }

  default:
    _ASSERT && common.assert(false);
    return Vec2.zero();
  }
}

Simplex.prototype.getClosestPoint = function() {
  switch (this.m_count) {
  case 0:
    _ASSERT && common.assert(false);
    return Vec2.zero();

  case 1:
    return Vec2.clone(this.m_v1.w);

  case 2:
    return Vec2.combine(this.m_v1.a, this.m_v1.w, this.m_v2.a, this.m_v2.w);

  case 3:
    return Vec2.zero();

  default:
    _ASSERT && common.assert(false);
    return Vec2.zero();
  }
}

Simplex.prototype.getWitnessPoints = function(pA, pB) {
  switch (this.m_count) {
  case 0:
    _ASSERT && common.assert(false);
    break;

  case 1:
    pA.set(this.m_v1.wA);
    pB.set(this.m_v1.wB);
    break;

  case 2:
    pA.setCombine(this.m_v1.a, this.m_v1.wA, this.m_v2.a, this.m_v2.wA);
    pB.setCombine(this.m_v1.a, this.m_v1.wB, this.m_v2.a, this.m_v2.wB);
    break;

  case 3:
    pA.setCombine(this.m_v1.a, this.m_v1.wA, this.m_v2.a, this.m_v2.wA);
    pA.addMul(this.m_v3.a, this.m_v3.wA);
    pB.set(pA);
    break;

  default:
    _ASSERT && common.assert(false);
    break;
  }
}

Simplex.prototype.getMetric = function() {
  switch (this.m_count) {
  case 0:
    _ASSERT && common.assert(false);
    return 0.0;

  case 1:
    return 0.0;

  case 2:
    return Vec2.distance(this.m_v1.w, this.m_v2.w);

  case 3:
    return Vec2.cross(Vec2.sub(this.m_v2.w, this.m_v1.w), Vec2.sub(this.m_v3.w,
        this.m_v1.w));

  default:
    _ASSERT && common.assert(false);
    return 0.0;
  }
}

Simplex.prototype.solve = function() {
  switch (this.m_count) {
  case 1:
    break;

  case 2:
    this.solve2();
    break;

  case 3:
    this.solve3();
    break;

  default:
    _ASSERT && common.assert(false);
  }
}

// Solve a line segment using barycentric coordinates.
//
// p = a1 * w1 + a2 * w2
// a1 + a2 = 1
//
// The vector from the origin to the closest point on the line is
// perpendicular to the line.
// e12 = w2 - w1
// dot(p, e) = 0
// a1 * dot(w1, e) + a2 * dot(w2, e) = 0
//
// 2-by-2 linear system
// [1 1 ][a1] = [1]
// [w1.e12 w2.e12][a2] = [0]
//
// Define
// d12_1 = dot(w2, e12)
// d12_2 = -dot(w1, e12)
// d12 = d12_1 + d12_2
//
// Solution
// a1 = d12_1 / d12
// a2 = d12_2 / d12
Simplex.prototype.solve2 = function() {
  var w1 = this.m_v1.w;
  var w2 = this.m_v2.w;
  var e12 = Vec2.sub(w2, w1);

  // w1 region
  var d12_2 = -Vec2.dot(w1, e12);
  if (d12_2 <= 0.0) {
    // a2 <= 0, so we clamp it to 0
    this.m_v1.a = 1.0;
    this.m_count = 1;
    return;
  }

  // w2 region
  var d12_1 = Vec2.dot(w2, e12);
  if (d12_1 <= 0.0) {
    // a1 <= 0, so we clamp it to 0
    this.m_v2.a = 1.0;
    this.m_count = 1;
    this.m_v1.set(this.m_v2);
    return;
  }

  // Must be in e12 region.
  var inv_d12 = 1.0 / (d12_1 + d12_2);
  this.m_v1.a = d12_1 * inv_d12;
  this.m_v2.a = d12_2 * inv_d12;
  this.m_count = 2;
}

// Possible regions:
// - points[2]
// - edge points[0]-points[2]
// - edge points[1]-points[2]
// - inside the triangle
Simplex.prototype.solve3 = function() {
  var w1 = this.m_v1.w;
  var w2 = this.m_v2.w;
  var w3 = this.m_v3.w;

  // Edge12
  // [1 1 ][a1] = [1]
  // [w1.e12 w2.e12][a2] = [0]
  // a3 = 0
  var e12 = Vec2.sub(w2, w1);
  var w1e12 = Vec2.dot(w1, e12);
  var w2e12 = Vec2.dot(w2, e12);
  var d12_1 = w2e12;
  var d12_2 = -w1e12;

  // Edge13
  // [1 1 ][a1] = [1]
  // [w1.e13 w3.e13][a3] = [0]
  // a2 = 0
  var e13 = Vec2.sub(w3, w1);
  var w1e13 = Vec2.dot(w1, e13);
  var w3e13 = Vec2.dot(w3, e13);
  var d13_1 = w3e13;
  var d13_2 = -w1e13;

  // Edge23
  // [1 1 ][a2] = [1]
  // [w2.e23 w3.e23][a3] = [0]
  // a1 = 0
  var e23 = Vec2.sub(w3, w2);// Vec2
  var w2e23 = Vec2.dot(w2, e23);
  var w3e23 = Vec2.dot(w3, e23);
  var d23_1 = w3e23;
  var d23_2 = -w2e23;

  // Triangle123
  var n123 = Vec2.cross(e12, e13);

  var d123_1 = n123 * Vec2.cross(w2, w3);
  var d123_2 = n123 * Vec2.cross(w3, w1);
  var d123_3 = n123 * Vec2.cross(w1, w2);

  // w1 region
  if (d12_2 <= 0.0 && d13_2 <= 0.0) {
    this.m_v1.a = 1.0;
    this.m_count = 1;
    return;
  }

  // e12
  if (d12_1 > 0.0 && d12_2 > 0.0 && d123_3 <= 0.0) {
    var inv_d12 = 1.0 / (d12_1 + d12_2);
    this.m_v1.a = d12_1 * inv_d12;
    this.m_v2.a = d12_2 * inv_d12;
    this.m_count = 2;
    return;
  }

  // e13
  if (d13_1 > 0.0 && d13_2 > 0.0 && d123_2 <= 0.0) {
    var inv_d13 = 1.0 / (d13_1 + d13_2);
    this.m_v1.a = d13_1 * inv_d13;
    this.m_v3.a = d13_2 * inv_d13;
    this.m_count = 2;
    this.m_v2.set(this.m_v3);
    return;
  }

  // w2 region
  if (d12_1 <= 0.0 && d23_2 <= 0.0) {
    this.m_v2.a = 1.0;
    this.m_count = 1;
    this.m_v1.set(this.m_v2);
    return;
  }

  // w3 region
  if (d13_1 <= 0.0 && d23_1 <= 0.0) {
    this.m_v3.a = 1.0;
    this.m_count = 1;
    this.m_v1.set(this.m_v3);
    return;
  }

  // e23
  if (d23_1 > 0.0 && d23_2 > 0.0 && d123_1 <= 0.0) {
    var inv_d23 = 1.0 / (d23_1 + d23_2);
    this.m_v2.a = d23_1 * inv_d23;
    this.m_v3.a = d23_2 * inv_d23;
    this.m_count = 2;
    this.m_v1.set(this.m_v3);
    return;
  }

  // Must be in triangle123
  var inv_d123 = 1.0 / (d123_1 + d123_2 + d123_3);
  this.m_v1.a = d123_1 * inv_d123;
  this.m_v2.a = d123_2 * inv_d123;
  this.m_v3.a = d123_3 * inv_d123;
  this.m_count = 3;
}

/**
 * Determine if two generic shapes overlap.
 */
Distance.testOverlap = function(shapeA, indexA, shapeB, indexB, xfA, xfB) {
  var input = new DistanceInput();
  input.proxyA.set(shapeA, indexA);
  input.proxyB.set(shapeB, indexB);
  input.transformA = xfA;
  input.transformB = xfB;
  input.useRadii = true;

  var cache = new SimplexCache();

  var output = new DistanceOutput();
  Distance(output, cache, input);

  return output.distance < 10.0 * Math.EPSILON;
}


/***/ }),
/* 83 */
/***/ ((__unused_webpack_module, exports) => {

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

exports.toString = function(newline) {
  newline = typeof newline === 'string' ? newline : '\n';
  var string = "";
  for (var name in this) {
    if (typeof this[name] !== 'function' && typeof this[name] !== 'object') {
      string += name + ': ' + this[name] + newline;
    }
  }
  return string;
};

/***/ }),
/* 84 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

module.exports = Vec3;

var common = __webpack_require__(61);
var Math = __webpack_require__(63);

function Vec3(x, y, z) {
  if (!(this instanceof Vec3)) {
    return new Vec3(x, y, z);
  }
  if (typeof x === 'undefined') {
    this.x = 0, this.y = 0, this.z = 0;
  } else if (typeof x === 'object') {
    this.x = x.x, this.y = x.y, this.z = x.z;
  } else {
    this.x = x, this.y = y, this.z = z;
  }
  _ASSERT && Vec3.assert(this);
};

Vec3.prototype._serialize = function() {
  return {
    x: this.x,
    y: this.y,
    z: this.z
  };
};

Vec3._deserialize = function(data) {
  var obj = Object.create(Vec3.prototype);
  obj.x = data.x;
  obj.y = data.y;
  obj.z = data.z;
  return obj;
};

Vec3.neo = function(x, y, z) {
  var obj = Object.create(Vec3.prototype);
  obj.x = x;
  obj.y = y;
  obj.z = z;
  return obj;
};

Vec3.clone = function(v) {
  _ASSERT && Vec3.assert(v);
  return Vec3.neo(v.x, v.y, v.z);
};

Vec3.prototype.toString = function() {
  return JSON.stringify(this);
};

/**
 * Does this vector contain finite coordinates?
 */
Vec3.isValid = function(v) {
  return v && Math.isFinite(v.x) && Math.isFinite(v.y) && Math.isFinite(v.z);
}

Vec3.assert = function(o) {
  if (!_ASSERT) return;
  if (!Vec3.isValid(o)) {
    _DEBUG && common.debug(o);
    throw new Error('Invalid Vec3!');
  }
}

Vec3.prototype.setZero = function() {
  this.x = 0.0;
  this.y = 0.0;
  this.z = 0.0;
  return this;
}

Vec3.prototype.set = function(x, y, z) {
  this.x = x;
  this.y = y;
  this.z = z;
  return this;
}

Vec3.prototype.add = function(w) {
  this.x += w.x;
  this.y += w.y;
  this.z += w.z;
  return this;
}

Vec3.prototype.sub = function(w) {
  this.x -= w.x;
  this.y -= w.y;
  this.z -= w.z;
  return this;
}

Vec3.prototype.mul = function(m) {
  this.x *= m;
  this.y *= m;
  this.z *= m;
  return this;
}

Vec3.areEqual = function(v, w) {
  _ASSERT && Vec3.assert(v);
  _ASSERT && Vec3.assert(w);
  return v == w ||
    typeof v === 'object' && v !== null &&
    typeof w === 'object' && w !== null &&
    v.x === w.x && v.y === w.y && v.z === w.z;
}

/**
 * Perform the dot product on two vectors.
 */
Vec3.dot = function(v, w) {
  return v.x * w.x + v.y * w.y + v.z * w.z;
}

/**
 * Perform the cross product on two vectors. In 2D this produces a scalar.
 */
Vec3.cross = function(v, w) {
  return new Vec3(
    v.y * w.z - v.z * w.y,
    v.z * w.x - v.x * w.z,
    v.x * w.y - v.y * w.x
  );
}

Vec3.add = function(v, w) {
  return new Vec3(v.x + w.x, v.y + w.y, v.z + w.z);
}

Vec3.sub = function(v, w) {
  return new Vec3(v.x - w.x, v.y - w.y, v.z - w.z);
}

Vec3.mul = function(v, m) {
  return new Vec3(m * v.x, m * v.y, m * v.z);
}

Vec3.prototype.neg = function() {
  this.x = -this.x;
  this.y = -this.y;
  this.z = -this.z;
  return this;
}

Vec3.neg = function(v) {
  return new Vec3(-v.x, -v.y, -v.z);
}


/***/ }),
/* 85 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

module.exports = Mat33;

var common = __webpack_require__(61);
var Math = __webpack_require__(63);
var Vec2 = __webpack_require__(62);
var Vec3 = __webpack_require__(84);

/**
 * A 3-by-3 matrix. Stored in column-major order.
 */
function Mat33(a, b, c) {
  if (typeof a === 'object' && a !== null) {
    this.ex = Vec3.clone(a);
    this.ey = Vec3.clone(b);
    this.ez = Vec3.clone(c);
  } else {
    this.ex = Vec3();
    this.ey = Vec3();
    this.ez = Vec3();
  }
};

Mat33.prototype.toString = function() {
  return JSON.stringify(this);
};

Mat33.isValid = function(o) {
  return o && Vec3.isValid(o.ex) && Vec3.isValid(o.ey) && Vec3.isValid(o.ez);
};

Mat33.assert = function(o) {
  if (!_ASSERT) return;
  if (!Mat33.isValid(o)) {
    _DEBUG && common.debug(o);
    throw new Error('Invalid Mat33!');
  }
};

/**
 * Set this matrix to all zeros.
 */
Mat33.prototype.setZero = function() {
  this.ex.setZero();
  this.ey.setZero();
  this.ez.setZero();
  return this;
}

/**
 * Solve A * x = b, where b is a column vector. This is more efficient than
 * computing the inverse in one-shot cases.
 * 
 * @param {Vec3} v
 * @returns {Vec3}
 */
Mat33.prototype.solve33 = function(v) {
  var det = Vec3.dot(this.ex, Vec3.cross(this.ey, this.ez));
  if (det != 0.0) {
    det = 1.0 / det;
  }
  var r = new Vec3();
  r.x = det * Vec3.dot(v, Vec3.cross(this.ey, this.ez));
  r.y = det * Vec3.dot(this.ex, Vec3.cross(v, this.ez));
  r.z = det * Vec3.dot(this.ex, Vec3.cross(this.ey, v));
  return r;
}

/**
 * Solve A * x = b, where b is a column vector. This is more efficient than
 * computing the inverse in one-shot cases. Solve only the upper 2-by-2 matrix
 * equation.
 * 
 * @param {Vec2} v
 * 
 * @returns {Vec2}
 */
Mat33.prototype.solve22 = function(v) {
  var a11 = this.ex.x;
  var a12 = this.ey.x;
  var a21 = this.ex.y;
  var a22 = this.ey.y;
  var det = a11 * a22 - a12 * a21;
  if (det != 0.0) {
    det = 1.0 / det;
  }
  var r = Vec2.zero();
  r.x = det * (a22 * v.x - a12 * v.y);
  r.y = det * (a11 * v.y - a21 * v.x);
  return r;
}

/**
 * Get the inverse of this matrix as a 2-by-2. Returns the zero matrix if
 * singular.
 * 
 * @param {Mat33} M
 */
Mat33.prototype.getInverse22 = function(M) {
  var a = this.ex.x;
  var b = this.ey.x;
  var c = this.ex.y;
  var d = this.ey.y;
  var det = a * d - b * c;
  if (det != 0.0) {
    det = 1.0 / det;
  }
  M.ex.x = det * d;
  M.ey.x = -det * b;
  M.ex.z = 0.0;
  M.ex.y = -det * c;
  M.ey.y = det * a;
  M.ey.z = 0.0;
  M.ez.x = 0.0;
  M.ez.y = 0.0;
  M.ez.z = 0.0;
}

/**
 * Get the symmetric inverse of this matrix as a 3-by-3. Returns the zero matrix
 * if singular.
 * 
 * @param {Mat33} M
 */
Mat33.prototype.getSymInverse33 = function(M) {
  var det = Vec3.dot(this.ex, Vec3.cross(this.ey, this.ez));
  if (det != 0.0) {
    det = 1.0 / det;
  }
  var a11 = this.ex.x;
  var a12 = this.ey.x;
  var a13 = this.ez.x;
  var a22 = this.ey.y;
  var a23 = this.ez.y;
  var a33 = this.ez.z;

  M.ex.x = det * (a22 * a33 - a23 * a23);
  M.ex.y = det * (a13 * a23 - a12 * a33);
  M.ex.z = det * (a12 * a23 - a13 * a22);

  M.ey.x = M.ex.y;
  M.ey.y = det * (a11 * a33 - a13 * a13);
  M.ey.z = det * (a13 * a12 - a11 * a23);

  M.ez.x = M.ex.z;
  M.ez.y = M.ey.z;
  M.ez.z = det * (a11 * a22 - a12 * a12);
}

/**
 * Multiply a matrix times a vector.
 * 
 * @param {Mat33} a
 * @param {Vec3|Vec2} b
 * 
 * @returns {Vec3|Vec2}
 */
Mat33.mul = function(a, b) {
  _ASSERT && Mat33.assert(a);
  if (b && 'z' in b && 'y' in b && 'x' in b) {
    _ASSERT && Vec3.assert(b);
    var x = a.ex.x * b.x + a.ey.x * b.y + a.ez.x * b.z;
    var y = a.ex.y * b.x + a.ey.y * b.y + a.ez.y * b.z;
    var z = a.ex.z * b.x + a.ey.z * b.y + a.ez.z * b.z;
    return new Vec3(x, y, z);

  } else if (b && 'y' in b && 'x' in b) {
    _ASSERT && Vec2.assert(b);
    var x = a.ex.x * b.x + a.ey.x * b.y;
    var y = a.ex.y * b.x + a.ey.y * b.y;
    return Vec2.neo(x, y);
  }

  _ASSERT && common.assert(false);
}

Mat33.mulVec3 = function(a, b) {
  _ASSERT && Mat33.assert(a);
  _ASSERT && Vec3.assert(b);
  var x = a.ex.x * b.x + a.ey.x * b.y + a.ez.x * b.z;
  var y = a.ex.y * b.x + a.ey.y * b.y + a.ez.y * b.z;
  var z = a.ex.z * b.x + a.ey.z * b.y + a.ez.z * b.z;
  return new Vec3(x, y, z);
}

Mat33.mulVec2 = function(a, b) {
  _ASSERT && Mat33.assert(a);
  _ASSERT && Vec2.assert(b);
  var x = a.ex.x * b.x + a.ey.x * b.y;
  var y = a.ex.y * b.x + a.ey.y * b.y;
  return Vec2.neo(x, y);
}

Mat33.add = function(a, b) {
  _ASSERT && Mat33.assert(a);
  _ASSERT && Mat33.assert(b);
  return new Mat33(
    Vec3.add(a.ex, b.ex),
    Vec3.add(a.ey, b.ey),
    Vec3.add(a.ez, b.ez)
  );
}


/***/ }),
/* 86 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

module.exports = Joint;

var common = __webpack_require__(61);

/**
 * A joint edge is used to connect bodies and joints together in a joint graph
 * where each body is a node and each joint is an edge. A joint edge belongs to
 * a doubly linked list maintained in each attached body. Each joint has two
 * joint nodes, one for each attached body.
 * 
 * @prop {Body} other provides quick access to the other body attached.
 * @prop {Joint} joint the joint
 * @prop {JointEdge} prev the previous joint edge in the body's joint list
 * @prop {JointEdge} next the next joint edge in the body's joint list
 */
function JointEdge() {
  this.other = null;
  this.joint = null;
  this.prev = null;
  this.next = null;
};

/**
 * @typedef {Object} JointDef
 *
 * Joint definitions are used to construct joints.
 * 
 * @prop userData Use this to attach application specific data to your joints.
 *       void userData;
 * @prop {boolean} collideConnected Set this flag to true if the attached bodies
 *       should collide.
 *
 * @prop {Body} bodyA The first attached body.
 * @prop {Body} bodyB The second attached body.
 */

var DEFAULTS = {
  userData : null,
  collideConnected : false
};

/**
 * The base joint class. Joints are used to constraint two bodies together in
 * various fashions. Some joints also feature limits and motors.
 * 
 * @param {JointDef} def
 */
function Joint(def, bodyA, bodyB) {
  bodyA = def.bodyA || bodyA;
  bodyB = def.bodyB || bodyB;

  _ASSERT && common.assert(bodyA);
  _ASSERT && common.assert(bodyB);
  _ASSERT && common.assert(bodyA != bodyB);

  this.m_type = 'unknown-joint';

  this.m_bodyA = bodyA;
  this.m_bodyB = bodyB;

  this.m_index = 0;
  this.m_collideConnected = !!def.collideConnected;

  this.m_prev = null;
  this.m_next = null;

  this.m_edgeA = new JointEdge();
  this.m_edgeB = new JointEdge();

  this.m_islandFlag = false;
  this.m_userData = def.userData;
};

Joint.TYPES = {};

Joint._deserialize = function(data, context, restore) {
  var clazz = Joint.TYPES[data.type];
  return clazz && restore(clazz, data);
};

/**
 * Short-cut function to determine if either body is inactive.
 * 
 * @returns {boolean}
 */
Joint.prototype.isActive = function() {
  return this.m_bodyA.isActive() && this.m_bodyB.isActive();
}

/**
 * Get the type of the concrete joint.
 * 
 * @returns JointType
 */
Joint.prototype.getType = function() {
  return this.m_type;
}

/**
 * Get the first body attached to this joint.
 * 
 * @returns Body
 */
Joint.prototype.getBodyA = function() {
  return this.m_bodyA;
}

/**
 * Get the second body attached to this joint.
 * 
 * @returns Body
 */
Joint.prototype.getBodyB = function() {
  return this.m_bodyB;
}

/**
 * Get the next joint the world joint list.
 * 
 * @returns Joint
 */
Joint.prototype.getNext = function() {
  return this.m_next;
}

Joint.prototype.getUserData = function() {
  return this.m_userData;
}

Joint.prototype.setUserData = function(data) {
  this.m_userData = data;
}

/**
 * Get collide connected. Note: modifying the collide connect flag won't work
 * correctly because the flag is only checked when fixture AABBs begin to
 * overlap.
 * 
 * @returns {boolean}
 */
Joint.prototype.getCollideConnected = function() {
  return this.m_collideConnected;
};

/**
 * Get the anchor point on bodyA in world coordinates.
 * 
 * @return {Vec2}
 */
Joint.prototype.getAnchorA = function() {
};

/**
 * Get the anchor point on bodyB in world coordinates.
 * 
 * @return {Vec2}
 */
Joint.prototype.getAnchorB = function() {
};

/**
 * Get the reaction force on bodyB at the joint anchor in Newtons.
 * 
 * @param {float} inv_dt
 * @return {Vec2}
 */
Joint.prototype.getReactionForce = function(inv_dt) {
};

/**
 * Get the reaction torque on bodyB in N*m.
 * 
 * @param {float} inv_dt
 * @return {float}
 */
Joint.prototype.getReactionTorque = function(inv_dt) {
};

/**
 * Shift the origin for any points stored in world coordinates.
 * 
 * @param {Vec2} newOrigin
 */
Joint.prototype.shiftOrigin = function(newOrigin) {
};

/**
 */
Joint.prototype.initVelocityConstraints = function(step) {
};

/**
 */
Joint.prototype.solveVelocityConstraints = function(step) {
};

/**
 * This returns true if the position errors are within tolerance.
 */
Joint.prototype.solvePositionConstraints = function(step) {
};


/***/ }),
/* 87 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

module.exports = TimeOfImpact;
module.exports.Input = TOIInput;
module.exports.Output = TOIOutput;

var Settings = __webpack_require__(66);

var common = __webpack_require__(61);
var Timer = __webpack_require__(88);

var stats = __webpack_require__(83);

var Math = __webpack_require__(63);
var Vec2 = __webpack_require__(62);
var Vec3 = __webpack_require__(84);
var Mat22 = __webpack_require__(80);
var Mat33 = __webpack_require__(85);
var Rot = __webpack_require__(72);
var Sweep = __webpack_require__(73);
var Transform = __webpack_require__(74);
var Velocity = __webpack_require__(75);
var Position = __webpack_require__(76);

var Distance = __webpack_require__(82);
var DistanceInput = Distance.Input;
var DistanceOutput = Distance.Output;
var DistanceProxy = Distance.Proxy;
var SimplexCache = Distance.Cache;

/**
 * Input parameters for TimeOfImpact.
 * 
 * @prop {DistanceProxy} proxyA
 * @prop {DistanceProxy} proxyB
 * @prop {Sweep} sweepA
 * @prop {Sweep} sweepB
 * @prop tMax defines sweep interval [0, tMax]
 */
function TOIInput() {
  this.proxyA = new DistanceProxy();
  this.proxyB = new DistanceProxy();
  this.sweepA = new Sweep();
  this.sweepB = new Sweep();
  this.tMax;
};

// TOIOutput State
TOIOutput.e_unknown = 0;
TOIOutput.e_failed = 1;
TOIOutput.e_overlapped = 2;
TOIOutput.e_touching = 3;
TOIOutput.e_separated = 4;

/**
 * Output parameters for TimeOfImpact.
 * 
 * @prop state
 * @prop t
 */
function TOIOutput() {
  this.state;
  this.t;
};

stats.toiTime = 0;
stats.toiMaxTime = 0;
stats.toiCalls = 0;
stats.toiIters = 0;
stats.toiMaxIters = 0;
stats.toiRootIters = 0;
stats.toiMaxRootIters = 0;

/**
 * Compute the upper bound on time before two shapes penetrate. Time is
 * represented as a fraction between [0,tMax]. This uses a swept separating axis
 * and may miss some intermediate, non-tunneling collision. If you change the
 * time interval, you should call this function again.
 * 
 * Note: use Distance to compute the contact point and normal at the time of
 * impact.
 * 
 * CCD via the local separating axis method. This seeks progression by computing
 * the largest time at which separation is maintained.
 */
function TimeOfImpact(output, input) {
  var timer = Timer.now();

  ++stats.toiCalls;

  output.state = TOIOutput.e_unknown;
  output.t = input.tMax;

  var proxyA = input.proxyA; // DistanceProxy
  var proxyB = input.proxyB; // DistanceProxy

  var sweepA = input.sweepA; // Sweep
  var sweepB = input.sweepB; // Sweep

  // Large rotations can make the root finder fail, so we normalize the
  // sweep angles.
  sweepA.normalize();
  sweepB.normalize();

  var tMax = input.tMax;

  var totalRadius = proxyA.m_radius + proxyB.m_radius;
  var target = Math.max(Settings.linearSlop, totalRadius - 3.0 * Settings.linearSlop);
  var tolerance = 0.25 * Settings.linearSlop;
  _ASSERT && common.assert(target > tolerance);

  var t1 = 0.0;
  var k_maxIterations = Settings.maxTOIIterations;
  var iter = 0;

  // Prepare input for distance query.
  var cache = new SimplexCache();

  var distanceInput = new DistanceInput();
  distanceInput.proxyA = input.proxyA;
  distanceInput.proxyB = input.proxyB;
  distanceInput.useRadii = false;

  // The outer loop progressively attempts to compute new separating axes.
  // This loop terminates when an axis is repeated (no progress is made).
  for (;;) {
    var xfA = Transform.identity();
    var xfB = Transform.identity();
    sweepA.getTransform(xfA, t1);
    sweepB.getTransform(xfB, t1);

    // Get the distance between shapes. We can also use the results
    // to get a separating axis.
    distanceInput.transformA = xfA;
    distanceInput.transformB = xfB;
    var distanceOutput = new DistanceOutput();
    Distance(distanceOutput, cache, distanceInput);

    // If the shapes are overlapped, we give up on continuous collision.
    if (distanceOutput.distance <= 0.0) {
      // Failure!
      output.state = TOIOutput.e_overlapped;
      output.t = 0.0;
      break;
    }

    if (distanceOutput.distance < target + tolerance) {
      // Victory!
      output.state = TOIOutput.e_touching;
      output.t = t1;
      break;
    }

    // Initialize the separating axis.
    var fcn = new SeparationFunction();
    fcn.initialize(cache, proxyA, sweepA, proxyB, sweepB, t1);

    // if (false) {
    //   // Dump the curve seen by the root finder
    //   var N = 100;
    //   var dx = 1.0 / N;
    //   var xs = []; // [ N + 1 ];
    //   var fs = []; // [ N + 1 ];
    //   var x = 0.0;
    //   for (var i = 0; i <= N; ++i) {
    //     sweepA.getTransform(xfA, x);
    //     sweepB.getTransform(xfB, x);
    //     var f = fcn.evaluate(xfA, xfB) - target;
    //     printf("%g %g\n", x, f);
    //     xs[i] = x;
    //     fs[i] = f;
    //     x += dx;
    //   }
    // }

    // Compute the TOI on the separating axis. We do this by successively
    // resolving the deepest point. This loop is bounded by the number of
    // vertices.
    var done = false;
    var t2 = tMax;
    var pushBackIter = 0;
    for (;;) {
      // Find the deepest point at t2. Store the witness point indices.
      var s2 = fcn.findMinSeparation(t2);
      var indexA = fcn.indexA;
      var indexB = fcn.indexB;

      // Is the final configuration separated?
      if (s2 > target + tolerance) {
        // Victory!
        output.state = TOIOutput.e_separated;
        output.t = tMax;
        done = true;
        break;
      }

      // Has the separation reached tolerance?
      if (s2 > target - tolerance) {
        // Advance the sweeps
        t1 = t2;
        break;
      }

      // Compute the initial separation of the witness points.
      var s1 = fcn.evaluate(t1);
      var indexA = fcn.indexA;
      var indexB = fcn.indexB;

      // Check for initial overlap. This might happen if the root finder
      // runs out of iterations.
      if (s1 < target - tolerance) {
        output.state = TOIOutput.e_failed;
        output.t = t1;
        done = true;
        break;
      }

      // Check for touching
      if (s1 <= target + tolerance) {
        // Victory! t1 should hold the TOI (could be 0.0).
        output.state = TOIOutput.e_touching;
        output.t = t1;
        done = true;
        break;
      }

      // Compute 1D root of: f(x) - target = 0
      var rootIterCount = 0;
      var a1 = t1, a2 = t2;
      for (;;) {
        // Use a mix of the secant rule and bisection.
        var t;
        if (rootIterCount & 1) {
          // Secant rule to improve convergence.
          t = a1 + (target - s1) * (a2 - a1) / (s2 - s1);
        } else {
          // Bisection to guarantee progress.
          t = 0.5 * (a1 + a2);
        }

        ++rootIterCount;
        ++stats.toiRootIters;

        var s = fcn.evaluate(t);
        var indexA = fcn.indexA;
        var indexB = fcn.indexB;

        if (Math.abs(s - target) < tolerance) {
          // t2 holds a tentative value for t1
          t2 = t;
          break;
        }

        // Ensure we continue to bracket the root.
        if (s > target) {
          a1 = t;
          s1 = s;
        } else {
          a2 = t;
          s2 = s;
        }

        if (rootIterCount == 50) {
          break;
        }
      }

      stats.toiMaxRootIters = Math.max(stats.toiMaxRootIters, rootIterCount);

      ++pushBackIter;

      if (pushBackIter == Settings.maxPolygonVertices) {
        break;
      }
    }

    ++iter;
    ++stats.toiIters;

    if (done) {
      break;
    }

    if (iter == k_maxIterations) {
      // Root finder got stuck. Semi-victory.
      output.state = TOIOutput.e_failed;
      output.t = t1;
      break;
    }
  }

  stats.toiMaxIters = Math.max(stats.toiMaxIters, iter);

  var time = Timer.diff(timer);
  stats.toiMaxTime = Math.max(stats.toiMaxTime, time);
  stats.toiTime += time;
}

// SeparationFunction Type
var e_points = 1;
var e_faceA = 2;
var e_faceB = 3;

function SeparationFunction() {
  this.m_proxyA = new DistanceProxy();
  this.m_proxyB = new DistanceProxy();
  this.m_sweepA;// Sweep
  this.m_sweepB;// Sweep
  this.indexA;// integer
  this.indexB;// integer
  this.m_type;
  this.m_localPoint = Vec2.zero();
  this.m_axis = Vec2.zero();
};

// TODO_ERIN might not need to return the separation

/**
 * @param {SimplexCache} cache
 * @param {DistanceProxy} proxyA
 * @param {Sweep} sweepA
 * @param {DistanceProxy} proxyB
 * @param {Sweep} sweepB
 * @param {float} t1
 */
SeparationFunction.prototype.initialize = function(cache, proxyA, sweepA, proxyB, sweepB, t1) {
  this.m_proxyA = proxyA;
  this.m_proxyB = proxyB;
  var count = cache.count;
  _ASSERT && common.assert(0 < count && count < 3);

  this.m_sweepA = sweepA;
  this.m_sweepB = sweepB;

  var xfA = Transform.identity();
  var xfB = Transform.identity();
  this.m_sweepA.getTransform(xfA, t1);
  this.m_sweepB.getTransform(xfB, t1);

  if (count == 1) {
    this.m_type = e_points;
    var localPointA = this.m_proxyA.getVertex(cache.indexA[0]);
    var localPointB = this.m_proxyB.getVertex(cache.indexB[0]);
    var pointA = Transform.mulVec2(xfA, localPointA);
    var pointB = Transform.mulVec2(xfB, localPointB);
    this.m_axis.setCombine(1, pointB, -1, pointA);
    var s = this.m_axis.normalize();
    return s;

  } else if (cache.indexA[0] == cache.indexA[1]) {
    // Two points on B and one on A.
    this.m_type = e_faceB;
    var localPointB1 = proxyB.getVertex(cache.indexB[0]);
    var localPointB2 = proxyB.getVertex(cache.indexB[1]);

    this.m_axis = Vec2.cross(Vec2.sub(localPointB2, localPointB1), 1.0);
    this.m_axis.normalize();
    var normal = Rot.mulVec2(xfB.q, this.m_axis);

    this.m_localPoint = Vec2.mid(localPointB1, localPointB2);
    var pointB = Transform.mulVec2(xfB, this.m_localPoint);

    var localPointA = proxyA.getVertex(cache.indexA[0]);
    var pointA = Transform.mulVec2(xfA, localPointA);

    var s = Vec2.dot(pointA, normal) - Vec2.dot(pointB, normal);
    if (s < 0.0) {
      this.m_axis = Vec2.neg(this.m_axis);
      s = -s;
    }
    return s;

  } else {
    // Two points on A and one or two points on B.
    this.m_type = e_faceA;
    var localPointA1 = this.m_proxyA.getVertex(cache.indexA[0]);
    var localPointA2 = this.m_proxyA.getVertex(cache.indexA[1]);

    this.m_axis = Vec2.cross(Vec2.sub(localPointA2, localPointA1), 1.0);
    this.m_axis.normalize();
    var normal = Rot.mulVec2(xfA.q, this.m_axis);

    this.m_localPoint = Vec2.mid(localPointA1, localPointA2);
    var pointA = Transform.mulVec2(xfA, this.m_localPoint);

    var localPointB = this.m_proxyB.getVertex(cache.indexB[0]);
    var pointB = Transform.mulVec2(xfB, localPointB);

    var s = Vec2.dot(pointB, normal) - Vec2.dot(pointA, normal);
    if (s < 0.0) {
      this.m_axis = Vec2.neg(this.m_axis);
      s = -s;
    }
    return s;
  }
};

SeparationFunction.prototype.compute = function(find, t) {
  // It was findMinSeparation and evaluate
  var xfA = Transform.identity();
  var xfB = Transform.identity();
  this.m_sweepA.getTransform(xfA, t);
  this.m_sweepB.getTransform(xfB, t);

  switch (this.m_type) {
  case e_points: {
    if (find) {
      var axisA = Rot.mulTVec2(xfA.q, this.m_axis);
      var axisB = Rot.mulTVec2(xfB.q, Vec2.neg(this.m_axis));

      this.indexA = this.m_proxyA.getSupport(axisA);
      this.indexB = this.m_proxyB.getSupport(axisB);
    }

    var localPointA = this.m_proxyA.getVertex(this.indexA);
    var localPointB = this.m_proxyB.getVertex(this.indexB);

    var pointA = Transform.mulVec2(xfA, localPointA);
    var pointB = Transform.mulVec2(xfB, localPointB);

    var sep = Vec2.dot(pointB, this.m_axis) - Vec2.dot(pointA, this.m_axis);
    return sep;
  }

  case e_faceA: {
    var normal = Rot.mulVec2(xfA.q, this.m_axis);
    var pointA = Transform.mulVec2(xfA, this.m_localPoint);

    if (find) {
      var axisB = Rot.mulTVec2(xfB.q, Vec2.neg(normal));

      this.indexA = -1;
      this.indexB = this.m_proxyB.getSupport(axisB);
    }

    var localPointB = this.m_proxyB.getVertex(this.indexB);
    var pointB = Transform.mulVec2(xfB, localPointB);

    var sep = Vec2.dot(pointB, normal) - Vec2.dot(pointA, normal);
    return sep;
  }

  case e_faceB: {
    var normal = Rot.mulVec2(xfB.q, this.m_axis);
    var pointB = Transform.mulVec2(xfB, this.m_localPoint);

    if (find) {
      var axisA = Rot.mulTVec2(xfA.q, Vec2.neg(normal));

      this.indexB = -1;
      this.indexA = this.m_proxyA.getSupport(axisA);
    }

    var localPointA = this.m_proxyA.getVertex(this.indexA);
    var pointA = Transform.mulVec2(xfA, localPointA);

    var sep = Vec2.dot(pointA, normal) - Vec2.dot(pointB, normal);
    return sep;
  }

  default:
    _ASSERT && common.assert(false);
    if (find) {
      this.indexA = -1;
      this.indexB = -1;
    }
    return 0.0;
  }
};

SeparationFunction.prototype.findMinSeparation = function(t) {
  return this.compute(true, t);
};

SeparationFunction.prototype.evaluate = function(t) {
  return this.compute(false, t);
};


/***/ }),
/* 88 */
/***/ ((module) => {

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

module.exports.now = function() {
  return Date.now();
}

module.exports.diff = function(time) {
  return Date.now() - time;
}


/***/ }),
/* 89 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

module.exports = CircleShape;

var common = __webpack_require__(61);
var create = __webpack_require__(64);
var options = __webpack_require__(60);
var Math = __webpack_require__(63);
var Transform = __webpack_require__(74);
var Rot = __webpack_require__(72);
var Vec2 = __webpack_require__(62);
var AABB = __webpack_require__(67);
var Settings = __webpack_require__(66);
var Shape = __webpack_require__(78);

CircleShape._super = Shape;
CircleShape.prototype = create(CircleShape._super.prototype);

CircleShape.TYPE = 'circle';
Shape.TYPES[CircleShape.TYPE] = CircleShape;

function CircleShape(a, b) {
  if (!(this instanceof CircleShape)) {
    return new CircleShape(a, b);
  }

  CircleShape._super.call(this);

  this.m_type = CircleShape.TYPE;
  this.m_p = Vec2.zero();
  this.m_radius = 1;

  if (typeof a === 'object' && Vec2.isValid(a)) {
    this.m_p.set(a);

    if (typeof b === 'number') {
      this.m_radius = b;
    }

  } else if (typeof a === 'number') {
    this.m_radius = a;
  }
}

CircleShape.prototype._serialize = function() {
  return {
    type: this.m_type,

    p: this.m_p,
    radius: this.m_radius,
  };
};

CircleShape._deserialize = function(data) {
  return new CircleShape(data.p, data.radius);
};

CircleShape.prototype.getRadius = function() {
  return this.m_radius;
}

CircleShape.prototype.getCenter = function() {
  return this.m_p;
}

CircleShape.prototype.getVertex = function(index) {
  _ASSERT && common.assert(index == 0);
  return this.m_p;
}

CircleShape.prototype.getVertexCount = function(index) {
  return 1;
}

/**
 * @deprecated
 */
CircleShape.prototype._clone = function() {
  var clone = new CircleShape();
  clone.m_type = this.m_type;
  clone.m_radius = this.m_radius;
  clone.m_p = this.m_p.clone();
  return clone;
}

CircleShape.prototype.getChildCount = function() {
  return 1;
}

CircleShape.prototype.testPoint = function(xf, p) {
  var center = Vec2.add(xf.p, Rot.mulVec2(xf.q, this.m_p));
  var d = Vec2.sub(p, center);
  return Vec2.dot(d, d) <= this.m_radius * this.m_radius;
}

// Collision Detection in Interactive 3D Environments by Gino van den Bergen
// From Section 3.1.2
// x = s + a * r
// norm(x) = radius
CircleShape.prototype.rayCast = function(output, input, xf, childIndex) {

  var position = Vec2.add(xf.p, Rot.mulVec2(xf.q, this.m_p));
  var s = Vec2.sub(input.p1, position);
  var b = Vec2.dot(s, s) - this.m_radius * this.m_radius;

  // Solve quadratic equation.
  var r = Vec2.sub(input.p2, input.p1);
  var c = Vec2.dot(s, r);
  var rr = Vec2.dot(r, r);
  var sigma = c * c - rr * b;

  // Check for negative discriminant and short segment.
  if (sigma < 0.0 || rr < Math.EPSILON) {
    return false;
  }

  // Find the point of intersection of the line with the circle.
  var a = -(c + Math.sqrt(sigma));

  // Is the intersection point on the segment?
  if (0.0 <= a && a <= input.maxFraction * rr) {
    a /= rr;
    output.fraction = a;
    output.normal = Vec2.add(s, Vec2.mul(a, r));
    output.normal.normalize();
    return true;
  }

  return false;
}

CircleShape.prototype.computeAABB = function(aabb, xf, childIndex) {
  var p = Vec2.add(xf.p, Rot.mulVec2(xf.q, this.m_p));
  aabb.lowerBound.set(p.x - this.m_radius, p.y - this.m_radius);
  aabb.upperBound.set(p.x + this.m_radius, p.y + this.m_radius);
}

CircleShape.prototype.computeMass = function(massData, density) {
  massData.mass = density * Math.PI * this.m_radius * this.m_radius;
  massData.center = this.m_p;
  // inertia about the local origin
  massData.I = massData.mass
      * (0.5 * this.m_radius * this.m_radius + Vec2.dot(this.m_p, this.m_p));
}

CircleShape.prototype.computeDistanceProxy = function(proxy) {
  proxy.m_vertices.push(this.m_p);
  proxy.m_count = 1;
  proxy.m_radius = this.m_radius;
};


/***/ }),
/* 90 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

module.exports = EdgeShape;

var create = __webpack_require__(64);
var options = __webpack_require__(60);
var Settings = __webpack_require__(66);
var Shape = __webpack_require__(78);
var Math = __webpack_require__(63);
var Transform = __webpack_require__(74);
var Rot = __webpack_require__(72);
var Vec2 = __webpack_require__(62);
var AABB = __webpack_require__(67);

EdgeShape._super = Shape;
EdgeShape.prototype = create(EdgeShape._super.prototype);

EdgeShape.TYPE = 'edge';
Shape.TYPES[EdgeShape.TYPE] = EdgeShape;

/**
 * A line segment (edge) shape. These can be connected in chains or loops to
 * other edge shapes. The connectivity information is used to ensure correct
 * contact normals.
 */
function EdgeShape(v1, v2) {
  if (!(this instanceof EdgeShape)) {
    return new EdgeShape(v1, v2);
  }

  EdgeShape._super.call(this);

  this.m_type = EdgeShape.TYPE;
  this.m_radius = Settings.polygonRadius;

  // These are the edge vertices
  this.m_vertex1 = v1 ? Vec2.clone(v1) : Vec2.zero();
  this.m_vertex2 = v2 ? Vec2.clone(v2) : Vec2.zero();

  // Optional adjacent vertices. These are used for smooth collision.
  // Used by chain shape.
  this.m_vertex0 = Vec2.zero();
  this.m_vertex3 = Vec2.zero();
  this.m_hasVertex0 = false;
  this.m_hasVertex3 = false;
}

EdgeShape.prototype._serialize = function() {
  return {
    type: this.m_type,

    vertex1: this.m_vertex1,
    vertex2: this.m_vertex2,

    vertex0: this.m_vertex0,
    vertex3: this.m_vertex3,
    hasVertex0: this.m_hasVertex0,
    hasVertex3: this.m_hasVertex3,
  };
};

EdgeShape._deserialize = function(data) {
  var shape = new EdgeShape(data.vertex1, data.vertex2);
  if (shape.hasVertex0) {
    shape.setPrev(data.vertex0);
  }
  if (shape.hasVertex3) {
    shape.setNext(data.vertex3);
  }
  return shape;
};

EdgeShape.prototype.setNext = function(v3) {
  if (v3) {
    this.m_vertex3.set(v3);
    this.m_hasVertex3 = true;
  } else {
    this.m_vertex3.setZero();
    this.m_hasVertex3 = false;
  }
  return this;
};

EdgeShape.prototype.setPrev = function(v0) {
  if (v0) {
    this.m_vertex0.set(v0);
    this.m_hasVertex0 = true;
  } else {
    this.m_vertex0.setZero();
    this.m_hasVertex0 = false;
  }
  return this;
};

/**
 * Set this as an isolated edge.
 */
EdgeShape.prototype._set = function(v1, v2) {
  this.m_vertex1.set(v1);
  this.m_vertex2.set(v2);
  this.m_hasVertex0 = false;
  this.m_hasVertex3 = false;
  return this;
}

/**
 * @deprecated
 */
EdgeShape.prototype._clone = function() {
  var clone = new EdgeShape();
  clone.m_type = this.m_type;
  clone.m_radius = this.m_radius;
  clone.m_vertex1.set(this.m_vertex1);
  clone.m_vertex2.set(this.m_vertex2);
  clone.m_vertex0.set(this.m_vertex0);
  clone.m_vertex3.set(this.m_vertex3);
  clone.m_hasVertex0 = this.m_hasVertex0;
  clone.m_hasVertex3 = this.m_hasVertex3;
  return clone;
}

EdgeShape.prototype.getChildCount = function() {
  return 1;
}

EdgeShape.prototype.testPoint = function(xf, p) {
  return false;
}

// p = p1 + t * d
// v = v1 + s * e
// p1 + t * d = v1 + s * e
// s * e - t * d = p1 - v1
EdgeShape.prototype.rayCast = function(output, input, xf, childIndex) {
  // NOT_USED(childIndex);

  // Put the ray into the edge's frame of reference.
  var p1 = Rot.mulTVec2(xf.q, Vec2.sub(input.p1, xf.p));
  var p2 = Rot.mulTVec2(xf.q, Vec2.sub(input.p2, xf.p));
  var d = Vec2.sub(p2, p1);

  var v1 = this.m_vertex1;
  var v2 = this.m_vertex2;
  var e = Vec2.sub(v2, v1);
  var normal = Vec2.neo(e.y, -e.x);
  normal.normalize();

  // q = p1 + t * d
  // dot(normal, q - v1) = 0
  // dot(normal, p1 - v1) + t * dot(normal, d) = 0
  var numerator = Vec2.dot(normal, Vec2.sub(v1, p1));
  var denominator = Vec2.dot(normal, d);

  if (denominator == 0.0) {
    return false;
  }

  var t = numerator / denominator;
  if (t < 0.0 || input.maxFraction < t) {
    return false;
  }

  var q = Vec2.add(p1, Vec2.mul(t, d));

  // q = v1 + s * r
  // s = dot(q - v1, r) / dot(r, r)
  var r = Vec2.sub(v2, v1);
  var rr = Vec2.dot(r, r);
  if (rr == 0.0) {
    return false;
  }

  var s = Vec2.dot(Vec2.sub(q, v1), r) / rr;
  if (s < 0.0 || 1.0 < s) {
    return false;
  }

  output.fraction = t;
  if (numerator > 0.0) {
    output.normal = Rot.mulVec2(xf.q, normal).neg();
  } else {
    output.normal = Rot.mulVec2(xf.q, normal);
  }
  return true;
}

EdgeShape.prototype.computeAABB = function(aabb, xf, childIndex) {
  var v1 = Transform.mulVec2(xf, this.m_vertex1);
  var v2 = Transform.mulVec2(xf, this.m_vertex2);

  aabb.combinePoints(v1, v2);
  aabb.extend(this.m_radius)
}

EdgeShape.prototype.computeMass = function(massData, density) {
  massData.mass = 0.0;
  massData.center.setCombine(0.5, this.m_vertex1, 0.5, this.m_vertex2);
  massData.I = 0.0;
}

EdgeShape.prototype.computeDistanceProxy = function(proxy) {
  proxy.m_vertices.push(this.m_vertex1);
  proxy.m_vertices.push(this.m_vertex2);
  proxy.m_count = 2;
  proxy.m_radius = this.m_radius;
};


/***/ }),
/* 91 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

module.exports = PolygonShape;

var common = __webpack_require__(61);
var create = __webpack_require__(64);
var options = __webpack_require__(60);
var Math = __webpack_require__(63);
var Transform = __webpack_require__(74);
var Rot = __webpack_require__(72);
var Vec2 = __webpack_require__(62);
var AABB = __webpack_require__(67);
var Settings = __webpack_require__(66);
var Shape = __webpack_require__(78);

PolygonShape._super = Shape;
PolygonShape.prototype = create(PolygonShape._super.prototype);

PolygonShape.TYPE = 'polygon';
Shape.TYPES[PolygonShape.TYPE] = PolygonShape;

/**
 * A convex polygon. It is assumed that the interior of the polygon is to the
 * left of each edge. Polygons have a maximum number of vertices equal to
 * Settings.maxPolygonVertices. In most cases you should not need many vertices
 * for a convex polygon. extends Shape
 */
function PolygonShape(vertices) {
  if (!(this instanceof PolygonShape)) {
    return new PolygonShape(vertices);
  }

  PolygonShape._super.call(this);

  this.m_type = PolygonShape.TYPE;
  this.m_radius = Settings.polygonRadius;
  this.m_centroid = Vec2.zero();
  this.m_vertices = []; // Vec2[Settings.maxPolygonVertices]
  this.m_normals = []; // Vec2[Settings.maxPolygonVertices]
  this.m_count = 0;

  if (vertices && vertices.length) {
    this._set(vertices);
  }
}

PolygonShape.prototype._serialize = function() {
  return {
    type: this.m_type,

    vertices: this.m_vertices,
  };
};

PolygonShape._deserialize = function(data, fixture, restore) {
  var vertices = [];
  if (data.vertices) {
    for (var i = 0; i < data.vertices.length; i++) {
      vertices.push(restore(Vec2, data.vertices[i]));
    }
  }

  var shape = new PolygonShape(vertices);
  return shape;
};

PolygonShape.prototype.getVertex = function(index) {
  _ASSERT && common.assert(0 <= index && index < this.m_count);
  return this.m_vertices[index];
}

/**
 * @deprecated
 */
PolygonShape.prototype._clone = function() {
  var clone = new PolygonShape();
  clone.m_type = this.m_type;
  clone.m_radius = this.m_radius;
  clone.m_count = this.m_count;
  clone.m_centroid.set(this.m_centroid);
  for (var i = 0; i < this.m_count; i++) {
    clone.m_vertices.push(this.m_vertices[i].clone());
  }
  for (var i = 0; i < this.m_normals.length; i++) {
    clone.m_normals.push(this.m_normals[i].clone());
  }
  return clone;
}

PolygonShape.prototype.getChildCount = function() {
  return 1;
}

function ComputeCentroid(vs, count) {
  _ASSERT && common.assert(count >= 3);

  var c = Vec2.zero();
  var area = 0.0;

  // pRef is the reference point for forming triangles.
  // It's location doesn't change the result (except for rounding error).
  var pRef = Vec2.zero();
  if (false) { var i; }

  var inv3 = 1.0 / 3.0;

  for (var i = 0; i < count; ++i) {
    // Triangle vertices.
    var p1 = pRef;
    var p2 = vs[i];
    var p3 = i + 1 < count ? vs[i + 1] : vs[0];

    var e1 = Vec2.sub(p2, p1);
    var e2 = Vec2.sub(p3, p1);

    var D = Vec2.cross(e1, e2);

    var triangleArea = 0.5 * D;
    area += triangleArea;

    // Area weighted centroid
    c.addMul(triangleArea * inv3, p1);
    c.addMul(triangleArea * inv3, p2);
    c.addMul(triangleArea * inv3, p3);
  }

  // Centroid
  _ASSERT && common.assert(area > Math.EPSILON);
  c.mul(1.0 / area);
  return c;
}

PolygonShape.prototype._reset = function() {
  this._set(this.m_vertices)
}

/**
 * @private
 *
 * Create a convex hull from the given array of local points. The count must be
 * in the range [3, Settings.maxPolygonVertices].
 *
 * Warning: the points may be re-ordered, even if they form a convex polygon
 * Warning: collinear points are handled but not removed. Collinear points may
 * lead to poor stacking behavior.
 */
PolygonShape.prototype._set = function(vertices) {
  _ASSERT && common.assert(3 <= vertices.length && vertices.length <= Settings.maxPolygonVertices);
  if (vertices.length < 3) {
    this._setAsBox(1.0, 1.0);
    return;
  }

  var n = Math.min(vertices.length, Settings.maxPolygonVertices);

  // Perform welding and copy vertices into local buffer.
  var ps = []; // [Settings.maxPolygonVertices];
  for (var i = 0; i < n; ++i) {
    var v = vertices[i];

    var unique = true;
    for (var j = 0; j < ps.length; ++j) {
      if (Vec2.distanceSquared(v, ps[j]) < 0.25 * Settings.linearSlopSquared) {
        unique = false;
        break;
      }
    }

    if (unique) {
      ps.push(v);
    }
  }

  n = ps.length;
  if (n < 3) {
    // Polygon is degenerate.
    _ASSERT && common.assert(false);
    this._setAsBox(1.0, 1.0);
    return;
  }

  // Create the convex hull using the Gift wrapping algorithm
  // http://en.wikipedia.org/wiki/Gift_wrapping_algorithm

  // Find the right most point on the hull (in case of multiple points bottom most is used)
  var i0 = 0;
  var x0 = ps[0].x;
  for (var i = 1; i < n; ++i) {
    var x = ps[i].x;
    if (x > x0 || (x === x0 && ps[i].y < ps[i0].y)) {
      i0 = i;
      x0 = x;
    }
  }

  var hull = []; // [Settings.maxPolygonVertices];
  var m = 0;
  var ih = i0;

  for (;;) {
    hull[m] = ih;

    var ie = 0;
    for (var j = 1; j < n; ++j) {
      if (ie === ih) {
        ie = j;
        continue;
      }

      var r = Vec2.sub(ps[ie], ps[hull[m]]);
      var v = Vec2.sub(ps[j], ps[hull[m]]);
      var c = Vec2.cross(r, v);
      // c < 0 means counter-clockwise wrapping, c > 0 means clockwise wrapping
      if (c < 0.0) {
        ie = j;
      }

      // Collinearity check
      if (c === 0.0 && v.lengthSquared() > r.lengthSquared()) {
        ie = j;
      }
    }

    ++m;
    ih = ie;

    if (ie === i0) {
      break;
    }
  }

  if (m < 3) {
    // Polygon is degenerate.
    _ASSERT && common.assert(false);
    this._setAsBox(1.0, 1.0);
    return;
  }

  this.m_count = m;

  // Copy vertices.
  this.m_vertices = [];
  for (var i = 0; i < m; ++i) {
    this.m_vertices[i] = ps[hull[i]];
  }

  // Compute normals. Ensure the edges have non-zero length.
  for (var i = 0; i < m; ++i) {
    var i1 = i;
    var i2 = i + 1 < m ? i + 1 : 0;
    var edge = Vec2.sub(this.m_vertices[i2], this.m_vertices[i1]);
    _ASSERT && common.assert(edge.lengthSquared() > Math.EPSILON * Math.EPSILON);
    this.m_normals[i] = Vec2.cross(edge, 1.0);
    this.m_normals[i].normalize();
  }

  // Compute the polygon centroid.
  this.m_centroid = ComputeCentroid(this.m_vertices, m);
}

/**
 * @private
 */
PolygonShape.prototype._setAsBox = function(hx, hy, center, angle) {
  // start with right-bottom, counter-clockwise, as in Gift wrapping algorithm in PolygonShape._set()
  this.m_vertices[0] = Vec2.neo(hx, -hy);
  this.m_vertices[1] = Vec2.neo(hx, hy);
  this.m_vertices[2] = Vec2.neo(-hx, hy);
  this.m_vertices[3] = Vec2.neo(-hx, -hy);

  this.m_normals[0] = Vec2.neo(1.0, 0.0);
  this.m_normals[1] = Vec2.neo(0.0, 1.0);
  this.m_normals[2] = Vec2.neo(-1.0, 0.0);
  this.m_normals[3] = Vec2.neo(0.0, -1.0);

  this.m_count = 4;

  if (Vec2.isValid(center)) {
    angle = angle || 0;

    this.m_centroid.set(center);

    var xf = Transform.identity();
    xf.p.set(center);
    xf.q.set(angle);

    // Transform vertices and normals.
    for (var i = 0; i < this.m_count; ++i) {
      this.m_vertices[i] = Transform.mulVec2(xf, this.m_vertices[i]);
      this.m_normals[i] = Rot.mulVec2(xf.q, this.m_normals[i]);
    }
  }
}

PolygonShape.prototype.testPoint = function(xf, p) {
  var pLocal = Rot.mulTVec2(xf.q, Vec2.sub(p, xf.p));

  for (var i = 0; i < this.m_count; ++i) {
    var dot = Vec2.dot(this.m_normals[i], Vec2.sub(pLocal, this.m_vertices[i]));
    if (dot > 0.0) {
      return false;
    }
  }

  return true;
}

PolygonShape.prototype.rayCast = function(output, input, xf, childIndex) {

  // Put the ray into the polygon's frame of reference.
  var p1 = Rot.mulTVec2(xf.q, Vec2.sub(input.p1, xf.p));
  var p2 = Rot.mulTVec2(xf.q, Vec2.sub(input.p2, xf.p));
  var d = Vec2.sub(p2, p1);

  var lower = 0.0;
  var upper = input.maxFraction;

  var index = -1;

  for (var i = 0; i < this.m_count; ++i) {
    // p = p1 + a * d
    // dot(normal, p - v) = 0
    // dot(normal, p1 - v) + a * dot(normal, d) = 0
    var numerator = Vec2.dot(this.m_normals[i], Vec2.sub(this.m_vertices[i], p1));
    var denominator = Vec2.dot(this.m_normals[i], d);

    if (denominator == 0.0) {
      if (numerator < 0.0) {
        return false;
      }
    } else {
      // Note: we want this predicate without division:
      // lower < numerator / denominator, where denominator < 0
      // Since denominator < 0, we have to flip the inequality:
      // lower < numerator / denominator <==> denominator * lower > numerator.
      if (denominator < 0.0 && numerator < lower * denominator) {
        // Increase lower.
        // The segment enters this half-space.
        lower = numerator / denominator;
        index = i;
      } else if (denominator > 0.0 && numerator < upper * denominator) {
        // Decrease upper.
        // The segment exits this half-space.
        upper = numerator / denominator;
      }
    }

    // The use of epsilon here causes the assert on lower to trip
    // in some cases. Apparently the use of epsilon was to make edge
    // shapes work, but now those are handled separately.
    // if (upper < lower - Math.EPSILON)
    if (upper < lower) {
      return false;
    }
  }

  _ASSERT && common.assert(0.0 <= lower && lower <= input.maxFraction);

  if (index >= 0) {
    output.fraction = lower;
    output.normal = Rot.mulVec2(xf.q, this.m_normals[index]);
    return true;
  }

  return false;
};

PolygonShape.prototype.computeAABB = function(aabb, xf, childIndex) {
  var minX = Infinity, minY = Infinity;
  var maxX = -Infinity, maxY = -Infinity;
  for (var i = 0; i < this.m_count; ++i) {
    var v = Transform.mulVec2(xf, this.m_vertices[i]);
    minX = Math.min(minX, v.x);
    maxX = Math.max(maxX, v.x);
    minY = Math.min(minY, v.y);
    maxY = Math.max(maxY, v.y);
  }

  aabb.lowerBound.set(minX, minY);
  aabb.upperBound.set(maxX, maxY);
  aabb.extend(this.m_radius);
}

PolygonShape.prototype.computeMass = function(massData, density) {
  // Polygon mass, centroid, and inertia.
  // Let rho be the polygon density in mass per unit area.
  // Then:
  // mass = rho * int(dA)
  // centroid.x = (1/mass) * rho * int(x * dA)
  // centroid.y = (1/mass) * rho * int(y * dA)
  // I = rho * int((x*x + y*y) * dA)
  //
  // We can compute these integrals by summing all the integrals
  // for each triangle of the polygon. To evaluate the integral
  // for a single triangle, we make a change of variables to
  // the (u,v) coordinates of the triangle:
  // x = x0 + e1x * u + e2x * v
  // y = y0 + e1y * u + e2y * v
  // where 0 <= u && 0 <= v && u + v <= 1.
  //
  // We integrate u from [0,1-v] and then v from [0,1].
  // We also need to use the Jacobian of the transformation:
  // D = cross(e1, e2)
  //
  // Simplification: triangle centroid = (1/3) * (p1 + p2 + p3)
  //
  // The rest of the derivation is handled by computer algebra.

  _ASSERT && common.assert(this.m_count >= 3);

  var center = Vec2.zero();
  var area = 0.0;
  var I = 0.0;

  // s is the reference point for forming triangles.
  // It's location doesn't change the result (except for rounding error).
  var s = Vec2.zero();

  // This code would put the reference point inside the polygon.
  for (var i = 0; i < this.m_count; ++i) {
    s.add(this.m_vertices[i]);
  }
  s.mul(1.0 / this.m_count);

  var k_inv3 = 1.0 / 3.0;

  for (var i = 0; i < this.m_count; ++i) {
    // Triangle vertices.
    var e1 = Vec2.sub(this.m_vertices[i], s);
    var e2 = i + 1 < this.m_count ? Vec2.sub(this.m_vertices[i + 1], s) : Vec2
        .sub(this.m_vertices[0], s);

    var D = Vec2.cross(e1, e2);

    var triangleArea = 0.5 * D;
    area += triangleArea;

    // Area weighted centroid
    center.addCombine(triangleArea * k_inv3, e1, triangleArea * k_inv3, e2);

    var ex1 = e1.x;
    var ey1 = e1.y;
    var ex2 = e2.x;
    var ey2 = e2.y;

    var intx2 = ex1 * ex1 + ex2 * ex1 + ex2 * ex2;
    var inty2 = ey1 * ey1 + ey2 * ey1 + ey2 * ey2;

    I += (0.25 * k_inv3 * D) * (intx2 + inty2);
  }

  // Total mass
  massData.mass = density * area;

  // Center of mass
  _ASSERT && common.assert(area > Math.EPSILON);
  center.mul(1.0 / area);
  massData.center.setCombine(1, center, 1, s);

  // Inertia tensor relative to the local origin (point s).
  massData.I = density * I;

  // Shift to center of mass then to original body origin.
  massData.I += massData.mass
      * (Vec2.dot(massData.center, massData.center) - Vec2.dot(center, center));
}

// Validate convexity. This is a very time consuming operation.
// @returns true if valid
PolygonShape.prototype.validate = function() {
  for (var i = 0; i < this.m_count; ++i) {
    var i1 = i;
    var i2 = i < this.m_count - 1 ? i1 + 1 : 0;
    var p = this.m_vertices[i1];
    var e = Vec2.sub(this.m_vertices[i2], p);

    for (var j = 0; j < this.m_count; ++j) {
      if (j == i1 || j == i2) {
        continue;
      }

      var v = Vec2.sub(this.m_vertices[j], p);
      var c = Vec2.cross(e, v);
      if (c < 0.0) {
        return false;
      }
    }
  }

  return true;
}

PolygonShape.prototype.computeDistanceProxy = function(proxy) {
  proxy.m_vertices = this.m_vertices;
  proxy.m_count = this.m_count;
  proxy.m_radius = this.m_radius;
};


/***/ }),
/* 92 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

module.exports = ChainShape;

var common = __webpack_require__(61);
var create = __webpack_require__(64);
var options = __webpack_require__(60);
var Math = __webpack_require__(63);
var Transform = __webpack_require__(74);
var Rot = __webpack_require__(72);
var Vec2 = __webpack_require__(62);
var AABB = __webpack_require__(67);
var Settings = __webpack_require__(66);
var Shape = __webpack_require__(78);
var EdgeShape = __webpack_require__(90);

ChainShape._super = Shape;
ChainShape.prototype = create(ChainShape._super.prototype);

ChainShape.TYPE = 'chain';
Shape.TYPES[ChainShape.TYPE] = ChainShape;

/**
 * A chain shape is a free form sequence of line segments. The chain has
 * two-sided collision, so you can use inside and outside collision. Therefore,
 * you may use any winding order. Connectivity information is used to create
 * smooth collisions.
 *
 * WARNING: The chain will not collide properly if there are self-intersections.
 */
function ChainShape(vertices, loop) {
  if (!(this instanceof ChainShape)) {
    return new ChainShape(vertices, loop);
  }

  ChainShape._super.call(this);

  this.m_type = ChainShape.TYPE;
  this.m_radius = Settings.polygonRadius;
  this.m_vertices = [];
  this.m_count = 0;
  this.m_prevVertex = null;
  this.m_nextVertex = null;
  this.m_hasPrevVertex = false;
  this.m_hasNextVertex = false;

  this.m_isLoop = loop;

  if (vertices && vertices.length) {
    if (loop) {
      this._createLoop(vertices);
    } else {
      this._createChain(vertices);
    }
  }
}

ChainShape.prototype._serialize = function() {
  const data = {
    type: this.m_type,
    vertices: this.m_vertices,
    isLoop: this.m_isLoop,
    hasPrevVertex: this.m_hasPrevVertex,
    hasNextVertex: this.m_hasNextVertex,
  };
  if (this.m_prevVertex) {
    data.prevVertex = this.m_prevVertex;
  }
  if (this.m_nextVertex) {
    data.nextVertex = this.m_nextVertex;
  }
  return data;
};

ChainShape._deserialize = function(data, fixture, restore) {
  var vertices = [];
  if (data.vertices) {
    for (var i = 0; i < data.vertices.length; i++) {
      vertices.push(restore(Vec2, data.vertices[i]));
    }
  }
  var shape = new ChainShape(vertices, data.isLoop);
  if (data.prevVertex) {
    shape.setPrevVertex(data.prevVertex);
  }
  if (data.nextVertex) {
    shape.setNextVertex(data.nextVertex);
  }
  return shape;
};

// ChainShape.clear = function() {
// this.m_vertices.length = 0;
// this.m_count = 0;
// }

/**
 * Create a loop. This automatically adjusts connectivity.
 *
 * @param vertices an array of vertices, these are copied
 * @param count the vertex count
 */
ChainShape.prototype._createLoop = function(vertices) {
  _ASSERT && common.assert(this.m_vertices.length == 0 && this.m_count == 0);
  _ASSERT && common.assert(vertices.length >= 3);
  for (var i = 1; i < vertices.length; ++i) {
    var v1 = vertices[i - 1];
    var v2 = vertices[i];
    // If the code crashes here, it means your vertices are too close together.
    _ASSERT && common.assert(Vec2.distanceSquared(v1, v2) > Settings.linearSlopSquared);
  }

  this.m_vertices = [];
  this.m_count = vertices.length + 1;
  for (var i = 0; i < vertices.length; ++i) {
    this.m_vertices[i] = Vec2.clone(vertices[i]);
  }
  this.m_vertices[vertices.length] = Vec2.clone(vertices[0]);

  this.m_prevVertex = this.m_vertices[this.m_count - 2];
  this.m_nextVertex = this.m_vertices[1];
  this.m_hasPrevVertex = true;
  this.m_hasNextVertex = true;
  return this;
}

/**
 * Create a chain with isolated end vertices.
 *
 * @param vertices an array of vertices, these are copied
 * @param count the vertex count
 */
ChainShape.prototype._createChain = function(vertices) {
  _ASSERT && common.assert(this.m_vertices.length == 0 && this.m_count == 0);
  _ASSERT && common.assert(vertices.length >= 2);
  for (var i = 1; i < vertices.length; ++i) {
    // If the code crashes here, it means your vertices are too close together.
    var v1 = vertices[i - 1];
    var v2 = vertices[i];
    _ASSERT && common.assert(Vec2.distanceSquared(v1, v2) > Settings.linearSlopSquared);
  }

  this.m_count = vertices.length;
  for (var i = 0; i < vertices.length; ++i) {
    this.m_vertices[i] = Vec2.clone(vertices[i]);
  }

  this.m_hasPrevVertex = false;
  this.m_hasNextVertex = false;
  this.m_prevVertex = null;
  this.m_nextVertex = null;
  return this;
}

ChainShape.prototype._reset = function() {
  if (this.m_isLoop) {
    this._createLoop(this.m_vertices);
  } else {
    this._createChain(this.m_vertices);
  }
}

/**
 * Establish connectivity to a vertex that precedes the first vertex. Don't call
 * this for loops.
 */
ChainShape.prototype.setPrevVertex = function(prevVertex) {
  this.m_prevVertex = prevVertex;
  this.m_hasPrevVertex = true;
}

/**
 * Establish connectivity to a vertex that follows the last vertex. Don't call
 * this for loops.
 */
ChainShape.prototype.setNextVertex = function(nextVertex) {
  this.m_nextVertex = nextVertex;
  this.m_hasNextVertex = true;
}

/**
 * @deprecated
 */
ChainShape.prototype._clone = function() {
  var clone = new ChainShape();
  clone.createChain(this.m_vertices);
  clone.m_type = this.m_type;
  clone.m_radius = this.m_radius;
  clone.m_prevVertex = this.m_prevVertex;
  clone.m_nextVertex = this.m_nextVertex;
  clone.m_hasPrevVertex = this.m_hasPrevVertex;
  clone.m_hasNextVertex = this.m_hasNextVertex;
  return clone;
}

ChainShape.prototype.getChildCount = function() {
  // edge count = vertex count - 1
  return this.m_count - 1;
}

// Get a child edge.
ChainShape.prototype.getChildEdge = function(edge, childIndex) {
  _ASSERT && common.assert(0 <= childIndex && childIndex < this.m_count - 1);
  edge.m_type = EdgeShape.TYPE;
  edge.m_radius = this.m_radius;

  edge.m_vertex1 = this.m_vertices[childIndex];
  edge.m_vertex2 = this.m_vertices[childIndex + 1];

  if (childIndex > 0) {
    edge.m_vertex0 = this.m_vertices[childIndex - 1];
    edge.m_hasVertex0 = true;
  } else {
    edge.m_vertex0 = this.m_prevVertex;
    edge.m_hasVertex0 = this.m_hasPrevVertex;
  }

  if (childIndex < this.m_count - 2) {
    edge.m_vertex3 = this.m_vertices[childIndex + 2];
    edge.m_hasVertex3 = true;
  } else {
    edge.m_vertex3 = this.m_nextVertex;
    edge.m_hasVertex3 = this.m_hasNextVertex;
  }
}

ChainShape.prototype.getVertex = function(index) {
  _ASSERT && common.assert(0 <= index && index <= this.m_count);
  if (index < this.m_count) {
    return this.m_vertices[index];
  } else {
    return this.m_vertices[0];
  }
}

/**
 * This always return false.
 */
ChainShape.prototype.testPoint = function(xf, p) {
  return false;
}

ChainShape.prototype.rayCast = function(output, input, xf, childIndex) {
  _ASSERT && common.assert(0 <= childIndex && childIndex < this.m_count);

  var edgeShape = new EdgeShape(this.getVertex(childIndex), this.getVertex(childIndex + 1));
  return edgeShape.rayCast(output, input, xf, 0);
}

ChainShape.prototype.computeAABB = function(aabb, xf, childIndex) {
  _ASSERT && common.assert(0 <= childIndex && childIndex < this.m_count);

  var v1 = Transform.mulVec2(xf, this.getVertex(childIndex));
  var v2 = Transform.mulVec2(xf, this.getVertex(childIndex + 1));

  aabb.combinePoints(v1, v2);
}

/**
 * Chains have zero mass.
 */
ChainShape.prototype.computeMass = function(massData, density) {
  massData.mass = 0.0;
  massData.center = Vec2.neo();
  massData.I = 0.0;
}

ChainShape.prototype.computeDistanceProxy = function(proxy, childIndex) {
  _ASSERT && common.assert(0 <= childIndex && childIndex < this.m_count);
  proxy.m_buffer[0] = this.getVertex(childIndex);
  proxy.m_buffer[1] = this.getVertex(childIndex + 1);
  proxy.m_vertices = proxy.m_buffer;
  proxy.m_count = 2;
  proxy.m_radius = this.m_radius;
};


/***/ }),
/* 93 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

module.exports = BoxShape;

var common = __webpack_require__(61);
var create = __webpack_require__(64);
var PolygonShape = __webpack_require__(91);

BoxShape._super = PolygonShape;
BoxShape.prototype = create(BoxShape._super.prototype);

BoxShape.TYPE = 'polygon';

/**
 * A rectangle polygon which extend PolygonShape.
 */
function BoxShape(hx, hy, center, angle) {
  if (!(this instanceof BoxShape)) {
    return new BoxShape(hx, hy, center, angle);
  }

  BoxShape._super.call(this);

  this._setAsBox(hx, hy, center, angle);
}



/***/ }),
/* 94 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

var common = __webpack_require__(61);
var create = __webpack_require__(64);
var Math = __webpack_require__(63);
var Transform = __webpack_require__(74);
var Vec2 = __webpack_require__(62);
var Settings = __webpack_require__(66);
var Shape = __webpack_require__(78);
var Contact = __webpack_require__(79);
var Manifold = __webpack_require__(81);
var CircleShape = __webpack_require__(89);

Contact.addType(CircleShape.TYPE, CircleShape.TYPE, CircleCircleContact);

function CircleCircleContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB, indexB) {
  _ASSERT && common.assert(fixtureA.getType() == CircleShape.TYPE);
  _ASSERT && common.assert(fixtureB.getType() == CircleShape.TYPE);
  CollideCircles(manifold, fixtureA.getShape(), xfA, fixtureB.getShape(), xfB);
}

function CollideCircles(manifold, circleA, xfA, circleB, xfB) {
  manifold.pointCount = 0;

  var pA = Transform.mulVec2(xfA, circleA.m_p);
  var pB = Transform.mulVec2(xfB, circleB.m_p);

  var distSqr = Vec2.distanceSquared(pB, pA);
  var rA = circleA.m_radius;
  var rB = circleB.m_radius;
  var radius = rA + rB;
  if (distSqr > radius * radius) {
    return;
  }

  manifold.type = Manifold.e_circles;
  manifold.localPoint.set(circleA.m_p);
  manifold.localNormal.setZero();
  manifold.pointCount = 1;
  manifold.points[0].localPoint.set(circleB.m_p);

  // manifold.points[0].id.key = 0;
  manifold.points[0].id.cf.indexA = 0;
  manifold.points[0].id.cf.typeA = Manifold.e_vertex;
  manifold.points[0].id.cf.indexB = 0;
  manifold.points[0].id.cf.typeB = Manifold.e_vertex;
}

exports.CollideCircles = CollideCircles;


/***/ }),
/* 95 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

var common = __webpack_require__(61);
var create = __webpack_require__(64);
var Math = __webpack_require__(63);
var Transform = __webpack_require__(74);
var Vec2 = __webpack_require__(62);
var Rot = __webpack_require__(72);
var Settings = __webpack_require__(66);
var Shape = __webpack_require__(78);
var Contact = __webpack_require__(79);
var Manifold = __webpack_require__(81);
var EdgeShape = __webpack_require__(90);
var ChainShape = __webpack_require__(92);
var CircleShape = __webpack_require__(89);

Contact.addType(EdgeShape.TYPE, CircleShape.TYPE, EdgeCircleContact);
Contact.addType(ChainShape.TYPE, CircleShape.TYPE, ChainCircleContact);

function EdgeCircleContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB,
    indexB) {
  _ASSERT && common.assert(fixtureA.getType() == EdgeShape.TYPE);
  _ASSERT && common.assert(fixtureB.getType() == CircleShape.TYPE);

  var shapeA = fixtureA.getShape();
  var shapeB = fixtureB.getShape();

  CollideEdgeCircle(manifold, shapeA, xfA, shapeB, xfB);
}

function ChainCircleContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB,
    indexB) {
  _ASSERT && common.assert(fixtureA.getType() == ChainShape.TYPE);
  _ASSERT && common.assert(fixtureB.getType() == CircleShape.TYPE);

  var chain = fixtureA.getShape();
  var edge = new EdgeShape();
  chain.getChildEdge(edge, indexA);

  var shapeA = edge;
  var shapeB = fixtureB.getShape();

  CollideEdgeCircle(manifold, shapeA, xfA, shapeB, xfB);
}

// Compute contact points for edge versus circle.
// This accounts for edge connectivity.
function CollideEdgeCircle(manifold, edgeA, xfA, circleB, xfB) {
  manifold.pointCount = 0;

  // Compute circle in frame of edge
  var Q = Transform.mulTVec2(xfA, Transform.mulVec2(xfB, circleB.m_p));

  var A = edgeA.m_vertex1;
  var B = edgeA.m_vertex2;
  var e = Vec2.sub(B, A);

  // Barycentric coordinates
  var u = Vec2.dot(e, Vec2.sub(B, Q));
  var v = Vec2.dot(e, Vec2.sub(Q, A));

  var radius = edgeA.m_radius + circleB.m_radius;

  // Region A
  if (v <= 0.0) {
    var P = Vec2.clone(A);
    var d = Vec2.sub(Q, P);
    var dd = Vec2.dot(d, d);
    if (dd > radius * radius) {
      return;
    }

    // Is there an edge connected to A?
    if (edgeA.m_hasVertex0) {
      var A1 = edgeA.m_vertex0;
      var B1 = A;
      var e1 = Vec2.sub(B1, A1);
      var u1 = Vec2.dot(e1, Vec2.sub(B1, Q));

      // Is the circle in Region AB of the previous edge?
      if (u1 > 0.0) {
        return;
      }
    }

    manifold.type = Manifold.e_circles;
    manifold.localNormal.setZero();
    manifold.localPoint.set(P);
    manifold.pointCount = 1;
    manifold.points[0].localPoint.set(circleB.m_p);

    // manifold.points[0].id.key = 0;
    manifold.points[0].id.cf.indexA = 0;
    manifold.points[0].id.cf.typeA = Manifold.e_vertex;
    manifold.points[0].id.cf.indexB = 0;
    manifold.points[0].id.cf.typeB = Manifold.e_vertex;
    return;
  }

  // Region B
  if (u <= 0.0) {
    var P = Vec2.clone(B);
    var d = Vec2.sub(Q, P);
    var dd = Vec2.dot(d, d);
    if (dd > radius * radius) {
      return;
    }

    // Is there an edge connected to B?
    if (edgeA.m_hasVertex3) {
      var B2 = edgeA.m_vertex3;
      var A2 = B;
      var e2 = Vec2.sub(B2, A2);
      var v2 = Vec2.dot(e2, Vec2.sub(Q, A2));

      // Is the circle in Region AB of the next edge?
      if (v2 > 0.0) {
        return;
      }
    }

    manifold.type = Manifold.e_circles;
    manifold.localNormal.setZero();
    manifold.localPoint.set(P);
    manifold.pointCount = 1;
    manifold.points[0].localPoint.set(circleB.m_p);

    // manifold.points[0].id.key = 0;
    manifold.points[0].id.cf.indexA = 1;
    manifold.points[0].id.cf.typeA = Manifold.e_vertex;
    manifold.points[0].id.cf.indexB = 0;
    manifold.points[0].id.cf.typeB = Manifold.e_vertex;
    return;
  }

  // Region AB
  var den = Vec2.dot(e, e);
  _ASSERT && common.assert(den > 0.0);
  var P = Vec2.combine(u / den, A, v / den, B);
  var d = Vec2.sub(Q, P);
  var dd = Vec2.dot(d, d);
  if (dd > radius * radius) {
    return;
  }

  var n = Vec2.neo(-e.y, e.x);
  if (Vec2.dot(n, Vec2.sub(Q, A)) < 0.0) {
    n.set(-n.x, -n.y);
  }
  n.normalize();

  manifold.type = Manifold.e_faceA;
  manifold.localNormal = n;
  manifold.localPoint.set(A);
  manifold.pointCount = 1;
  manifold.points[0].localPoint.set(circleB.m_p);

  // manifold.points[0].id.key = 0;
  manifold.points[0].id.cf.indexA = 0;
  manifold.points[0].id.cf.typeA = Manifold.e_face;
  manifold.points[0].id.cf.indexB = 0;
  manifold.points[0].id.cf.typeB = Manifold.e_vertex;
}


/***/ }),
/* 96 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

var common = __webpack_require__(61);
var Math = __webpack_require__(63);
var Transform = __webpack_require__(74);
var Rot = __webpack_require__(72);
var Vec2 = __webpack_require__(62);
var AABB = __webpack_require__(67);
var Settings = __webpack_require__(66);
var Manifold = __webpack_require__(81);
var Contact = __webpack_require__(79);
var Shape = __webpack_require__(78);
var PolygonShape = __webpack_require__(91);

module.exports = CollidePolygons;

Contact.addType(PolygonShape.TYPE, PolygonShape.TYPE, PolygonContact);

function PolygonContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB, indexB) {
  _ASSERT && common.assert(fixtureA.getType() == PolygonShape.TYPE);
  _ASSERT && common.assert(fixtureB.getType() == PolygonShape.TYPE);
  CollidePolygons(manifold, fixtureA.getShape(), xfA, fixtureB.getShape(), xfB);
}

/**
 * Find the max separation between poly1 and poly2 using edge normals from
 * poly1.
 */
function FindMaxSeparation(poly1, xf1, poly2, xf2) {
  var count1 = poly1.m_count;
  var count2 = poly2.m_count;
  var n1s = poly1.m_normals;
  var v1s = poly1.m_vertices;
  var v2s = poly2.m_vertices;
  var xf = Transform.mulTXf(xf2, xf1);

  var bestIndex = 0;
  var maxSeparation = -Infinity;
  for (var i = 0; i < count1; ++i) {
    // Get poly1 normal in frame2.
    var n = Rot.mulVec2(xf.q, n1s[i]);
    var v1 = Transform.mulVec2(xf, v1s[i]);

    // Find deepest point for normal i.
    var si = Infinity;
    for (var j = 0; j < count2; ++j) {
      var sij = Vec2.dot(n, v2s[j]) - Vec2.dot(n, v1);
      if (sij < si) {
        si = sij;
      }
    }

    if (si > maxSeparation) {
      maxSeparation = si;
      bestIndex = i;
    }
  }

  // used to keep last FindMaxSeparation call values
  FindMaxSeparation._maxSeparation = maxSeparation;
  FindMaxSeparation._bestIndex = bestIndex;
}

/**
 * @param {ClipVertex[2]} c
 * @param {int} edge1
 */
function FindIncidentEdge(c, poly1, xf1, edge1, poly2, xf2) {
  var normals1 = poly1.m_normals;

  var count2 = poly2.m_count;
  var vertices2 = poly2.m_vertices;
  var normals2 = poly2.m_normals;

  _ASSERT && common.assert(0 <= edge1 && edge1 < poly1.m_count);

  // Get the normal of the reference edge in poly2's frame.
  var normal1 = Rot.mulT(xf2.q, Rot.mulVec2(xf1.q, normals1[edge1]));

  // Find the incident edge on poly2.
  var index = 0;
  var minDot = Infinity;
  for (var i = 0; i < count2; ++i) {
    var dot = Vec2.dot(normal1, normals2[i]);
    if (dot < minDot) {
      minDot = dot;
      index = i;
    }
  }

  // Build the clip vertices for the incident edge.
  var i1 = index;
  var i2 = i1 + 1 < count2 ? i1 + 1 : 0;

  c[0].v = Transform.mulVec2(xf2, vertices2[i1]);
  c[0].id.cf.indexA = edge1;
  c[0].id.cf.indexB = i1;
  c[0].id.cf.typeA = Manifold.e_face;
  c[0].id.cf.typeB = Manifold.e_vertex;

  c[1].v = Transform.mulVec2(xf2, vertices2[i2]);
  c[1].id.cf.indexA = edge1;
  c[1].id.cf.indexB = i2;
  c[1].id.cf.typeA = Manifold.e_face;
  c[1].id.cf.typeB = Manifold.e_vertex;
}

/**
 * 
 * Find edge normal of max separation on A - return if separating axis is found<br>
 * Find edge normal of max separation on B - return if separation axis is found<br>
 * Choose reference edge as min(minA, minB)<br>
 * Find incident edge<br>
 * Clip
 * 
 * The normal points from 1 to 2
 */
function CollidePolygons(manifold, polyA, xfA, polyB, xfB) {
  manifold.pointCount = 0;
  var totalRadius = polyA.m_radius + polyB.m_radius;

  FindMaxSeparation(polyA, xfA, polyB, xfB);
  var edgeA = FindMaxSeparation._bestIndex;
  var separationA = FindMaxSeparation._maxSeparation;
  if (separationA > totalRadius)
    return;

  FindMaxSeparation(polyB, xfB, polyA, xfA);
  var edgeB = FindMaxSeparation._bestIndex;
  var separationB = FindMaxSeparation._maxSeparation;
  if (separationB > totalRadius)
    return;

  var poly1; // reference polygon
  var poly2; // incident polygon
  var xf1;
  var xf2;
  var edge1; // reference edge
  var flip;
  var k_tol = 0.1 * Settings.linearSlop;

  if (separationB > separationA + k_tol) {
    poly1 = polyB;
    poly2 = polyA;
    xf1 = xfB;
    xf2 = xfA;
    edge1 = edgeB;
    manifold.type = Manifold.e_faceB;
    flip = 1;
  } else {
    poly1 = polyA;
    poly2 = polyB;
    xf1 = xfA;
    xf2 = xfB;
    edge1 = edgeA;
    manifold.type = Manifold.e_faceA;
    flip = 0;
  }

  var incidentEdge = [ new Manifold.clipVertex(), new Manifold.clipVertex() ];
  FindIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);

  var count1 = poly1.m_count;
  var vertices1 = poly1.m_vertices;

  var iv1 = edge1;
  var iv2 = edge1 + 1 < count1 ? edge1 + 1 : 0;

  var v11 = vertices1[iv1];
  var v12 = vertices1[iv2];

  var localTangent = Vec2.sub(v12, v11);
  localTangent.normalize();

  var localNormal = Vec2.cross(localTangent, 1.0);
  var planePoint = Vec2.combine(0.5, v11, 0.5, v12);

  var tangent = Rot.mulVec2(xf1.q, localTangent);
  var normal = Vec2.cross(tangent, 1.0);

  v11 = Transform.mulVec2(xf1, v11);
  v12 = Transform.mulVec2(xf1, v12);

  // Face offset.
  var frontOffset = Vec2.dot(normal, v11);

  // Side offsets, extended by polytope skin thickness.
  var sideOffset1 = -Vec2.dot(tangent, v11) + totalRadius;
  var sideOffset2 = Vec2.dot(tangent, v12) + totalRadius;

  // Clip incident edge against extruded edge1 side edges.
  var clipPoints1 = [ new Manifold.clipVertex(), new Manifold.clipVertex() ];
  var clipPoints2 = [ new Manifold.clipVertex(), new Manifold.clipVertex() ];
  var np;

  // Clip to box side 1
  np = Manifold.clipSegmentToLine(clipPoints1, incidentEdge, Vec2.neg(tangent),
      sideOffset1, iv1);

  if (np < 2) {
    return;
  }

  // Clip to negative box side 1
  np = Manifold.clipSegmentToLine(clipPoints2, clipPoints1, tangent,
      sideOffset2, iv2);

  if (np < 2) {
    return;
  }

  // Now clipPoints2 contains the clipped points.
  manifold.localNormal = localNormal;
  manifold.localPoint = planePoint;

  var pointCount = 0;
  for (var i = 0; i < clipPoints2.length/* maxManifoldPoints */; ++i) {
    var separation = Vec2.dot(normal, clipPoints2[i].v) - frontOffset;

    if (separation <= totalRadius) {
      var cp = manifold.points[pointCount]; // ManifoldPoint
      cp.localPoint.set(Transform.mulTVec2(xf2, clipPoints2[i].v));
      cp.id = clipPoints2[i].id;
      if (flip) {
        // Swap features
        var cf = cp.id.cf; // ContactFeature
        var indexA = cf.indexA;
        var indexB = cf.indexB;
        var typeA = cf.typeA;
        var typeB = cf.typeB;
        cf.indexA = indexB;
        cf.indexB = indexA;
        cf.typeA = typeB;
        cf.typeB = typeA;
      }
      ++pointCount;
    }
  }

  manifold.pointCount = pointCount;
}


/***/ }),
/* 97 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

var common = __webpack_require__(61);
var Math = __webpack_require__(63);
var Transform = __webpack_require__(74);
var Rot = __webpack_require__(72);
var Vec2 = __webpack_require__(62);
var AABB = __webpack_require__(67);
var Settings = __webpack_require__(66);
var Manifold = __webpack_require__(81);
var Contact = __webpack_require__(79);
var Shape = __webpack_require__(78);
var CircleShape = __webpack_require__(89);
var PolygonShape = __webpack_require__(91);

Contact.addType(PolygonShape.TYPE, CircleShape.TYPE, PolygonCircleContact);

function PolygonCircleContact(manifold, xfA, fixtureA, indexA, xfB, fixtureB, indexB) {
  _ASSERT && common.assert(fixtureA.getType() == PolygonShape.TYPE);
  _ASSERT && common.assert(fixtureB.getType() == CircleShape.TYPE);
  CollidePolygonCircle(manifold, fixtureA.getShape(), xfA, fixtureB.getShape(),
      xfB);
}

function CollidePolygonCircle(manifold, polygonA, xfA, circleB, xfB) {
  manifold.pointCount = 0;

  // Compute circle position in the frame of the polygon.
  var c = Transform.mulVec2(xfB, circleB.m_p);
  var cLocal = Transform.mulTVec2(xfA, c);

  // Find the min separating edge.
  var normalIndex = 0;
  var separation = -Infinity;
  var radius = polygonA.m_radius + circleB.m_radius;
  var vertexCount = polygonA.m_count;
  var vertices = polygonA.m_vertices;
  var normals = polygonA.m_normals;

  for (var i = 0; i < vertexCount; ++i) {
    var s = Vec2.dot(normals[i], Vec2.sub(cLocal, vertices[i]));

    if (s > radius) {
      // Early out.
      return;
    }

    if (s > separation) {
      separation = s;
      normalIndex = i;
    }
  }

  // Vertices that subtend the incident face.
  var vertIndex1 = normalIndex;
  var vertIndex2 = vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0;
  var v1 = vertices[vertIndex1];
  var v2 = vertices[vertIndex2];

  // If the center is inside the polygon ...
  if (separation < Math.EPSILON) {
    manifold.pointCount = 1;
    manifold.type = Manifold.e_faceA;
    manifold.localNormal.set(normals[normalIndex]);
    manifold.localPoint.setCombine(0.5, v1, 0.5, v2);
    manifold.points[0].localPoint = circleB.m_p;

    // manifold.points[0].id.key = 0;
    manifold.points[0].id.cf.indexA = 0;
    manifold.points[0].id.cf.typeA = Manifold.e_vertex;
    manifold.points[0].id.cf.indexB = 0;
    manifold.points[0].id.cf.typeB = Manifold.e_vertex;
    return;
  }

  // Compute barycentric coordinates
  var u1 = Vec2.dot(Vec2.sub(cLocal, v1), Vec2.sub(v2, v1));
  var u2 = Vec2.dot(Vec2.sub(cLocal, v2), Vec2.sub(v1, v2));
  if (u1 <= 0.0) {
    if (Vec2.distanceSquared(cLocal, v1) > radius * radius) {
      return;
    }

    manifold.pointCount = 1;
    manifold.type = Manifold.e_faceA;
    manifold.localNormal.setCombine(1, cLocal, -1, v1);
    manifold.localNormal.normalize();
    manifold.localPoint = v1;
    manifold.points[0].localPoint.set(circleB.m_p);

    // manifold.points[0].id.key = 0;
    manifold.points[0].id.cf.indexA = 0;
    manifold.points[0].id.cf.typeA = Manifold.e_vertex;
    manifold.points[0].id.cf.indexB = 0;
    manifold.points[0].id.cf.typeB = Manifold.e_vertex;
  } else if (u2 <= 0.0) {
    if (Vec2.distanceSquared(cLocal, v2) > radius * radius) {
      return;
    }

    manifold.pointCount = 1;
    manifold.type = Manifold.e_faceA;
    manifold.localNormal.setCombine(1, cLocal, -1, v2);
    manifold.localNormal.normalize();
    manifold.localPoint.set(v2);
    manifold.points[0].localPoint.set(circleB.m_p);

    // manifold.points[0].id.key = 0;
    manifold.points[0].id.cf.indexA = 0;
    manifold.points[0].id.cf.typeA = Manifold.e_vertex;
    manifold.points[0].id.cf.indexB = 0;
    manifold.points[0].id.cf.typeB = Manifold.e_vertex;
  } else {
    var faceCenter = Vec2.mid(v1, v2);
    var separation = Vec2.dot(cLocal, normals[vertIndex1])
        - Vec2.dot(faceCenter, normals[vertIndex1]);
    if (separation > radius) {
      return;
    }

    manifold.pointCount = 1;
    manifold.type = Manifold.e_faceA;
    manifold.localNormal.set(normals[vertIndex1]);
    manifold.localPoint.set(faceCenter);
    manifold.points[0].localPoint.set(circleB.m_p);

    // manifold.points[0].id.key = 0;
    manifold.points[0].id.cf.indexA = 0;
    manifold.points[0].id.cf.typeA = Manifold.e_vertex;
    manifold.points[0].id.cf.indexB = 0;
    manifold.points[0].id.cf.typeB = Manifold.e_vertex;
  }
}


/***/ }),
/* 98 */
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

var common = __webpack_require__(61);
var create = __webpack_require__(64);
var Math = __webpack_require__(63);
var Transform = __webpack_require__(74);
var Vec2 = __webpack_require__(62);
var Rot = __webpack_require__(72);
var Settings = __webpack_require__(66);
var Shape = __webpack_require__(78);
var Contact = __webpack_require__(79);
var Manifold = __webpack_require__(81);
var EdgeShape = __webpack_require__(90);
var ChainShape = __webpack_require__(92);
var PolygonShape = __webpack_require__(91);

Contact.addType(EdgeShape.TYPE, PolygonShape.TYPE, EdgePolygonContact);
Contact.addType(ChainShape.TYPE, PolygonShape.TYPE, ChainPolygonContact);

function EdgePolygonContact(manifold, xfA, fA, indexA, xfB, fB, indexB) {
  _ASSERT && common.assert(fA.getType() == EdgeShape.TYPE);
  _ASSERT && common.assert(fB.getType() == PolygonShape.TYPE);

  CollideEdgePolygon(manifold, fA.getShape(), xfA, fB.getShape(), xfB);
}

function ChainPolygonContact(manifold, xfA, fA, indexA, xfB, fB, indexB) {
  _ASSERT && common.assert(fA.getType() == ChainShape.TYPE);
  _ASSERT && common.assert(fB.getType() == PolygonShape.TYPE);

  var chain = fA.getShape();
  var edge = new EdgeShape();
  chain.getChildEdge(edge, indexA);

  CollideEdgePolygon(manifold, edge, xfA, fB.getShape(), xfB);
}

// EPAxis Type
var e_unknown = -1;
var e_edgeA = 1;
var e_edgeB = 2;

// VertexType unused?
var e_isolated = 0;
var e_concave = 1;
var e_convex = 2;

// This structure is used to keep track of the best separating axis.
function EPAxis() {
  this.type; // Type
  this.index;
  this.separation;
};

// This holds polygon B expressed in frame A.
function TempPolygon() {
  this.vertices = []; // Vec2[Settings.maxPolygonVertices]
  this.normals = []; // Vec2[Settings.maxPolygonVertices];
  this.count = 0;
};

// Reference face used for clipping
function ReferenceFace() {
  this.i1, this.i2; // int
  this.v1, this.v2; // v
  this.normal = Vec2.zero();
  this.sideNormal1 = Vec2.zero();
  this.sideOffset1; // float
  this.sideNormal2 = Vec2.zero();
  this.sideOffset2; // float
};

// reused
var edgeAxis = new EPAxis();
var polygonAxis = new EPAxis();
var polygonBA = new TempPolygon();
var rf = new ReferenceFace();

/**
 * This function collides and edge and a polygon, taking into account edge
 * adjacency.
 */
function CollideEdgePolygon(manifold, edgeA, xfA, polygonB, xfB) {
  // Algorithm:
  // 1. Classify v1 and v2
  // 2. Classify polygon centroid as front or back
  // 3. Flip normal if necessary
  // 4. Initialize normal range to [-pi, pi] about face normal
  // 5. Adjust normal range according to adjacent edges
  // 6. Visit each separating axes, only accept axes within the range
  // 7. Return if _any_ axis indicates separation
  // 8. Clip

  var m_type1, m_type2; // VertexType unused?

  var xf = Transform.mulTXf(xfA, xfB);

  var centroidB = Transform.mulVec2(xf, polygonB.m_centroid);

  var v0 = edgeA.m_vertex0;
  var v1 = edgeA.m_vertex1;
  var v2 = edgeA.m_vertex2;
  var v3 = edgeA.m_vertex3;

  var hasVertex0 = edgeA.m_hasVertex0;
  var hasVertex3 = edgeA.m_hasVertex3;

  var edge1 = Vec2.sub(v2, v1);
  edge1.normalize();
  var normal1 = Vec2.neo(edge1.y, -edge1.x);
  var offset1 = Vec2.dot(normal1, Vec2.sub(centroidB, v1));
  var offset0 = 0.0;
  var offset2 = 0.0;
  var convex1 = false;
  var convex2 = false;

  // Is there a preceding edge?
  if (hasVertex0) {
    var edge0 = Vec2.sub(v1, v0);
    edge0.normalize();
    var normal0 = Vec2.neo(edge0.y, -edge0.x);
    convex1 = Vec2.cross(edge0, edge1) >= 0.0;
    offset0 = Vec2.dot(normal0, centroidB) - Vec2.dot(normal0, v0);
  }

  // Is there a following edge?
  if (hasVertex3) {
    var edge2 = Vec2.sub(v3, v2);
    edge2.normalize();
    var normal2 = Vec2.neo(edge2.y, -edge2.x);
    convex2 = Vec2.cross(edge1, edge2) > 0.0;
    offset2 = Vec2.dot(normal2, centroidB) - Vec2.dot(normal2, v2);
  }

  var front;
  var normal = Vec2.zero();
  var lowerLimit = Vec2.zero();
  var upperLimit = Vec2.zero();

  // Determine front or back collision. Determine collision normal limits.
  if (hasVertex0 && hasVertex3) {
    if (convex1 && convex2) {
      front = offset0 >= 0.0 || offset1 >= 0.0 || offset2 >= 0.0;
      if (front) {
        normal.set(normal1);
        lowerLimit.set(normal0);
        upperLimit.set(normal2);
      } else {
        normal.setMul(-1, normal1);
        lowerLimit.setMul(-1, normal1);
        upperLimit.setMul(-1, normal1);
      }
    } else if (convex1) {
      front = offset0 >= 0.0 || (offset1 >= 0.0 && offset2 >= 0.0);
      if (front) {
        normal.set(normal1);
        lowerLimit.set(normal0);
        upperLimit.set(normal1);
      } else {
        normal.setMul(-1, normal1);
        lowerLimit.setMul(-1, normal2);
        upperLimit.setMul(-1, normal1);
      }
    } else if (convex2) {
      front = offset2 >= 0.0 || (offset0 >= 0.0 && offset1 >= 0.0);
      if (front) {
        normal.set(normal1);
        lowerLimit.set(normal1);
        upperLimit.set(normal2);
      } else {
        normal.setMul(-1, normal1);
        lowerLimit.setMul(-1, normal1);
        upperLimit.setMul(-1, normal0);
      }
    } else {
      front = offset0 >= 0.0 && offset1 >= 0.0 && offset2 >= 0.0;
      if (front) {
        normal.set(normal1);
        lowerLimit.set(normal1);
        upperLimit.set(normal1);
      } else {
        normal.setMul(-1, normal1);
        lowerLimit.setMul(-1, normal2);
        upperLimit.setMul(-1, normal0);
      }
    }
  } else if (hasVertex0) {
    if (convex1) {
      front = offset0 >= 0.0 || offset1 >= 0.0;
      if (front) {
        normal.set(normal1);
        lowerLimit.set(normal0);
        upperLimit.setMul(-1, normal1);
      } else {
        normal.setMul(-1, normal1);
        lowerLimit.set(normal1);
        upperLimit.setMul(-1, normal1);
      }
    } else {
      front = offset0 >= 0.0 && offset1 >= 0.0;
      if (front) {
        normal.set(normal1);
        lowerLimit.set(normal1);
        upperLimit.setMul(-1, normal1);
      } else {
        normal.setMul(-1, normal1);
        lowerLimit.set(normal1);
        upperLimit.setMul(-1, normal0);
      }
    }
  } else if (hasVertex3) {
    if (convex2) {
      front = offset1 >= 0.0 || offset2 >= 0.0;
      if (front) {
        normal.set(normal1);
        lowerLimit.setMul(-1, normal1);
        upperLimit.set(normal2);
      } else {
        normal.setMul(-1, normal1);
        lowerLimit.setMul(-1, normal1);
        upperLimit.set(normal1);
      }
    } else {
      front = offset1 >= 0.0 && offset2 >= 0.0;
      if (front) {
        normal.set(normal1);
        lowerLimit.setMul(-1, normal1);
        upperLimit.set(normal1);
      } else {
        normal.setMul(-1, normal1);
        lowerLimit.setMul(-1, normal2);
        upperLimit.set(normal1);
      }
    }
  } else {
    front = offset1 >= 0.0;
    if (front) {
      normal.set(normal1);
      lowerLimit.setMul(-1, normal1);
      upperLimit.setMul(-1, normal1);
    } else {
      normal.setMul(-1, normal1);
      lowerLimit.set(normal1);
      upperLimit.set(normal1);
    }
  }

  // Get polygonB in frameA
  polygonBA.count = polygonB.m_count;
  for (var i = 0; i < polygonB.m_count; ++i) {
    polygonBA.vertices[i] = Transform.mulVec2(xf, polygonB.m_vertices[i]);
    polygonBA.normals[i] = Rot.mulVec2(xf.q, polygonB.m_normals[i]);
  }

  var radius = 2.0 * Settings.polygonRadius;

  manifold.pointCount = 0;

  { // ComputeEdgeSeparation
    edgeAxis.type = e_edgeA;
    edgeAxis.index = front ? 0 : 1;
    edgeAxis.separation = Infinity;

    for (var i = 0; i < polygonBA.count; ++i) {
      var s = Vec2.dot(normal, Vec2.sub(polygonBA.vertices[i], v1));
      if (s < edgeAxis.separation) {
        edgeAxis.separation = s;
      }
    }
  }

  // If no valid normal can be found than this edge should not collide.
  if (edgeAxis.type == e_unknown) {
    return;
  }

  if (edgeAxis.separation > radius) {
    return;
  }

  { // ComputePolygonSeparation
    polygonAxis.type = e_unknown;
    polygonAxis.index = -1;
    polygonAxis.separation = -Infinity;

    var perp = Vec2.neo(-normal.y, normal.x);

    for (var i = 0; i < polygonBA.count; ++i) {
      var n = Vec2.neg(polygonBA.normals[i]);

      var s1 = Vec2.dot(n, Vec2.sub(polygonBA.vertices[i], v1));
      var s2 = Vec2.dot(n, Vec2.sub(polygonBA.vertices[i], v2));
      var s = Math.min(s1, s2);

      if (s > radius) {
        // No collision
        polygonAxis.type = e_edgeB;
        polygonAxis.index = i;
        polygonAxis.separation = s;
        break;
      }

      // Adjacency
      if (Vec2.dot(n, perp) >= 0.0) {
        if (Vec2.dot(Vec2.sub(n, upperLimit), normal) < -Settings.angularSlop) {
          continue;
        }
      } else {
        if (Vec2.dot(Vec2.sub(n, lowerLimit), normal) < -Settings.angularSlop) {
          continue;
        }
      }

      if (s > polygonAxis.separation) {
        polygonAxis.type = e_edgeB;
        polygonAxis.index = i;
        polygonAxis.separation = s;
      }
    }
  }

  if (polygonAxis.type != e_unknown && polygonAxis.separation > radius) {
    return;
  }

  // Use hysteresis for jitter reduction.
  var k_relativeTol = 0.98;
  var k_absoluteTol = 0.001;

  var primaryAxis;
  if (polygonAxis.type == e_unknown) {
    primaryAxis = edgeAxis;
  } else if (polygonAxis.separation > k_relativeTol * edgeAxis.separation + k_absoluteTol) {
    primaryAxis = polygonAxis;
  } else {
    primaryAxis = edgeAxis;
  }

  var ie = [ new Manifold.clipVertex(), new Manifold.clipVertex() ];

  if (primaryAxis.type == e_edgeA) {
    manifold.type = Manifold.e_faceA;

    // Search for the polygon normal that is most anti-parallel to the edge
    // normal.
    var bestIndex = 0;
    var bestValue = Vec2.dot(normal, polygonBA.normals[0]);
    for (var i = 1; i < polygonBA.count; ++i) {
      var value = Vec2.dot(normal, polygonBA.normals[i]);
      if (value < bestValue) {
        bestValue = value;
        bestIndex = i;
      }
    }

    var i1 = bestIndex;
    var i2 = i1 + 1 < polygonBA.count ? i1 + 1 : 0;

    ie[0].v = polygonBA.vertices[i1];
    ie[0].id.cf.indexA = 0;
    ie[0].id.cf.indexB = i1;
    ie[0].id.cf.typeA = Manifold.e_face;
    ie[0].id.cf.typeB = Manifold.e_vertex;

    ie[1].v = polygonBA.vertices[i2];
    ie[1].id.cf.indexA = 0;
    ie[1].id.cf.indexB = i2;
    ie[1].id.cf.typeA = Manifold.e_face;
    ie[1].id.cf.typeB = Manifold.e_vertex;

    if (front) {
      rf.i1 = 0;
      rf.i2 = 1;
      rf.v1 = v1;
      rf.v2 = v2;
      rf.normal.set(normal1);
    } else {
      rf.i1 = 1;
      rf.i2 = 0;
      rf.v1 = v2;
      rf.v2 = v1;
      rf.normal.setMul(-1, normal1);
    }
  } else {
    manifold.type = Manifold.e_faceB;

    ie[0].v = v1;
    ie[0].id.cf.indexA = 0;
    ie[0].id.cf.indexB = primaryAxis.index;
    ie[0].id.cf.typeA = Manifold.e_vertex;
    ie[0].id.cf.typeB = Manifold.e_face;

    ie[1].v = v2;
    ie[1].id.cf.indexA = 0;
    ie[1].id.cf.indexB = primaryAxis.index;
    ie[1].id.cf.typeA = Manifold.e_vertex;
    ie[1].id.cf.typeB = Manifold.e_face;

    rf.i1 = primaryAxis.index;
    rf.i2 = rf.i1 + 1 < polygonBA.count ? rf.i1 + 1 : 0;
    rf.v1 = polygonBA.vertices[rf.i1];
    rf.v2 = polygonBA.vertices[rf.i2];
    rf.normal.set(polygonBA.normals[rf.i1]);
  }

  rf.sideNormal1.set(rf.normal.y, -rf.normal.x);
  rf.sideNormal2.setMul(-1, rf.sideNormal1);
  rf.sideOffset1 = Vec2.dot(rf.sideNormal1, rf.v1);
  rf.sideOffset2 = Vec2.dot(rf.sideNormal2, rf.v2);

  // Clip incident edge against extruded edge1 side edges.
  var clipPoints1 = [ new Manifold.clipVertex(), new Manifold.clipVertex() ];
  var clipPoints2 = [ new Manifold.clipVertex(), new Manifold.clipVertex() ];

  var np;

  // Clip to box side 1
  np = Manifold.clipSegmentToLine(clipPoints1, ie, rf.sideNormal1, rf.sideOffset1, rf.i1);

  if (np < Settings.maxManifoldPoints) {
    return;
  }

  // Clip to negative box side 1
  np = Manifold.clipSegmentToLine(clipPoints2, clipPoints1, rf.sideNormal2, rf.sideOffset2, rf.i2);

  if (np < Settings.maxManifoldPoints) {
    return;
  }

  // Now clipPoints2 contains the clipped points.
  if (primaryAxis.type == e_edgeA) {
    manifold.localNormal = Vec2.clone(rf.normal);
    manifold.localPoint = Vec2.clone(rf.v1);
  } else {
    manifold.localNormal = Vec2.clone(polygonB.m_normals[rf.i1]);
    manifold.localPoint = Vec2.clone(polygonB.m_vertices[rf.i1]);
  }

  var pointCount = 0;
  for (var i = 0; i < Settings.maxManifoldPoints; ++i) {
    var separation = Vec2.dot(rf.normal, Vec2.sub(clipPoints2[i].v, rf.v1));

    if (separation <= radius) {
      var cp = manifold.points[pointCount]; // ManifoldPoint

      if (primaryAxis.type == e_edgeA) {
        cp.localPoint = Transform.mulT(xf, clipPoints2[i].v);
        cp.id = clipPoints2[i].id;
      } else {
        cp.localPoint = clipPoints2[i].v;
        cp.id.cf.typeA = clipPoints2[i].id.cf.typeB;
        cp.id.cf.typeB = clipPoints2[i].id.cf.typeA;
        cp.id.cf.indexA = clipPoints2[i].id.cf.indexB;
        cp.id.cf.indexB = clipPoints2[i].id.cf.indexA;
      }

      ++pointCount;
    }
  }

  manifold.pointCount = pointCount;
}


/***/ }),
/* 99 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

module.exports = DistanceJoint;

var options = __webpack_require__(60);
var create = __webpack_require__(64);
var Settings = __webpack_require__(66);

var Math = __webpack_require__(63);
var Vec2 = __webpack_require__(62);
var Vec3 = __webpack_require__(84);
var Mat22 = __webpack_require__(80);
var Mat33 = __webpack_require__(85);
var Rot = __webpack_require__(72);
var Sweep = __webpack_require__(73);
var Transform = __webpack_require__(74);
var Velocity = __webpack_require__(75);
var Position = __webpack_require__(76);

var Joint = __webpack_require__(86);
var Body = __webpack_require__(71);

DistanceJoint.TYPE = 'distance-joint';
Joint.TYPES[DistanceJoint.TYPE] = DistanceJoint;

DistanceJoint._super = Joint;
DistanceJoint.prototype = create(DistanceJoint._super.prototype);

/**
 * @typedef {Object} DistanceJointDef
 *
 * Distance joint definition. This requires defining an anchor point on both
 * bodies and the non-zero length of the distance joint. The definition uses
 * local anchor points so that the initial configuration can violate the
 * constraint slightly. This helps when saving and loading a game. Warning: Do
 * not use a zero or short length.
 * 
 * @prop {float} frequencyHz The mass-spring-damper frequency in Hertz. A value
 *       of 0 disables softness.
 * @prop {float} dampingRatio The damping ratio. 0 = no damping, 1 = critical
 *       damping.
 *
 * @prop {Vec2} localAnchorA The local anchor point relative to bodyA's origin.
 * @prop {Vec2} localAnchorB The local anchor point relative to bodyB's origin.
 * @prop {number} length Distance length.
 */

var DEFAULTS = {
  frequencyHz : 0.0,
  dampingRatio : 0.0
};

/**
 * A distance joint constrains two points on two bodies to remain at a fixed
 * distance from each other. You can view this as a massless, rigid rod.
 *
 * @param {DistanceJointDef} def
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Vec2} anchorA Anchor A in global coordination.
 * @param {Vec2} anchorB Anchor B in global coordination.
 */
function DistanceJoint(def, bodyA, bodyB, anchorA, anchorB) {
  if (!(this instanceof DistanceJoint)) {
    return new DistanceJoint(def, bodyA, bodyB, anchorA, anchorB);
  }

  // order of constructor arguments is changed in v0.2
  if (bodyB && anchorA && ('m_type' in anchorA) && ('x' in bodyB) && ('y' in bodyB)) {
    var temp = bodyB;
    bodyB = anchorA;
    anchorA = temp;
  }

  def = options(def, DEFAULTS);
  Joint.call(this, def, bodyA, bodyB);
  bodyA = this.m_bodyA;
  bodyB = this.m_bodyB;

  this.m_type = DistanceJoint.TYPE;

  // Solver shared
  this.m_localAnchorA = Vec2.clone(anchorA ? bodyA.getLocalPoint(anchorA) : def.localAnchorA || Vec2.zero());
  this.m_localAnchorB = Vec2.clone(anchorB ? bodyB.getLocalPoint(anchorB) : def.localAnchorB || Vec2.zero());
  this.m_length = Math.isFinite(def.length) ? def.length :
    Vec2.distance(bodyA.getWorldPoint(this.m_localAnchorA), bodyB.getWorldPoint(this.m_localAnchorB));
  this.m_frequencyHz = def.frequencyHz;
  this.m_dampingRatio = def.dampingRatio;
  this.m_impulse = 0.0;
  this.m_gamma = 0.0;
  this.m_bias = 0.0;

  // Solver temp
  this.m_u; // Vec2
  this.m_rA; // Vec2
  this.m_rB; // Vec2
  this.m_localCenterA; // Vec2
  this.m_localCenterB; // Vec2
  this.m_invMassA;
  this.m_invMassB;
  this.m_invIA;
  this.m_invIB;
  this.m_mass;

  // 1-D constrained system
  // m (v2 - v1) = lambda
  // v2 + (beta/h) * x1 + gamma * lambda = 0, gamma has units of inverse mass.
  // x2 = x1 + h * v2

  // 1-D mass-damper-spring system
  // m (v2 - v1) + h * d * v2 + h * k *

  // C = norm(p2 - p1) - L
  // u = (p2 - p1) / norm(p2 - p1)
  // Cdot = dot(u, v2 + cross(w2, r2) - v1 - cross(w1, r1))
  // J = [-u -cross(r1, u) u cross(r2, u)]
  // K = J * invM * JT
  // = invMass1 + invI1 * cross(r1, u)^2 + invMass2 + invI2 * cross(r2, u)^2
};

DistanceJoint.prototype._serialize = function() {
  return {
    type: this.m_type,
    bodyA: this.m_bodyA,
    bodyB: this.m_bodyB,
    collideConnected: this.m_collideConnected,

    frequencyHz: this.m_frequencyHz,
    dampingRatio: this.m_dampingRatio,

    localAnchorA: this.m_localAnchorA,
    localAnchorB: this.m_localAnchorB,
    length: this.m_length,

    impulse: this.m_impulse,
    gamma: this.m_gamma,
    bias: this.m_bias,
  };
};

DistanceJoint._deserialize = function(data, world, restore) {
  data = Object.assign({}, data);
  data.bodyA = restore(Body, data.bodyA, world);
  data.bodyB = restore(Body, data.bodyB, world);
  var joint = new DistanceJoint(data);
  return joint;
};

/**
 * @internal
 */
DistanceJoint.prototype._setAnchors = function(def) {
  if (def.anchorA) {
    this.m_localAnchorA.set(this.m_bodyA.getLocalPoint(def.anchorA));
  } else if (def.localAnchorA) {
    this.m_localAnchorA.set(def.localAnchorA);
  }

  if (def.anchorB) {
    this.m_localAnchorB.set(this.m_bodyB.getLocalPoint(def.anchorB));
  } else if (def.localAnchorB) {
    this.m_localAnchorB.set(def.localAnchorB);
  }

  if (def.length > 0) {
    this.m_length = +def.length;
  } else if (def.length < 0) { // don't change length
  } else if (def.anchorA || def.anchorA || def.anchorA || def.anchorA) {
    this.m_length = Vec2.distance(
        this.m_bodyA.getWorldPoint(this.m_localAnchorA),
        this.m_bodyB.getWorldPoint(this.m_localAnchorB)
    );
  }
}

/**
 * The local anchor point relative to bodyA's origin.
 */
DistanceJoint.prototype.getLocalAnchorA = function() {
  return this.m_localAnchorA;
}

/**
 * The local anchor point relative to bodyB's origin.
 */
DistanceJoint.prototype.getLocalAnchorB = function() {
  return this.m_localAnchorB;
}

/**
 * Set/get the natural length. Manipulating the length can lead to non-physical
 * behavior when the frequency is zero.
 */
DistanceJoint.prototype.setLength = function(length) {
  this.m_length = length;
}

DistanceJoint.prototype.getLength = function() {
  return this.m_length;
}

DistanceJoint.prototype.setFrequency = function(hz) {
  this.m_frequencyHz = hz;
}

DistanceJoint.prototype.getFrequency = function() {
  return this.m_frequencyHz;
}

DistanceJoint.prototype.setDampingRatio = function(ratio) {
  this.m_dampingRatio = ratio;
}

DistanceJoint.prototype.getDampingRatio = function() {
  return this.m_dampingRatio;
}

DistanceJoint.prototype.getAnchorA = function() {
  return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
}

DistanceJoint.prototype.getAnchorB = function() {
  return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
}

DistanceJoint.prototype.getReactionForce = function(inv_dt) {
  return Vec2.mul(this.m_impulse, this.m_u).mul(inv_dt);
}

DistanceJoint.prototype.getReactionTorque = function(inv_dt) {
  return 0.0;
}

DistanceJoint.prototype.initVelocityConstraints = function(step) {
  this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
  this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
  this.m_invMassA = this.m_bodyA.m_invMass;
  this.m_invMassB = this.m_bodyB.m_invMass;
  this.m_invIA = this.m_bodyA.m_invI;
  this.m_invIB = this.m_bodyB.m_invI;

  var cA = this.m_bodyA.c_position.c;
  var aA = this.m_bodyA.c_position.a;
  var vA = this.m_bodyA.c_velocity.v;
  var wA = this.m_bodyA.c_velocity.w;

  var cB = this.m_bodyB.c_position.c;
  var aB = this.m_bodyB.c_position.a;
  var vB = this.m_bodyB.c_velocity.v;
  var wB = this.m_bodyB.c_velocity.w;

  var qA = Rot.neo(aA);
  var qB = Rot.neo(aB);

  this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
  this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
  this.m_u = Vec2.sub(Vec2.add(cB, this.m_rB), Vec2.add(cA, this.m_rA));

  // Handle singularity.
  var length = this.m_u.length();
  if (length > Settings.linearSlop) {
    this.m_u.mul(1.0 / length);
  } else {
    this.m_u.set(0.0, 0.0);
  }

  var crAu = Vec2.cross(this.m_rA, this.m_u);
  var crBu = Vec2.cross(this.m_rB, this.m_u);
  var invMass = this.m_invMassA + this.m_invIA * crAu * crAu + this.m_invMassB
      + this.m_invIB * crBu * crBu;

  // Compute the effective mass matrix.
  this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;

  if (this.m_frequencyHz > 0.0) {
    var C = length - this.m_length;

    // Frequency
    var omega = 2.0 * Math.PI * this.m_frequencyHz;

    // Damping coefficient
    var d = 2.0 * this.m_mass * this.m_dampingRatio * omega;

    // Spring stiffness
    var k = this.m_mass * omega * omega;

    // magic formulas
    var h = step.dt;
    this.m_gamma = h * (d + h * k);
    this.m_gamma = this.m_gamma != 0.0 ? 1.0 / this.m_gamma : 0.0;
    this.m_bias = C * h * k * this.m_gamma;

    invMass += this.m_gamma;
    this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;
  } else {
    this.m_gamma = 0.0;
    this.m_bias = 0.0;
  }

  if (step.warmStarting) {
    // Scale the impulse to support a variable time step.
    this.m_impulse *= step.dtRatio;

    var P = Vec2.mul(this.m_impulse, this.m_u);

    vA.subMul(this.m_invMassA, P);
    wA -= this.m_invIA * Vec2.cross(this.m_rA, P);

    vB.addMul(this.m_invMassB, P);
    wB += this.m_invIB * Vec2.cross(this.m_rB, P);

  } else {
    this.m_impulse = 0.0;
  }

  this.m_bodyA.c_velocity.v.set(vA);
  this.m_bodyA.c_velocity.w = wA;
  this.m_bodyB.c_velocity.v.set(vB);
  this.m_bodyB.c_velocity.w = wB;
}

DistanceJoint.prototype.solveVelocityConstraints = function(step) {
  var vA = this.m_bodyA.c_velocity.v;
  var wA = this.m_bodyA.c_velocity.w;
  var vB = this.m_bodyB.c_velocity.v;
  var wB = this.m_bodyB.c_velocity.w;

  // Cdot = dot(u, v + cross(w, r))
  var vpA = Vec2.add(vA, Vec2.cross(wA, this.m_rA));
  var vpB = Vec2.add(vB, Vec2.cross(wB, this.m_rB));
  var Cdot = Vec2.dot(this.m_u, vpB) - Vec2.dot(this.m_u, vpA);

  var impulse = -this.m_mass
      * (Cdot + this.m_bias + this.m_gamma * this.m_impulse);
  this.m_impulse += impulse;

  var P = Vec2.mul(impulse, this.m_u);
  vA.subMul(this.m_invMassA, P);
  wA -= this.m_invIA * Vec2.cross(this.m_rA, P);
  vB.addMul(this.m_invMassB, P);
  wB += this.m_invIB * Vec2.cross(this.m_rB, P);

  this.m_bodyA.c_velocity.v.set(vA);
  this.m_bodyA.c_velocity.w = wA;
  this.m_bodyB.c_velocity.v.set(vB);
  this.m_bodyB.c_velocity.w = wB;
}

DistanceJoint.prototype.solvePositionConstraints = function(step) {
  if (this.m_frequencyHz > 0.0) {
    // There is no position correction for soft distance constraints.
    return true;
  }

  var cA = this.m_bodyA.c_position.c;
  var aA = this.m_bodyA.c_position.a;
  var cB = this.m_bodyB.c_position.c;
  var aB = this.m_bodyB.c_position.a;

  var qA = Rot.neo(aA);
  var qB = Rot.neo(aB);

  var rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);
  var rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);
  var u = Vec2.sub(Vec2.add(cB, rB), Vec2.add(cA, rA));

  var length = u.normalize();
  var C = length - this.m_length;
  C = Math
      .clamp(C, -Settings.maxLinearCorrection, Settings.maxLinearCorrection);

  var impulse = -this.m_mass * C;
  var P = Vec2.mul(impulse, u);

  cA.subMul(this.m_invMassA, P);
  aA -= this.m_invIA * Vec2.cross(rA, P);
  cB.addMul(this.m_invMassB, P);
  aB += this.m_invIB * Vec2.cross(rB, P);

  this.m_bodyA.c_position.c.set(cA);
  this.m_bodyA.c_position.a = aA;
  this.m_bodyB.c_position.c.set(cB);
  this.m_bodyB.c_position.a = aB;

  return Math.abs(C) < Settings.linearSlop;
}


/***/ }),
/* 100 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

module.exports = FrictionJoint;

var common = __webpack_require__(61);
var options = __webpack_require__(60);
var create = __webpack_require__(64);
var Settings = __webpack_require__(66);

var Math = __webpack_require__(63);
var Vec2 = __webpack_require__(62);
var Vec3 = __webpack_require__(84);
var Mat22 = __webpack_require__(80);
var Mat33 = __webpack_require__(85);
var Rot = __webpack_require__(72);
var Sweep = __webpack_require__(73);
var Transform = __webpack_require__(74);
var Velocity = __webpack_require__(75);
var Position = __webpack_require__(76);

var Joint = __webpack_require__(86);
var Body = __webpack_require__(71);

FrictionJoint.TYPE = 'friction-joint';
Joint.TYPES[FrictionJoint.TYPE] = FrictionJoint;

FrictionJoint._super = Joint;
FrictionJoint.prototype = create(FrictionJoint._super.prototype);

/**
 * @typedef {Object} FrictionJointDef
 *
 * Friction joint definition.
 * 
 * @prop {float} maxForce The maximum friction force in N.
 * @prop {float} maxTorque The maximum friction torque in N-m.
 *
 * @prop {Vec2} localAnchorA The local anchor point relative to bodyA's origin.
 * @prop {Vec2} localAnchorB The local anchor point relative to bodyB's origin.
 */

var DEFAULTS = {
  maxForce : 0.0,
  maxTorque : 0.0,
};

/**
 * Friction joint. This is used for top-down friction. It provides 2D
 * translational friction and angular friction.
 *
 * @param {FrictionJointDef} def
 * @param {Body} bodyA
 * @param {Body} bodyB
 * @param {Vec2} anchor Anchor in global coordination.
 */
function FrictionJoint(def, bodyA, bodyB, anchor) {
  if (!(this instanceof FrictionJoint)) {
    return new FrictionJoint(def, bodyA, bodyB, anchor);
  }

  def = options(def, DEFAULTS);
  Joint.call(this, def, bodyA, bodyB);
  bodyA = this.m_bodyA;
  bodyB = this.m_bodyB;

  this.m_type = FrictionJoint.TYPE;

  this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());
  this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());

  // Solver shared
  this.m_linearImpulse = Vec2.zero();
  this.m_angularImpulse = 0.0;
  this.m_maxForce = def.maxForce;
  this.m_maxTorque = def.maxTorque;

  // Solver temp
  this.m_rA; // Vec2
  this.m_rB; // Vec2
  this.m_localCenterA; // Vec2
  this.m_localCenterB; // Vec2
  this.m_invMassA; // float
  this.m_invMassB; // float
  this.m_invIA; // float
  this.m_invIB; // float
  this.m_linearMass; // Mat22
  this.m_angularMass; // float

  // Point-to-point constraint
  // Cdot = v2 - v1
  // = v2 + cross(w2, r2) - v1 - cross(w1, r1)
  // J = [-I -r1_skew I r2_skew ]
  // Identity used:
  // w k % (rx i + ry j) = w * (-ry i + rx j)

  // Angle constraint
  // Cdot = w2 - w1
  // J = [0 0 -1 0 0 1]
  // K = invI1 + invI2
}

FrictionJoint.prototype._serialize = function() {
  return {
    type: this.m_type,
    bodyA: this.m_bodyA,
    bodyB: this.m_bodyB,
    collideConnected: this.m_collideConnected,

    maxForce: this.m_maxForce,
    maxTorque: this.m_maxTorque,

    localAnchorA: this.m_localAnchorA,
    localAnchorB: this.m_localAnchorB,
  };
};

FrictionJoint._deserialize = function(data, world, restore) {
  data = Object.assign({}, data);
  data.bodyA = restore(Body, data.bodyA, world);
  data.bodyB = restore(Body, data.bodyB, world);
  var joint = new FrictionJoint(data);
  return joint;
};

/**
 * @internal
 */
FrictionJoint.prototype._setAnchors = function(def) {
  if (def.anchorA) {
    this.m_localAnchorA.set(this.m_bodyA.getLocalPoint(def.anchorA));
  } else if (def.localAnchorA) {
    this.m_localAnchorA.set(def.localAnchorA);
  }

  if (def.anchorB) {
    this.m_localAnchorB.set(this.m_bodyB.getLocalPoint(def.anchorB));
  } else if (def.localAnchorB) {
    this.m_localAnchorB.set(def.localAnchorB);
  }
}


/**
 * The local anchor point relative to bodyA's origin.
 */
FrictionJoint.prototype.getLocalAnchorA = function() {
  return this.m_localAnchorA;
}

/**
 * The local anchor point relative to bodyB's origin.
 */
FrictionJoint.prototype.getLocalAnchorB = function() {
  return this.m_localAnchorB;
}

/**
 * Set the maximum friction force in N.
 */
FrictionJoint.prototype.setMaxForce = function(force) {
  _ASSERT && common.assert(Math.isFinite(force) && force >= 0.0);
  this.m_maxForce = force;
}

/**
 * Get the maximum friction force in N.
 */
FrictionJoint.prototype.getMaxForce = function() {
  return this.m_maxForce;
}

/**
 * Set the maximum friction torque in N*m.
 */
FrictionJoint.prototype.setMaxTorque = function(torque) {
  _ASSERT && common.assert(Math.isFinite(torque) && torque >= 0.0);
  this.m_maxTorque = torque;
}

/**
 * Get the maximum friction torque in N*m.
 */
FrictionJoint.prototype.getMaxTorque = function() {
  return this.m_maxTorque;
}

FrictionJoint.prototype.getAnchorA = function() {
  return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
}

FrictionJoint.prototype.getAnchorB = function() {
  return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
}

FrictionJoint.prototype.getReactionForce = function(inv_dt) {
  return Vec2.mul(inv_dt, this.m_linearImpulse);
}

FrictionJoint.prototype.getReactionTorque = function(inv_dt) {
  return inv_dt * this.m_angularImpulse;
}

FrictionJoint.prototype.initVelocityConstraints = function(step) {
  this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
  this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
  this.m_invMassA = this.m_bodyA.m_invMass;
  this.m_invMassB = this.m_bodyB.m_invMass;
  this.m_invIA = this.m_bodyA.m_invI;
  this.m_invIB = this.m_bodyB.m_invI;

  var aA = this.m_bodyA.c_position.a;
  var vA = this.m_bodyA.c_velocity.v;
  var wA = this.m_bodyA.c_velocity.w;

  var aB = this.m_bodyB.c_position.a;
  var vB = this.m_bodyB.c_velocity.v;
  var wB = this.m_bodyB.c_velocity.w;

  var qA = Rot.neo(aA), qB = Rot.neo(aB);

  // Compute the effective mass matrix.
  this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
  this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));

  // J = [-I -r1_skew I r2_skew]
  // [ 0 -1 0 1]
  // r_skew = [-ry; rx]

  // Matlab
  // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]
  // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]
  // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]

  var mA = this.m_invMassA, mB = this.m_invMassB; // float
  var iA = this.m_invIA, iB = this.m_invIB; // float

  var K = new Mat22()
  K.ex.x = mA + mB + iA * this.m_rA.y * this.m_rA.y + iB * this.m_rB.y
      * this.m_rB.y;
  K.ex.y = -iA * this.m_rA.x * this.m_rA.y - iB * this.m_rB.x * this.m_rB.y;
  K.ey.x = K.ex.y;
  K.ey.y = mA + mB + iA * this.m_rA.x * this.m_rA.x + iB * this.m_rB.x
      * this.m_rB.x;

  this.m_linearMass = K.getInverse();

  this.m_angularMass = iA + iB;
  if (this.m_angularMass > 0.0) {
    this.m_angularMass = 1.0 / this.m_angularMass;
  }

  if (step.warmStarting) {
    // Scale impulses to support a variable time step.
    this.m_linearImpulse.mul(step.dtRatio);
    this.m_angularImpulse *= step.dtRatio;

    var P = Vec2.neo(this.m_linearImpulse.x, this.m_linearImpulse.y);

    vA.subMul(mA, P);
    wA -= iA * (Vec2.cross(this.m_rA, P) + this.m_angularImpulse);

    vB.addMul(mB, P);
    wB += iB * (Vec2.cross(this.m_rB, P) + this.m_angularImpulse);

  } else {
    this.m_linearImpulse.setZero();
    this.m_angularImpulse = 0.0;
  }

  this.m_bodyA.c_velocity.v = vA;
  this.m_bodyA.c_velocity.w = wA;
  this.m_bodyB.c_velocity.v = vB;
  this.m_bodyB.c_velocity.w = wB;
}

FrictionJoint.prototype.solveVelocityConstraints = function(step) {
  var vA = this.m_bodyA.c_velocity.v;
  var wA = this.m_bodyA.c_velocity.w;
  var vB = this.m_bodyB.c_velocity.v;
  var wB = this.m_bodyB.c_velocity.w;

  var mA = this.m_invMassA, mB = this.m_invMassB; // float
  var iA = this.m_invIA, iB = this.m_invIB; // float

  var h = step.dt; // float

  // Solve angular friction
  {
    var Cdot = wB - wA; // float
    var impulse = -this.m_angularMass * Cdot; // float

    var oldImpulse = this.m_angularImpulse; // float
    var maxImpulse = h * this.m_maxTorque; // float
    this.m_angularImpulse = Math.clamp(this.m_angularImpulse + impulse,
        -maxImpulse, maxImpulse);
    impulse = this.m_angularImpulse - oldImpulse;

    wA -= iA * impulse;
    wB += iB * impulse;
  }

  // Solve linear friction
  {
    var Cdot = Vec2.sub(Vec2.add(vB, Vec2.cross(wB, this.m_rB)), Vec2.add(vA,
        Vec2.cross(wA, this.m_rA))); // Vec2

    var impulse = Vec2.neg(Mat22.mulVec2(this.m_linearMass, Cdot)); // Vec2
    var oldImpulse = this.m_linearImpulse; // Vec2
    this.m_linearImpulse.add(impulse);

    var maxImpulse = h * this.m_maxForce; // float

    if (this.m_linearImpulse.lengthSquared() > maxImpulse * maxImpulse) {
      this.m_linearImpulse.normalize();
      this.m_linearImpulse.mul(maxImpulse);
    }

    impulse = Vec2.sub(this.m_linearImpulse, oldImpulse);

    vA.subMul(mA, impulse);
    wA -= iA * Vec2.cross(this.m_rA, impulse);

    vB.addMul(mB, impulse);
    wB += iB * Vec2.cross(this.m_rB, impulse);
  }

  this.m_bodyA.c_velocity.v = vA;
  this.m_bodyA.c_velocity.w = wA;
  this.m_bodyB.c_velocity.v = vB;
  this.m_bodyB.c_velocity.w = wB;
}

FrictionJoint.prototype.solvePositionConstraints = function(step) {
  return true;
}


/***/ }),
/* 101 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

module.exports = GearJoint;

var common = __webpack_require__(61);
var options = __webpack_require__(60);
var create = __webpack_require__(64);
var Settings = __webpack_require__(66);

var Math = __webpack_require__(63);
var Vec2 = __webpack_require__(62);
var Vec3 = __webpack_require__(84);
var Mat22 = __webpack_require__(80);
var Mat33 = __webpack_require__(85);
var Rot = __webpack_require__(72);
var Sweep = __webpack_require__(73);
var Transform = __webpack_require__(74);
var Velocity = __webpack_require__(75);
var Position = __webpack_require__(76);

var Joint = __webpack_require__(86);
var Body = __webpack_require__(71);

var RevoluteJoint = __webpack_require__(102);
var PrismaticJoint = __webpack_require__(103);

GearJoint.TYPE = 'gear-joint';
Joint.TYPES[GearJoint.TYPE] = GearJoint;

GearJoint._super = Joint;
GearJoint.prototype = create(GearJoint._super.prototype);

/**
 * @typedef {Object} GearJointDef
 *
 * Gear joint definition.
 *
 * @prop {float} ratio The gear ratio. See GearJoint for explanation.
 *
 * @prop {RevoluteJoint|PrismaticJoint} joint1 The first revolute/prismatic
 *          joint attached to the gear joint.
 * @prop {PrismaticJoint|RevoluteJoint} joint2 The second prismatic/revolute
 *          joint attached to the gear joint.
 */

var DEFAULTS = {
  ratio : 1.0
};

/**
 * A gear joint is used to connect two joints together. Either joint can be a
 * revolute or prismatic joint. You specify a gear ratio to bind the motions
 * together: coordinate1 + ratio * coordinate2 = constant
 * 
 * The ratio can be negative or positive. If one joint is a revolute joint and
 * the other joint is a prismatic joint, then the ratio will have units of
 * length or units of 1/length. Warning: You have to manually destroy the gear
 * joint if joint1 or joint2 is destroyed.
 * 
 * This definition requires two existing revolute or prismatic joints (any
 * combination will work).
 *
 * @param {GearJointDef} def
 * @param {Body} bodyA
 * @param {Body} bodyB
 */
function GearJoint(def, bodyA, bodyB, joint1, joint2, ratio) {
  if (!(this instanceof GearJoint)) {
    return new GearJoint(def, bodyA, bodyB, joint1, joint2, ratio);
  }

  def = options(def, DEFAULTS);
  Joint.call(this, def, bodyA, bodyB);
  bodyA = this.m_bodyA;
  bodyB = this.m_bodyB;

  this.m_type = GearJoint.TYPE;

  _ASSERT && common.assert(joint1.m_type === RevoluteJoint.TYPE
      || joint1.m_type === PrismaticJoint.TYPE);
  _ASSERT && common.assert(joint2.m_type === RevoluteJoint.TYPE
      || joint2.m_type === PrismaticJoint.TYPE);

  this.m_joint1 = joint1 ? joint1 : def.joint1;
  this.m_joint2 = joint2 ? joint2 : def.joint2;
  this.m_ratio = Math.isFinite(ratio) ? ratio : def.ratio;

  this.m_type1 = this.m_joint1.getType();
  this.m_type2 = this.m_joint2.getType();

  // joint1 connects body A to body C
  // joint2 connects body B to body D

  var coordinateA, coordinateB; // float

  // TODO_ERIN there might be some problem with the joint edges in Joint.

  this.m_bodyC = this.m_joint1.getBodyA();
  this.m_bodyA = this.m_joint1.getBodyB();

  // Get geometry of joint1
  var xfA = this.m_bodyA.m_xf;
  var aA = this.m_bodyA.m_sweep.a;
  var xfC = this.m_bodyC.m_xf;
  var aC = this.m_bodyC.m_sweep.a;

  if (this.m_type1 === RevoluteJoint.TYPE) {
    var revolute = this.m_joint1;// RevoluteJoint
    this.m_localAnchorC = revolute.m_localAnchorA;
    this.m_localAnchorA = revolute.m_localAnchorB;
    this.m_referenceAngleA = revolute.m_referenceAngle;
    this.m_localAxisC = Vec2.zero();

    coordinateA = aA - aC - this.m_referenceAngleA;
  } else {
    var prismatic = this.m_joint1; // PrismaticJoint
    this.m_localAnchorC = prismatic.m_localAnchorA;
    this.m_localAnchorA = prismatic.m_localAnchorB;
    this.m_referenceAngleA = prismatic.m_referenceAngle;
    this.m_localAxisC = prismatic.m_localXAxisA;

    var pC = this.m_localAnchorC;
    var pA = Rot.mulTVec2(xfC.q, Vec2.add(Rot.mul(xfA.q, this.m_localAnchorA), Vec2.sub(xfA.p, xfC.p)));
    coordinateA = Vec2.dot(pA, this.m_localAxisC) - Vec2.dot(pC, this.m_localAxisC);
  }

  this.m_bodyD = this.m_joint2.getBodyA();
  this.m_bodyB = this.m_joint2.getBodyB();

  // Get geometry of joint2
  var xfB = this.m_bodyB.m_xf;
  var aB = this.m_bodyB.m_sweep.a;
  var xfD = this.m_bodyD.m_xf;
  var aD = this.m_bodyD.m_sweep.a;

  if (this.m_type2 === RevoluteJoint.TYPE) {
    var revolute = this.m_joint2; // RevoluteJoint
    this.m_localAnchorD = revolute.m_localAnchorA;
    this.m_localAnchorB = revolute.m_localAnchorB;
    this.m_referenceAngleB = revolute.m_referenceAngle;
    this.m_localAxisD = Vec2.zero();

    coordinateB = aB - aD - this.m_referenceAngleB;
  } else {
    var prismatic = this.m_joint2; // PrismaticJoint
    this.m_localAnchorD = prismatic.m_localAnchorA;
    this.m_localAnchorB = prismatic.m_localAnchorB;
    this.m_referenceAngleB = prismatic.m_referenceAngle;
    this.m_localAxisD = prismatic.m_localXAxisA;

    var pD = this.m_localAnchorD;
    var pB = Rot.mulTVec2(xfD.q, Vec2.add(Rot.mul(xfB.q, this.m_localAnchorB), Vec2.sub(xfB.p, xfD.p)));
    coordinateB = Vec2.dot(pB, this.m_localAxisD) - Vec2.dot(pD, this.m_localAxisD);
  }

  this.m_constant = coordinateA + this.m_ratio * coordinateB;

  this.m_impulse = 0.0;

  // Solver temp
  this.m_lcA, this.m_lcB, this.m_lcC, this.m_lcD; // Vec2
  this.m_mA, this.m_mB, this.m_mC, this.m_mD; // float
  this.m_iA, this.m_iB, this.m_iC, this.m_iD; // float
  this.m_JvAC, this.m_JvBD; // Vec2
  this.m_JwA, this.m_JwB, this.m_JwC, this.m_JwD; // float
  this.m_mass; // float

  // Gear Joint:
  // C0 = (coordinate1 + ratio * coordinate2)_initial
  // C = (coordinate1 + ratio * coordinate2) - C0 = 0
  // J = [J1 ratio * J2]
  // K = J * invM * JT
  // = J1 * invM1 * J1T + ratio * ratio * J2 * invM2 * J2T
  //
  // Revolute:
  // coordinate = rotation
  // Cdot = angularVelocity
  // J = [0 0 1]
  // K = J * invM * JT = invI
  //
  // Prismatic:
  // coordinate = dot(p - pg, ug)
  // Cdot = dot(v + cross(w, r), ug)
  // J = [ug cross(r, ug)]
  // K = J * invM * JT = invMass + invI * cross(r, ug)^2
};

GearJoint.prototype._serialize = function() {
  return {
    type: this.m_type,
    bodyA: this.m_bodyA,
    bodyB: this.m_bodyB,
    collideConnected: this.m_collideConnected,

    joint1: this.m_joint1,
    joint2: this.m_joint2,
    ratio: this.m_ratio,

    // _constant: this.m_constant,
  };
};

GearJoint._deserialize = function(data, world, restore) {
  data = Object.assign({}, data);
  data.bodyA = restore(Body, data.bodyA, world);
  data.bodyB = restore(Body, data.bodyB, world);
  data.joint1 = restore(Joint, data.joint1, world);
  data.joint2 = restore(Joint, data.joint2, world);
  var joint = new GearJoint(data);
  // if (data._constant) joint.m_constant = data._constant;
  return joint;
};

/**
 * Get the first joint.
 */
GearJoint.prototype.getJoint1 = function() {
  return this.m_joint1;
}

/**
 * Get the second joint.
 */
GearJoint.prototype.getJoint2 = function() {
  return this.m_joint2;
}

/**
 * Set/Get the gear ratio.
 */
GearJoint.prototype.setRatio = function(ratio) {
  _ASSERT && common.assert(Math.isFinite(ratio));
  this.m_ratio = ratio;
}

GearJoint.prototype.getRatio = function() {
  return this.m_ratio;
}

GearJoint.prototype.getAnchorA = function() {
  return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
}

GearJoint.prototype.getAnchorB = function() {
  return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
}

GearJoint.prototype.getReactionForce = function(inv_dt) {
  return Vec2.mul(this.m_impulse, this.m_JvAC).mul(inv_dt);
}

GearJoint.prototype.getReactionTorque = function(inv_dt) {
  var L = this.m_impulse * this.m_JwA; // float
  return inv_dt * L;
}

GearJoint.prototype.initVelocityConstraints = function(step) {
  this.m_lcA = this.m_bodyA.m_sweep.localCenter;
  this.m_lcB = this.m_bodyB.m_sweep.localCenter;
  this.m_lcC = this.m_bodyC.m_sweep.localCenter;
  this.m_lcD = this.m_bodyD.m_sweep.localCenter;
  this.m_mA = this.m_bodyA.m_invMass;
  this.m_mB = this.m_bodyB.m_invMass;
  this.m_mC = this.m_bodyC.m_invMass;
  this.m_mD = this.m_bodyD.m_invMass;
  this.m_iA = this.m_bodyA.m_invI;
  this.m_iB = this.m_bodyB.m_invI;
  this.m_iC = this.m_bodyC.m_invI;
  this.m_iD = this.m_bodyD.m_invI;

  var aA = this.m_bodyA.c_position.a;
  var vA = this.m_bodyA.c_velocity.v;
  var wA = this.m_bodyA.c_velocity.w;

  var aB = this.m_bodyB.c_position.a;
  var vB = this.m_bodyB.c_velocity.v;
  var wB = this.m_bodyB.c_velocity.w;

  var aC = this.m_bodyC.c_position.a;
  var vC = this.m_bodyC.c_velocity.v;
  var wC = this.m_bodyC.c_velocity.w;

  var aD = this.m_bodyD.c_position.a;
  var vD = this.m_bodyD.c_velocity.v;
  var wD = this.m_bodyD.c_velocity.w;

  var qA = Rot.neo(aA);
  var qB = Rot.neo(aB);
  var qC = Rot.neo(aC);
  var qD = Rot.neo(aD);

  this.m_mass = 0.0;

  if (this.m_type1 == RevoluteJoint.TYPE) {
    this.m_JvAC = Vec2.zero();
    this.m_JwA = 1.0;
    this.m_JwC = 1.0;
    this.m_mass += this.m_iA + this.m_iC;
  } else {
    var u = Rot.mulVec2(qC, this.m_localAxisC); // Vec2
    var rC = Rot.mulSub(qC, this.m_localAnchorC, this.m_lcC); // Vec2
    var rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_lcA); // Vec2
    this.m_JvAC = u;
    this.m_JwC = Vec2.cross(rC, u);
    this.m_JwA = Vec2.cross(rA, u);
    this.m_mass += this.m_mC + this.m_mA + this.m_iC * this.m_JwC * this.m_JwC + this.m_iA * this.m_JwA * this.m_JwA;
  }

  if (this.m_type2 == RevoluteJoint.TYPE) {
    this.m_JvBD = Vec2.zero();
    this.m_JwB = this.m_ratio;
    this.m_JwD = this.m_ratio;
    this.m_mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);
  } else {
    var u = Rot.mulVec2(qD, this.m_localAxisD); // Vec2
    var rD = Rot.mulSub(qD, this.m_localAnchorD, this.m_lcD); // Vec2
    var rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_lcB); // Vec2
    this.m_JvBD = Vec2.mul(this.m_ratio, u);
    this.m_JwD = this.m_ratio * Vec2.cross(rD, u);
    this.m_JwB = this.m_ratio * Vec2.cross(rB, u);
    this.m_mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * this.m_JwD * this.m_JwD + this.m_iB * this.m_JwB * this.m_JwB;
  }

  // Compute effective mass.
  this.m_mass = this.m_mass > 0.0 ? 1.0 / this.m_mass : 0.0;

  if (step.warmStarting) {
    vA.addMul(this.m_mA * this.m_impulse, this.m_JvAC);
    wA += this.m_iA * this.m_impulse * this.m_JwA;
    
    vB.addMul(this.m_mB * this.m_impulse, this.m_JvBD);
    wB += this.m_iB * this.m_impulse * this.m_JwB;
    
    vC.subMul(this.m_mC * this.m_impulse, this.m_JvAC);
    wC -= this.m_iC * this.m_impulse * this.m_JwC;
  
    vD.subMul(this.m_mD * this.m_impulse, this.m_JvBD);
    wD -= this.m_iD * this.m_impulse * this.m_JwD;

  } else {
    this.m_impulse = 0.0;
  }

  this.m_bodyA.c_velocity.v.set(vA);
  this.m_bodyA.c_velocity.w = wA;
  this.m_bodyB.c_velocity.v.set(vB);
  this.m_bodyB.c_velocity.w = wB;
  this.m_bodyC.c_velocity.v.set(vC);
  this.m_bodyC.c_velocity.w = wC;
  this.m_bodyD.c_velocity.v.set(vD);
  this.m_bodyD.c_velocity.w = wD;
}

GearJoint.prototype.solveVelocityConstraints = function(step) {
  var vA = this.m_bodyA.c_velocity.v;
  var wA = this.m_bodyA.c_velocity.w;
  var vB = this.m_bodyB.c_velocity.v;
  var wB = this.m_bodyB.c_velocity.w;
  var vC = this.m_bodyC.c_velocity.v;
  var wC = this.m_bodyC.c_velocity.w;
  var vD = this.m_bodyD.c_velocity.v;
  var wD = this.m_bodyD.c_velocity.w;

  var Cdot = Vec2.dot(this.m_JvAC, vA) - Vec2.dot(this.m_JvAC, vC)
      + Vec2.dot(this.m_JvBD, vB) - Vec2.dot(this.m_JvBD, vD); // float
  Cdot += (this.m_JwA * wA - this.m_JwC * wC)
      + (this.m_JwB * wB - this.m_JwD * wD);

  var impulse = -this.m_mass * Cdot; // float
  this.m_impulse += impulse;

  vA.addMul(this.m_mA * impulse, this.m_JvAC);
  wA += this.m_iA * impulse * this.m_JwA;
  vB.addMul(this.m_mB * impulse, this.m_JvBD);
  wB += this.m_iB * impulse * this.m_JwB;
  vC.subMul(this.m_mC * impulse, this.m_JvAC);
  wC -= this.m_iC * impulse * this.m_JwC;
  vD.subMul(this.m_mD * impulse, this.m_JvBD);
  wD -= this.m_iD * impulse * this.m_JwD;

  this.m_bodyA.c_velocity.v.set(vA);
  this.m_bodyA.c_velocity.w = wA;
  this.m_bodyB.c_velocity.v.set(vB);
  this.m_bodyB.c_velocity.w = wB;
  this.m_bodyC.c_velocity.v.set(vC);
  this.m_bodyC.c_velocity.w = wC;
  this.m_bodyD.c_velocity.v.set(vD);
  this.m_bodyD.c_velocity.w = wD;
}

GearJoint.prototype.solvePositionConstraints = function(step) {
  var cA = this.m_bodyA.c_position.c;
  var aA = this.m_bodyA.c_position.a;
  var cB = this.m_bodyB.c_position.c;
  var aB = this.m_bodyB.c_position.a;
  var cC = this.m_bodyC.c_position.c;
  var aC = this.m_bodyC.c_position.a;
  var cD = this.m_bodyD.c_position.c;
  var aD = this.m_bodyD.c_position.a;

  var qA = Rot.neo(aA);
  var qB = Rot.neo(aB);
  var qC = Rot.neo(aC);
  var qD = Rot.neo(aD);

  var linearError = 0.0; // float

  var coordinateA, coordinateB; // float

  var JvAC, JvBD; // Vec2
  var JwA, JwB, JwC, JwD; // float
  var mass = 0.0; // float

  if (this.m_type1 == RevoluteJoint.TYPE) {
    JvAC = Vec2.zero();
    JwA = 1.0;
    JwC = 1.0;
    mass += this.m_iA + this.m_iC;

    coordinateA = aA - aC - this.m_referenceAngleA;
  } else {
    var u = Rot.mulVec2(qC, this.m_localAxisC); // Vec2
    var rC = Rot.mulSub(qC, this.m_localAnchorC, this.m_lcC); // Vec2
    var rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_lcA); // Vec2
    JvAC = u;
    JwC = Vec2.cross(rC, u);
    JwA = Vec2.cross(rA, u);
    mass += this.m_mC + this.m_mA + this.m_iC * JwC * JwC + this.m_iA * JwA * JwA;

    var pC = Vec2.sub(this.m_localAnchorC, this.m_lcC); // Vec2
    var pA = Rot.mulTVec2(qC, Vec2.add(rA, Vec2.sub(cA, cC))); // Vec2
    coordinateA = Vec2.dot(Vec2.sub(pA, pC), this.m_localAxisC);
  }

  if (this.m_type2 == RevoluteJoint.TYPE) {
    JvBD = Vec2.zero();
    JwB = this.m_ratio;
    JwD = this.m_ratio;
    mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);

    coordinateB = aB - aD - this.m_referenceAngleB;
  } else {
    var u = Rot.mulVec2(qD, this.m_localAxisD);
    var rD = Rot.mulSub(qD, this.m_localAnchorD, this.m_lcD);
    var rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_lcB);
    JvBD = Vec2.mul(this.m_ratio, u);
    JwD = this.m_ratio * Vec2.cross(rD, u);
    JwB = this.m_ratio * Vec2.cross(rB, u);
    mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD
        * JwD * JwD + this.m_iB * JwB * JwB;

    var pD = Vec2.sub(this.m_localAnchorD, this.m_lcD); // Vec2
    var pB = Rot.mulTVec2(qD, Vec2.add(rB, Vec2.sub(cB, cD))); // Vec2
    coordinateB = Vec2.dot(pB, this.m_localAxisD)
        - Vec2.dot(pD, this.m_localAxisD);
  }

  var C = (coordinateA + this.m_ratio * coordinateB) - this.m_constant; // float

  var impulse = 0.0; // float
  if (mass > 0.0) {
    impulse = -C / mass;
  }

  cA.addMul(this.m_mA * impulse, JvAC);
  aA += this.m_iA * impulse * JwA;
  cB.addMul(this.m_mB * impulse, JvBD);
  aB += this.m_iB * impulse * JwB;
  cC.subMul(this.m_mC * impulse, JvAC);
  aC -= this.m_iC * impulse * JwC;
  cD.subMul(this.m_mD * impulse, JvBD);
  aD -= this.m_iD * impulse * JwD;

  this.m_bodyA.c_position.c.set(cA);
  this.m_bodyA.c_position.a = aA;
  this.m_bodyB.c_position.c.set(cB);
  this.m_bodyB.c_position.a = aB;
  this.m_bodyC.c_position.c.set(cC);
  this.m_bodyC.c_position.a = aC;
  this.m_bodyD.c_position.c.set(cD);
  this.m_bodyD.c_position.a = aD;

  // TODO_ERIN not implemented
  return linearError < Settings.linearSlop;
}


/***/ }),
/* 102 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

module.exports = RevoluteJoint;

var common = __webpack_require__(61);
var options = __webpack_require__(60);
var create = __webpack_require__(64);
var Settings = __webpack_require__(66);

var Math = __webpack_require__(63);
var Vec2 = __webpack_require__(62);
var Vec3 = __webpack_require__(84);
var Mat22 = __webpack_require__(80);
var Mat33 = __webpack_require__(85);
var Rot = __webpack_require__(72);
var Sweep = __webpack_require__(73);
var Transform = __webpack_require__(74);
var Velocity = __webpack_require__(75);
var Position = __webpack_require__(76);

var Joint = __webpack_require__(86);
var Body = __webpack_require__(71);

var inactiveLimit = 0;
var atLowerLimit = 1;
var atUpperLimit = 2;
var equalLimits = 3;

RevoluteJoint.TYPE = 'revolute-joint';
Joint.TYPES[RevoluteJoint.TYPE] = RevoluteJoint;

RevoluteJoint._super = Joint;
RevoluteJoint.prototype = create(RevoluteJoint._super.prototype);

/**
 * @typedef {Object} RevoluteJointDef
 *
 * Revolute joint definition. This requires defining an anchor point where the
 * bodies are joined. The definition uses local anchor points so that the
 * initial configuration can violate the constraint slightly. You also need to
 * specify the initial relative angle for joint limits. This helps when saving
 * and loading a game.
 *
 * The local anchor points are measured from the body's origin rather than the
 * center of mass because: 1. you might not know where the center of mass will
 * be. 2. if you add/remove shapes from a body and recompute the mass, the
 * joints will be broken.
 *
 * @prop {bool} enableLimit A flag to enable joint limits.
 * @prop {bool} enableMotor A flag to enable the joint motor.
 * @prop {float} lowerAngle The lower angle for the joint limit (radians).
 * @prop {float} upperAngle The upper angle for the joint limit (radians).
 * @prop {float} motorSpeed The desired motor speed. Usually in radians per
 *       second.
 * @prop {float} maxMotorTorque The maximum motor torque used to achieve the
 *       desired motor speed. Usually in N-m.
 *
 * @prop {Vec2} localAnchorA The local anchor point relative to bodyA's origin.
 * @prop {Vec2} localAnchorB The local anchor point relative to bodyB's origin.
 * @prop {float} referenceAngle The bodyB angle minus bodyA angle in the
 *       reference state (radians).
 */

var DEFAULTS = {
  lowerAngle : 0.0,
  upperAngle : 0.0,
  maxMotorTorque : 0.0,
  motorSpeed : 0.0,
  enableLimit : false,
  enableMotor : false
};

/**
 * A revolute joint constrains two bodies to share a common point while they are
 * free to rotate about the point. The relative rotation about the shared point
 * is the joint angle. You can limit the relative rotation with a joint limit
 * that specifies a lower and upper angle. You can use a motor to drive the
 * relative rotation about the shared point. A maximum motor torque is provided
 * so that infinite forces are not generated.
 *
 * @param {RevoluteJointDef} def
 * @param {Body} bodyA
 * @param {Body} bodyB
 */
function RevoluteJoint(def, bodyA, bodyB, anchor) {
  if (!(this instanceof RevoluteJoint)) {
    return new RevoluteJoint(def, bodyA, bodyB, anchor);
  }

  def = options(def, DEFAULTS);
  Joint.call(this, def, bodyA, bodyB);
  bodyA = this.m_bodyA;
  bodyB = this.m_bodyB;

  this.m_type = RevoluteJoint.TYPE;

  this.m_localAnchorA =  Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());
  this.m_localAnchorB =  Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());
  this.m_referenceAngle = Math.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();

  this.m_impulse = Vec3();
  this.m_motorImpulse = 0.0;

  this.m_lowerAngle = def.lowerAngle;
  this.m_upperAngle = def.upperAngle;
  this.m_maxMotorTorque = def.maxMotorTorque;
  this.m_motorSpeed = def.motorSpeed;
  this.m_enableLimit = def.enableLimit;
  this.m_enableMotor = def.enableMotor;

  // Solver temp
  this.m_rA; // Vec2
  this.m_rB; // Vec2
  this.m_localCenterA; // Vec2
  this.m_localCenterB; // Vec2
  this.m_invMassA; // float
  this.m_invMassB; // float
  this.m_invIA; // float
  this.m_invIB; // float
  // effective mass for point-to-point constraint.
  this.m_mass = new Mat33();
  // effective mass for motor/limit angular constraint.
  this.m_motorMass; // float
  this.m_limitState = inactiveLimit;

  // Point-to-point constraint
  // C = p2 - p1
  // Cdot = v2 - v1
  // = v2 + cross(w2, r2) - v1 - cross(w1, r1)
  // J = [-I -r1_skew I r2_skew ]
  // Identity used:
  // w k % (rx i + ry j) = w * (-ry i + rx j)

  // Motor constraint
  // Cdot = w2 - w1
  // J = [0 0 -1 0 0 1]
  // K = invI1 + invI2
}

RevoluteJoint.prototype._serialize = function() {
  return {
    type: this.m_type,
    bodyA: this.m_bodyA,
    bodyB: this.m_bodyB,
    collideConnected: this.m_collideConnected,

    lowerAngle: this.m_lowerAngle,
    upperAngle: this.m_upperAngle,
    maxMotorTorque: this.m_maxMotorTorque,
    motorSpeed: this.m_motorSpeed,
    enableLimit: this.m_enableLimit,
    enableMotor: this.m_enableMotor,

    localAnchorA: this.m_localAnchorA,
    localAnchorB: this.m_localAnchorB,
    referenceAngle: this.m_referenceAngle,
  };
};

RevoluteJoint._deserialize = function(data, world, restore) {
  data = Object.assign({}, data);
  data.bodyA = restore(Body, data.bodyA, world);
  data.bodyB = restore(Body, data.bodyB, world);
  var joint = new RevoluteJoint(data);
  return joint;
};

/**
 * @internal
 */
RevoluteJoint.prototype._setAnchors = function(def) {
  if (def.anchorA) {
    this.m_localAnchorA.set(this.m_bodyA.getLocalPoint(def.anchorA));
  } else if (def.localAnchorA) {
    this.m_localAnchorA.set(def.localAnchorA);
  }

  if (def.anchorB) {
    this.m_localAnchorB.set(this.m_bodyB.getLocalPoint(def.anchorB));
  } else if (def.localAnchorB) {
    this.m_localAnchorB.set(def.localAnchorB);
  }
}

/**
 * The local anchor point relative to bodyA's origin.
 */
RevoluteJoint.prototype.getLocalAnchorA = function() {
  return this.m_localAnchorA;
}

/**
 * The local anchor point relative to bodyB's origin.
 */
RevoluteJoint.prototype.getLocalAnchorB = function() {
  return this.m_localAnchorB;
}

/**
 * Get the reference angle.
 */
RevoluteJoint.prototype.getReferenceAngle = function() {
  return this.m_referenceAngle;
}

/**
 * Get the current joint angle in radians.
 */
RevoluteJoint.prototype.getJointAngle = function() {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  return bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;
}

/**
 * Get the current joint angle speed in radians per second.
 */
RevoluteJoint.prototype.getJointSpeed = function() {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;
  return bB.m_angularVelocity - bA.m_angularVelocity;
}

/**
 * Is the joint motor enabled?
 */
RevoluteJoint.prototype.isMotorEnabled = function() {
  return this.m_enableMotor;
}

/**
 * Enable/disable the joint motor.
 */
RevoluteJoint.prototype.enableMotor = function(flag) {
  this.m_bodyA.setAwake(true);
  this.m_bodyB.setAwake(true);
  this.m_enableMotor = flag;
}

/**
 * Get the current motor torque given the inverse time step. Unit is N*m.
 */
RevoluteJoint.prototype.getMotorTorque = function(inv_dt) {
  return inv_dt * this.m_motorImpulse;
}

/**
 * Set the motor speed in radians per second.
 */
RevoluteJoint.prototype.setMotorSpeed = function(speed) {
  this.m_bodyA.setAwake(true);
  this.m_bodyB.setAwake(true);
  this.m_motorSpeed = speed;
}

/**
 * Get the motor speed in radians per second.
 */
RevoluteJoint.prototype.getMotorSpeed = function() {
  return this.m_motorSpeed;
}

/**
 * Set the maximum motor torque, usually in N-m.
 */
RevoluteJoint.prototype.setMaxMotorTorque = function(torque) {
  this.m_bodyA.setAwake(true);
  this.m_bodyB.setAwake(true);
  this.m_maxMotorTorque = torque;
}

RevoluteJoint.prototype.getMaxMotorTorque = function() {
  return this.m_maxMotorTorque;
}

/**
 * Is the joint limit enabled?
 */
RevoluteJoint.prototype.isLimitEnabled = function() {
  return this.m_enableLimit;
}

/**
 * Enable/disable the joint limit.
 */
RevoluteJoint.prototype.enableLimit = function(flag) {
  if (flag != this.m_enableLimit) {
    this.m_bodyA.setAwake(true);
    this.m_bodyB.setAwake(true);
    this.m_enableLimit = flag;
    this.m_impulse.z = 0.0;
  }
}

/**
 * Get the lower joint limit in radians.
 */
RevoluteJoint.prototype.getLowerLimit = function() {
  return this.m_lowerAngle;
}

/**
 * Get the upper joint limit in radians.
 */
RevoluteJoint.prototype.getUpperLimit = function() {
  return this.m_upperAngle;
}

/**
 * Set the joint limits in radians.
 */
RevoluteJoint.prototype.setLimits = function(lower, upper) {
  _ASSERT && common.assert(lower <= upper);

  if (lower != this.m_lowerAngle || upper != this.m_upperAngle) {
    this.m_bodyA.setAwake(true);
    this.m_bodyB.setAwake(true);
    this.m_impulse.z = 0.0;
    this.m_lowerAngle = lower;
    this.m_upperAngle = upper;
  }
}

RevoluteJoint.prototype.getAnchorA = function() {
  return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
}

RevoluteJoint.prototype.getAnchorB = function() {
  return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
}

/**
 * Get the reaction force given the inverse time step. Unit is N.
 */
RevoluteJoint.prototype.getReactionForce = function(inv_dt) {
  return Vec2.neo(this.m_impulse.x, this.m_impulse.y).mul(inv_dt);
}

/**
 * Get the reaction torque due to the joint limit given the inverse time step.
 * Unit is N*m.
 */
RevoluteJoint.prototype.getReactionTorque = function(inv_dt) {
  return inv_dt * this.m_impulse.z;
}

RevoluteJoint.prototype.initVelocityConstraints = function(step) {
  this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
  this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
  this.m_invMassA = this.m_bodyA.m_invMass;
  this.m_invMassB = this.m_bodyB.m_invMass;
  this.m_invIA = this.m_bodyA.m_invI;
  this.m_invIB = this.m_bodyB.m_invI;

  var aA = this.m_bodyA.c_position.a;
  var vA = this.m_bodyA.c_velocity.v;
  var wA = this.m_bodyA.c_velocity.w;

  var aB = this.m_bodyB.c_position.a;
  var vB = this.m_bodyB.c_velocity.v;
  var wB = this.m_bodyB.c_velocity.w;

  var qA = Rot.neo(aA);
  var qB = Rot.neo(aB);

  this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
  this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));

  // J = [-I -r1_skew I r2_skew]
  // [ 0 -1 0 1]
  // r_skew = [-ry; rx]

  // Matlab
  // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]
  // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]
  // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]

  var mA = this.m_invMassA;
  var mB = this.m_invMassB; // float
  var iA = this.m_invIA;
  var iB = this.m_invIB; // float

  var fixedRotation = (iA + iB === 0.0); // bool

  this.m_mass.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y
      * this.m_rB.y * iB;
  this.m_mass.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y
      * this.m_rB.x * iB;
  this.m_mass.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;
  this.m_mass.ex.y = this.m_mass.ey.x;
  this.m_mass.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x
      * this.m_rB.x * iB;
  this.m_mass.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;
  this.m_mass.ex.z = this.m_mass.ez.x;
  this.m_mass.ey.z = this.m_mass.ez.y;
  this.m_mass.ez.z = iA + iB;

  this.m_motorMass = iA + iB;
  if (this.m_motorMass > 0.0) {
    this.m_motorMass = 1.0 / this.m_motorMass;
  }

  if (this.m_enableMotor == false || fixedRotation) {
    this.m_motorImpulse = 0.0;
  }

  if (this.m_enableLimit && fixedRotation == false) {
    var jointAngle = aB - aA - this.m_referenceAngle; // float

    if (Math.abs(this.m_upperAngle - this.m_lowerAngle) < 2.0 * Settings.angularSlop) {
      this.m_limitState = equalLimits;

    } else if (jointAngle <= this.m_lowerAngle) {
      if (this.m_limitState != atLowerLimit) {
        this.m_impulse.z = 0.0;
      }
      this.m_limitState = atLowerLimit;

    } else if (jointAngle >= this.m_upperAngle) {
      if (this.m_limitState != atUpperLimit) {
        this.m_impulse.z = 0.0;
      }
      this.m_limitState = atUpperLimit;

    } else {
      this.m_limitState = inactiveLimit;
      this.m_impulse.z = 0.0;
    }

  } else {
    this.m_limitState = inactiveLimit;
  }

  if (step.warmStarting) {
    // Scale impulses to support a variable time step.
    this.m_impulse.mul(step.dtRatio);
    this.m_motorImpulse *= step.dtRatio;

    var P = Vec2.neo(this.m_impulse.x, this.m_impulse.y);

    vA.subMul(mA, P);
    wA -= iA * (Vec2.cross(this.m_rA, P) + this.m_motorImpulse + this.m_impulse.z);

    vB.addMul(mB, P);
    wB += iB * (Vec2.cross(this.m_rB, P) + this.m_motorImpulse + this.m_impulse.z);

  } else {
    this.m_impulse.setZero();
    this.m_motorImpulse = 0.0;
  }

  this.m_bodyA.c_velocity.v = vA;
  this.m_bodyA.c_velocity.w = wA;
  this.m_bodyB.c_velocity.v = vB;
  this.m_bodyB.c_velocity.w = wB;
}

RevoluteJoint.prototype.solveVelocityConstraints = function(step) {
  var vA = this.m_bodyA.c_velocity.v;
  var wA = this.m_bodyA.c_velocity.w;
  var vB = this.m_bodyB.c_velocity.v;
  var wB = this.m_bodyB.c_velocity.w;

  var mA = this.m_invMassA;
  var mB = this.m_invMassB; // float
  var iA = this.m_invIA;
  var iB = this.m_invIB; // float

  var fixedRotation = (iA + iB === 0.0); // bool

  // Solve motor constraint.
  if (this.m_enableMotor && this.m_limitState != equalLimits
      && fixedRotation == false) {
    var Cdot = wB - wA - this.m_motorSpeed; // float
    var impulse = -this.m_motorMass * Cdot; // float
    var oldImpulse = this.m_motorImpulse; // float
    var maxImpulse = step.dt * this.m_maxMotorTorque; // float
    this.m_motorImpulse = Math.clamp(this.m_motorImpulse + impulse,
        -maxImpulse, maxImpulse);
    impulse = this.m_motorImpulse - oldImpulse;

    wA -= iA * impulse;
    wB += iB * impulse;
  }

  // Solve limit constraint.
  if (this.m_enableLimit && this.m_limitState != inactiveLimit
      && fixedRotation == false) {
    var Cdot1 = Vec2.zero();
    Cdot1.addCombine(1, vB, 1, Vec2.cross(wB, this.m_rB));
    Cdot1.subCombine(1, vA, 1, Vec2.cross(wA, this.m_rA));
    var Cdot2 = wB - wA; // float
    var Cdot = Vec3(Cdot1.x, Cdot1.y, Cdot2);

    var impulse = Vec3.neg(this.m_mass.solve33(Cdot)); // Vec3

    if (this.m_limitState == equalLimits) {
      this.m_impulse.add(impulse);

    } else if (this.m_limitState == atLowerLimit) {
      var newImpulse = this.m_impulse.z + impulse.z; // float

      if (newImpulse < 0.0) {
        var rhs = Vec2.combine(-1, Cdot1, this.m_impulse.z, Vec2.neo(this.m_mass.ez.x, this.m_mass.ez.y)); // Vec2
        var reduced = this.m_mass.solve22(rhs); // Vec2
        impulse.x = reduced.x;
        impulse.y = reduced.y;
        impulse.z = -this.m_impulse.z;
        this.m_impulse.x += reduced.x;
        this.m_impulse.y += reduced.y;
        this.m_impulse.z = 0.0;

      } else {
        this.m_impulse.add(impulse);
      }

    } else if (this.m_limitState == atUpperLimit) {
      var newImpulse = this.m_impulse.z + impulse.z; // float

      if (newImpulse > 0.0) {
        var rhs = Vec2.combine(-1, Cdot1, this.m_impulse.z, Vec2.neo(this.m_mass.ez.x, this.m_mass.ez.y)); // Vec2
        var reduced = this.m_mass.solve22(rhs); // Vec2
        impulse.x = reduced.x;
        impulse.y = reduced.y;
        impulse.z = -this.m_impulse.z;
        this.m_impulse.x += reduced.x;
        this.m_impulse.y += reduced.y;
        this.m_impulse.z = 0.0;

      } else {
        this.m_impulse.add(impulse);
      }
    }

    var P = Vec2.neo(impulse.x, impulse.y);

    vA.subMul(mA, P);
    wA -= iA * (Vec2.cross(this.m_rA, P) + impulse.z);

    vB.addMul(mB, P);
    wB += iB * (Vec2.cross(this.m_rB, P) + impulse.z);

  } else {
    // Solve point-to-point constraint
    var Cdot = Vec2.zero();
    Cdot.addCombine(1, vB, 1, Vec2.cross(wB, this.m_rB));
    Cdot.subCombine(1, vA, 1, Vec2.cross(wA, this.m_rA));
    var impulse = this.m_mass.solve22(Vec2.neg(Cdot)); // Vec2

    this.m_impulse.x += impulse.x;
    this.m_impulse.y += impulse.y;

    vA.subMul(mA, impulse);
    wA -= iA * Vec2.cross(this.m_rA, impulse);

    vB.addMul(mB, impulse);
    wB += iB * Vec2.cross(this.m_rB, impulse);
  }

  this.m_bodyA.c_velocity.v = vA;
  this.m_bodyA.c_velocity.w = wA;
  this.m_bodyB.c_velocity.v = vB;
  this.m_bodyB.c_velocity.w = wB;
}

RevoluteJoint.prototype.solvePositionConstraints = function(step) {
  var cA = this.m_bodyA.c_position.c;
  var aA = this.m_bodyA.c_position.a;
  var cB = this.m_bodyB.c_position.c;
  var aB = this.m_bodyB.c_position.a;

  var qA = Rot.neo(aA);
  var qB = Rot.neo(aB);

  var angularError = 0.0; // float
  var positionError = 0.0; // float

  var fixedRotation = (this.m_invIA + this.m_invIB == 0.0); // bool

  // Solve angular limit constraint.
  if (this.m_enableLimit && this.m_limitState != inactiveLimit
      && fixedRotation == false) {
    var angle = aB - aA - this.m_referenceAngle; // float
    var limitImpulse = 0.0; // float

    if (this.m_limitState == equalLimits) {
      // Prevent large angular corrections
      var C = Math.clamp(angle - this.m_lowerAngle,
          -Settings.maxAngularCorrection, Settings.maxAngularCorrection); // float
      limitImpulse = -this.m_motorMass * C;
      angularError = Math.abs(C);

    } else if (this.m_limitState == atLowerLimit) {
      var C = angle - this.m_lowerAngle; // float
      angularError = -C;

      // Prevent large angular corrections and allow some slop.
      C = Math.clamp(C + Settings.angularSlop, -Settings.maxAngularCorrection,
          0.0);
      limitImpulse = -this.m_motorMass * C;

    } else if (this.m_limitState == atUpperLimit) {
      var C = angle - this.m_upperAngle; // float
      angularError = C;

      // Prevent large angular corrections and allow some slop.
      C = Math.clamp(C - Settings.angularSlop, 0.0,
          Settings.maxAngularCorrection);
      limitImpulse = -this.m_motorMass * C;
    }

    aA -= this.m_invIA * limitImpulse;
    aB += this.m_invIB * limitImpulse;
  }

  // Solve point-to-point constraint.
  {
    qA.set(aA);
    qB.set(aB);
    var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA)); // Vec2
    var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB)); // Vec2

    var C = Vec2.zero();
    C.addCombine(1, cB, 1, rB);
    C.subCombine(1, cA, 1, rA);
    positionError = C.length();

    var mA = this.m_invMassA;
    var mB = this.m_invMassB; // float
    var iA = this.m_invIA;
    var iB = this.m_invIB; // float

    var K = new Mat22();
    K.ex.x = mA + mB + iA * rA.y * rA.y + iB * rB.y * rB.y;
    K.ex.y = -iA * rA.x * rA.y - iB * rB.x * rB.y;
    K.ey.x = K.ex.y;
    K.ey.y = mA + mB + iA * rA.x * rA.x + iB * rB.x * rB.x;

    var impulse = Vec2.neg(K.solve(C)); // Vec2

    cA.subMul(mA, impulse);
    aA -= iA * Vec2.cross(rA, impulse);

    cB.addMul(mB, impulse);
    aB += iB * Vec2.cross(rB, impulse);
  }

  this.m_bodyA.c_position.c.set(cA);
  this.m_bodyA.c_position.a = aA;
  this.m_bodyB.c_position.c.set(cB);
  this.m_bodyB.c_position.a = aB;

  return positionError <= Settings.linearSlop
      && angularError <= Settings.angularSlop;
}


/***/ }),
/* 103 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

module.exports = PrismaticJoint;

var common = __webpack_require__(61);
var options = __webpack_require__(60);
var create = __webpack_require__(64);
var Settings = __webpack_require__(66);

var Math = __webpack_require__(63);
var Vec2 = __webpack_require__(62);
var Vec3 = __webpack_require__(84);
var Mat22 = __webpack_require__(80);
var Mat33 = __webpack_require__(85);
var Rot = __webpack_require__(72);
var Sweep = __webpack_require__(73);
var Transform = __webpack_require__(74);
var Velocity = __webpack_require__(75);
var Position = __webpack_require__(76);

var Joint = __webpack_require__(86);
var Body = __webpack_require__(71);

var inactiveLimit = 0;
var atLowerLimit = 1;
var atUpperLimit = 2;
var equalLimits = 3;

PrismaticJoint.TYPE = 'prismatic-joint';
Joint.TYPES[PrismaticJoint.TYPE] = PrismaticJoint;

PrismaticJoint._super = Joint;
PrismaticJoint.prototype = create(PrismaticJoint._super.prototype);

/**
 * @typedef {Object} PrismaticJointDef
 *
 * Prismatic joint definition. This requires defining a line of motion using an
 * axis and an anchor point. The definition uses local anchor points and a local
 * axis so that the initial configuration can violate the constraint slightly.
 * The joint translation is zero when the local anchor points coincide in world
 * space. Using local anchors and a local axis helps when saving and loading a
 * game.
 * 
 * @prop {boolean} enableLimit Enable/disable the joint limit.
 * @prop {float} lowerTranslation The lower translation limit, usually in
 *       meters.
 * @prop {float} upperTranslation The upper translation limit, usually in
 *       meters.
 * @prop {boolean} enableMotor Enable/disable the joint motor.
 * @prop {float} maxMotorForce The maximum motor torque, usually in N-m.
 * @prop {float} motorSpeed The desired motor speed in radians per second.
 *
 * @prop {Vec2} localAnchorA The local anchor point relative to bodyA's origin.
 * @prop {Vec2} localAnchorB The local anchor point relative to bodyB's origin.
 * @prop {Vec2} localAxisA The local translation unit axis in bodyA.
 * @prop {float} referenceAngle The constrained angle between the bodies:
 *       bodyB_angle - bodyA_angle.
 */

var DEFAULTS = {
  enableLimit : false,
  lowerTranslation : 0.0,
  upperTranslation : 0.0,
  enableMotor : false,
  maxMotorForce : 0.0,
  motorSpeed : 0.0
};

/**
 * A prismatic joint. This joint provides one degree of freedom: translation
 * along an axis fixed in bodyA. Relative rotation is prevented. You can use a
 * joint limit to restrict the range of motion and a joint motor to drive the
 * motion or to model joint friction.
 *
 * @param {PrismaticJointDef} def
 * @param {Body} bodyA
 * @param {Body} bodyB
 */
function PrismaticJoint(def, bodyA, bodyB, anchor, axis) {
  if (!(this instanceof PrismaticJoint)) {
    return new PrismaticJoint(def, bodyA, bodyB, anchor, axis);
  }

  def = options(def, DEFAULTS);
  Joint.call(this, def, bodyA, bodyB);
  bodyA = this.m_bodyA;
  bodyB = this.m_bodyB;

  this.m_type = PrismaticJoint.TYPE;

  this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());
  this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());
  this.m_localXAxisA = Vec2.clone(axis ? bodyA.getLocalVector(axis) : def.localAxisA || Vec2.neo(1.0, 0.0));
  this.m_localXAxisA.normalize();
  this.m_localYAxisA = Vec2.cross(1.0, this.m_localXAxisA);
  this.m_referenceAngle = Math.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();

  this.m_impulse = Vec3();
  this.m_motorMass = 0.0;
  this.m_motorImpulse = 0.0;

  this.m_lowerTranslation = def.lowerTranslation;
  this.m_upperTranslation = def.upperTranslation;
  this.m_maxMotorForce = def.maxMotorForce;
  this.m_motorSpeed = def.motorSpeed;
  this.m_enableLimit = def.enableLimit;
  this.m_enableMotor = def.enableMotor;
  this.m_limitState = inactiveLimit;

  this.m_axis = Vec2.zero();
  this.m_perp = Vec2.zero();

  // Solver temp
  this.m_localCenterA; // Vec2
  this.m_localCenterB; // Vec2
  this.m_invMassA; // float
  this.m_invMassB; // float
  this.m_invIA; // float
  this.m_invIB; // float
  this.m_axis, this.m_perp; // Vec2
  this.m_s1, this.m_s2; // float
  this.m_a1, this.m_a2; // float
  this.m_K = new Mat33();
  this.m_motorMass; // float

  // Linear constraint (point-to-line)
  // d = p2 - p1 = x2 + r2 - x1 - r1
  // C = dot(perp, d)
  // Cdot = dot(d, cross(w1, perp)) + dot(perp, v2 + cross(w2, r2) - v1 -
  // cross(w1, r1))
  // = -dot(perp, v1) - dot(cross(d + r1, perp), w1) + dot(perp, v2) +
  // dot(cross(r2, perp), v2)
  // J = [-perp, -cross(d + r1, perp), perp, cross(r2,perp)]
  //
  // Angular constraint
  // C = a2 - a1 + a_initial
  // Cdot = w2 - w1
  // J = [0 0 -1 0 0 1]
  //
  // K = J * invM * JT
  //
  // J = [-a -s1 a s2]
  // [0 -1 0 1]
  // a = perp
  // s1 = cross(d + r1, a) = cross(p2 - x1, a)
  // s2 = cross(r2, a) = cross(p2 - x2, a)

  // Motor/Limit linear constraint
  // C = dot(ax1, d)
  // Cdot = = -dot(ax1, v1) - dot(cross(d + r1, ax1), w1) + dot(ax1, v2) +
  // dot(cross(r2, ax1), v2)
  // J = [-ax1 -cross(d+r1,ax1) ax1 cross(r2,ax1)]

  // Block Solver
  // We develop a block solver that includes the joint limit. This makes the
  // limit stiff (inelastic) even
  // when the mass has poor distribution (leading to large torques about the
  // joint anchor points).
  //
  // The Jacobian has 3 rows:
  // J = [-uT -s1 uT s2] // linear
  // [0 -1 0 1] // angular
  // [-vT -a1 vT a2] // limit
  //
  // u = perp
  // v = axis
  // s1 = cross(d + r1, u), s2 = cross(r2, u)
  // a1 = cross(d + r1, v), a2 = cross(r2, v)

  // M * (v2 - v1) = JT * df
  // J * v2 = bias
  //
  // v2 = v1 + invM * JT * df
  // J * (v1 + invM * JT * df) = bias
  // K * df = bias - J * v1 = -Cdot
  // K = J * invM * JT
  // Cdot = J * v1 - bias
  //
  // Now solve for f2.
  // df = f2 - f1
  // K * (f2 - f1) = -Cdot
  // f2 = invK * (-Cdot) + f1
  //
  // Clamp accumulated limit impulse.
  // lower: f2(3) = max(f2(3), 0)
  // upper: f2(3) = min(f2(3), 0)
  //
  // Solve for correct f2(1:2)
  // K(1:2, 1:2) * f2(1:2) = -Cdot(1:2) - K(1:2,3) * f2(3) + K(1:2,1:3) * f1
  // = -Cdot(1:2) - K(1:2,3) * f2(3) + K(1:2,1:2) * f1(1:2) + K(1:2,3) * f1(3)
  // K(1:2, 1:2) * f2(1:2) = -Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3)) +
  // K(1:2,1:2) * f1(1:2)
  // f2(1:2) = invK(1:2,1:2) * (-Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3))) +
  // f1(1:2)
  //
  // Now compute impulse to be applied:
  // df = f2 - f1
}

PrismaticJoint.prototype._serialize = function() {
  return {
    type: this.m_type,
    bodyA: this.m_bodyA,
    bodyB: this.m_bodyB,
    collideConnected: this.m_collideConnected,

    lowerTranslation: this.m_lowerTranslation,
    upperTranslation: this.m_upperTranslation,
    maxMotorForce: this.m_maxMotorForce,
    motorSpeed: this.m_motorSpeed,
    enableLimit: this.m_enableLimit,
    enableMotor: this.m_enableMotor,

    localAnchorA: this.m_localAnchorA,
    localAnchorB: this.m_localAnchorB,
    localAxisA: this.m_localXAxisA,
    referenceAngle: this.m_referenceAngle,
  };
};

PrismaticJoint._deserialize = function(data, world, restore) {
  data = Object.assign({}, data);
  data.bodyA = restore(Body, data.bodyA, world);
  data.bodyB = restore(Body, data.bodyB, world);
  data.localAxisA = Vec2(data.localAxisA);
  var joint = new PrismaticJoint(data);
  return joint;
};

/**
 * @internal
 */
PrismaticJoint.prototype._setAnchors = function(def) {
  if (def.anchorA) {
    this.m_localAnchorA.set(this.m_bodyA.getLocalPoint(def.anchorA));
  } else if (def.localAnchorA) {
    this.m_localAnchorA.set(def.localAnchorA);
  }

  if (def.anchorB) {
    this.m_localAnchorB.set(this.m_bodyB.getLocalPoint(def.anchorB));
  } else if (def.localAnchorB) {
    this.m_localAnchorB.set(def.localAnchorB);
  }

  if (def.localAxisA) {
    this.m_localXAxisA.set(def.localAxisA);
    this.m_localYAxisA.set(Vec2.cross(1.0, def.localAxisA));
  }
}

/**
 * The local anchor point relative to bodyA's origin.
 */
PrismaticJoint.prototype.getLocalAnchorA = function() {
  return this.m_localAnchorA;
}

/**
 * The local anchor point relative to bodyB's origin.
 */
PrismaticJoint.prototype.getLocalAnchorB = function() {
  return this.m_localAnchorB;
}

/**
 * The local joint axis relative to bodyA.
 */
PrismaticJoint.prototype.getLocalAxisA = function() {
  return this.m_localXAxisA;
}

/**
 * Get the reference angle.
 */
PrismaticJoint.prototype.getReferenceAngle = function() {
  return this.m_referenceAngle;
}

/**
 * Get the current joint translation, usually in meters.
 */
PrismaticJoint.prototype.getJointTranslation = function() {
  var pA = this.m_bodyA.getWorldPoint(this.m_localAnchorA);
  var pB = this.m_bodyB.getWorldPoint(this.m_localAnchorB);
  var d = Vec2.sub(pB, pA);
  var axis = this.m_bodyA.getWorldVector(this.m_localXAxisA);

  var translation = Vec2.dot(d, axis);
  return translation;
}

/**
 * Get the current joint translation speed, usually in meters per second.
 */
PrismaticJoint.prototype.getJointSpeed = function() {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;

  var rA = Rot.mulVec2(bA.m_xf.q, Vec2.sub(this.m_localAnchorA, bA.m_sweep.localCenter)); // Vec2
  var rB = Rot.mulVec2(bB.m_xf.q, Vec2.sub(this.m_localAnchorB, bB.m_sweep.localCenter)); // Vec2
  var p1 = Vec2.add(bA.m_sweep.c, rA); // Vec2
  var p2 = Vec2.add(bB.m_sweep.c, rB); // Vec2
  var d = Vec2.sub(p2, p1); // Vec2
  var axis = Rot.mulVec2(bA.m_xf.q, this.m_localXAxisA); // Vec2

  var vA = bA.m_linearVelocity; // Vec2
  var vB = bB.m_linearVelocity; // Vec2
  var wA = bA.m_angularVelocity; // float
  var wB = bB.m_angularVelocity; // float

  var speed = Vec2.dot(d, Vec2.cross(wA, axis))
      + Vec2.dot(axis, Vec2.sub(Vec2.addCross(vB, wB, rB), Vec2.addCross(vA, wA, rA))); // float
  return speed;
}

/**
 * Is the joint limit enabled?
 */
PrismaticJoint.prototype.isLimitEnabled = function() {
  return this.m_enableLimit;
}

/**
 * Enable/disable the joint limit.
 */
PrismaticJoint.prototype.enableLimit = function(flag) {
  if (flag != this.m_enableLimit) {
    this.m_bodyA.setAwake(true);
    this.m_bodyB.setAwake(true);
    this.m_enableLimit = flag;
    this.m_impulse.z = 0.0;
  }
}

/**
 * Get the lower joint limit, usually in meters.
 */
PrismaticJoint.prototype.getLowerLimit = function() {
  return this.m_lowerTranslation;
}

/**
 * Get the upper joint limit, usually in meters.
 */
PrismaticJoint.prototype.getUpperLimit = function() {
  return this.m_upperTranslation;
}

/**
 * Set the joint limits, usually in meters.
 */
PrismaticJoint.prototype.setLimits = function(lower, upper) {
  _ASSERT && common.assert(lower <= upper);
  if (lower != this.m_lowerTranslation || upper != this.m_upperTranslation) {
    this.m_bodyA.setAwake(true);
    this.m_bodyB.setAwake(true);
    this.m_lowerTranslation = lower;
    this.m_upperTranslation = upper;
    this.m_impulse.z = 0.0;
  }
}

/**
 * Is the joint motor enabled?
 */
PrismaticJoint.prototype.isMotorEnabled = function() {
  return this.m_enableMotor;
}

/**
 * Enable/disable the joint motor.
 */
PrismaticJoint.prototype.enableMotor = function(flag) {
  this.m_bodyA.setAwake(true);
  this.m_bodyB.setAwake(true);
  this.m_enableMotor = flag;
}

/**
 * Set the motor speed, usually in meters per second.
 */
PrismaticJoint.prototype.setMotorSpeed = function(speed) {
  this.m_bodyA.setAwake(true);
  this.m_bodyB.setAwake(true);
  this.m_motorSpeed = speed;
}

/**
 * Set the maximum motor force, usually in N.
 */
PrismaticJoint.prototype.setMaxMotorForce = function(force) {
  this.m_bodyA.setAwake(true);
  this.m_bodyB.setAwake(true);
  this.m_maxMotorForce = force;
}

PrismaticJoint.prototype.getMaxMotorForce = function() {
  return this.m_maxMotorForce;
}

/**
 * Get the motor speed, usually in meters per second.
 */
PrismaticJoint.prototype.getMotorSpeed = function() {
  return this.m_motorSpeed;
}

/**
 * Get the current motor force given the inverse time step, usually in N.
 */
PrismaticJoint.prototype.getMotorForce = function(inv_dt) {
  return inv_dt * this.m_motorImpulse;
}

PrismaticJoint.prototype.getAnchorA = function() {
  return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
}

PrismaticJoint.prototype.getAnchorB = function() {
  return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
}

PrismaticJoint.prototype.getReactionForce = function(inv_dt) {
  return Vec2.combine(this.m_impulse.x, this.m_perp, this.m_motorImpulse + this.m_impulse.z, this.m_axis).mul(inv_dt);
}

PrismaticJoint.prototype.getReactionTorque = function(inv_dt) {
  return inv_dt * this.m_impulse.y;
}

PrismaticJoint.prototype.initVelocityConstraints = function(step) {
  this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
  this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
  this.m_invMassA = this.m_bodyA.m_invMass;
  this.m_invMassB = this.m_bodyB.m_invMass;
  this.m_invIA = this.m_bodyA.m_invI;
  this.m_invIB = this.m_bodyB.m_invI;

  var cA = this.m_bodyA.c_position.c;
  var aA = this.m_bodyA.c_position.a;
  var vA = this.m_bodyA.c_velocity.v;
  var wA = this.m_bodyA.c_velocity.w;

  var cB = this.m_bodyB.c_position.c;
  var aB = this.m_bodyB.c_position.a;
  var vB = this.m_bodyB.c_velocity.v;
  var wB = this.m_bodyB.c_velocity.w;

  var qA = Rot.neo(aA);
  var qB = Rot.neo(aB);

  // Compute the effective masses.
  var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
  var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
  var d = Vec2.zero();
  d.addCombine(1, cB, 1, rB);
  d.subCombine(1, cA, 1, rA);

  var mA = this.m_invMassA, mB = this.m_invMassB;
  var iA = this.m_invIA, iB = this.m_invIB;

  // Compute motor Jacobian and effective mass.
  {
    this.m_axis = Rot.mulVec2(qA, this.m_localXAxisA);
    this.m_a1 = Vec2.cross(Vec2.add(d, rA), this.m_axis);
    this.m_a2 = Vec2.cross(rB, this.m_axis);

    this.m_motorMass = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2
        * this.m_a2;
    if (this.m_motorMass > 0.0) {
      this.m_motorMass = 1.0 / this.m_motorMass;
    }
  }

  // Prismatic constraint.
  {
    this.m_perp = Rot.mulVec2(qA, this.m_localYAxisA);

    this.m_s1 = Vec2.cross(Vec2.add(d, rA), this.m_perp);
    this.m_s2 = Vec2.cross(rB, this.m_perp);

    var s1test = Vec2.cross(rA, this.m_perp);

    var k11 = mA + mB + iA * this.m_s1 * this.m_s1 + iB * this.m_s2 * this.m_s2;
    var k12 = iA * this.m_s1 + iB * this.m_s2;
    var k13 = iA * this.m_s1 * this.m_a1 + iB * this.m_s2 * this.m_a2;
    var k22 = iA + iB;
    if (k22 == 0.0) {
      // For bodies with fixed rotation.
      k22 = 1.0;
    }
    var k23 = iA * this.m_a1 + iB * this.m_a2;
    var k33 = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2 * this.m_a2;

    this.m_K.ex.set(k11, k12, k13);
    this.m_K.ey.set(k12, k22, k23);
    this.m_K.ez.set(k13, k23, k33);
  }

  // Compute motor and limit terms.
  if (this.m_enableLimit) {

    var jointTranslation = Vec2.dot(this.m_axis, d); // float
    if (Math.abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * Settings.linearSlop) {
      this.m_limitState = equalLimits;

    } else if (jointTranslation <= this.m_lowerTranslation) {
      if (this.m_limitState != atLowerLimit) {
        this.m_limitState = atLowerLimit;
        this.m_impulse.z = 0.0;
      }

    } else if (jointTranslation >= this.m_upperTranslation) {
      if (this.m_limitState != atUpperLimit) {
        this.m_limitState = atUpperLimit;
        this.m_impulse.z = 0.0;
      }

    } else {
      this.m_limitState = inactiveLimit;
      this.m_impulse.z = 0.0;
    }

  } else {
    this.m_limitState = inactiveLimit;
    this.m_impulse.z = 0.0;
  }

  if (this.m_enableMotor == false) {
    this.m_motorImpulse = 0.0;
  }

  if (step.warmStarting) {
    // Account for variable time step.
    this.m_impulse.mul(step.dtRatio);
    this.m_motorImpulse *= step.dtRatio;

    var P = Vec2.combine(this.m_impulse.x, this.m_perp, this.m_motorImpulse
        + this.m_impulse.z, this.m_axis);
    var LA = this.m_impulse.x * this.m_s1 + this.m_impulse.y
        + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;
    var LB = this.m_impulse.x * this.m_s2 + this.m_impulse.y
        + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;

    vA.subMul(mA, P);
    wA -= iA * LA;

    vB.addMul(mB, P);
    wB += iB * LB;
  } else {
    this.m_impulse.setZero();
    this.m_motorImpulse = 0.0;
  }

  this.m_bodyA.c_velocity.v.set(vA);
  this.m_bodyA.c_velocity.w = wA;
  this.m_bodyB.c_velocity.v.set(vB);
  this.m_bodyB.c_velocity.w = wB;
}

PrismaticJoint.prototype.solveVelocityConstraints = function(step) {
  var vA = this.m_bodyA.c_velocity.v;
  var wA = this.m_bodyA.c_velocity.w;
  var vB = this.m_bodyB.c_velocity.v;
  var wB = this.m_bodyB.c_velocity.w;

  var mA = this.m_invMassA;
  var mB = this.m_invMassB;
  var iA = this.m_invIA;
  var iB = this.m_invIB;

  // Solve linear motor constraint.
  if (this.m_enableMotor && this.m_limitState != equalLimits) {
    var Cdot = Vec2.dot(this.m_axis, Vec2.sub(vB, vA)) + this.m_a2 * wB
        - this.m_a1 * wA;
    var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);
    var oldImpulse = this.m_motorImpulse;
    var maxImpulse = step.dt * this.m_maxMotorForce;
    this.m_motorImpulse = Math.clamp(this.m_motorImpulse + impulse,
        -maxImpulse, maxImpulse);
    impulse = this.m_motorImpulse - oldImpulse;

    var P = Vec2.mul(impulse, this.m_axis);
    var LA = impulse * this.m_a1;
    var LB = impulse * this.m_a2;

    vA.subMul(mA, P);
    wA -= iA * LA;

    vB.addMul(mB, P);
    wB += iB * LB;
  }

  var Cdot1 = Vec2.zero();
  Cdot1.x += Vec2.dot(this.m_perp, vB) + this.m_s2 * wB;
  Cdot1.x -= Vec2.dot(this.m_perp, vA) + this.m_s1 * wA;
  Cdot1.y = wB - wA;

  if (this.m_enableLimit && this.m_limitState != inactiveLimit) {
    // Solve prismatic and limit constraint in block form.
    var Cdot2 = 0;
    Cdot2 += Vec2.dot(this.m_axis, vB) + this.m_a2 * wB;
    Cdot2 -= Vec2.dot(this.m_axis, vA) + this.m_a1 * wA;

    var Cdot = Vec3(Cdot1.x, Cdot1.y, Cdot2);

    var f1 = Vec3(this.m_impulse);
    var df = this.m_K.solve33(Vec3.neg(Cdot)); // Vec3
    this.m_impulse.add(df);

    if (this.m_limitState == atLowerLimit) {
      this.m_impulse.z = Math.max(this.m_impulse.z, 0.0);
    } else if (this.m_limitState == atUpperLimit) {
      this.m_impulse.z = Math.min(this.m_impulse.z, 0.0);
    }

    // f2(1:2) = invK(1:2,1:2) * (-Cdot(1:2) - K(1:2,3) * (f2(3) - f1(3))) +
    // f1(1:2)
    var b = Vec2.combine(-1, Cdot1, -(this.m_impulse.z - f1.z), Vec2.neo(this.m_K.ez.x, this.m_K.ez.y)); // Vec2
    var f2r = Vec2.add(this.m_K.solve22(b), Vec2.neo(f1.x, f1.y)); // Vec2
    this.m_impulse.x = f2r.x;
    this.m_impulse.y = f2r.y;

    df = Vec3.sub(this.m_impulse, f1);

    var P = Vec2.combine(df.x, this.m_perp, df.z, this.m_axis); // Vec2
    var LA = df.x * this.m_s1 + df.y + df.z * this.m_a1; // float
    var LB = df.x * this.m_s2 + df.y + df.z * this.m_a2; // float

    vA.subMul(mA, P);
    wA -= iA * LA;

    vB.addMul(mB, P);
    wB += iB * LB;
  } else {
    // Limit is inactive, just solve the prismatic constraint in block form.
    var df = this.m_K.solve22(Vec2.neg(Cdot1)); // Vec2
    this.m_impulse.x += df.x;
    this.m_impulse.y += df.y;

    var P = Vec2.mul(df.x, this.m_perp); // Vec2
    var LA = df.x * this.m_s1 + df.y; // float
    var LB = df.x * this.m_s2 + df.y; // float

    vA.subMul(mA, P);
    wA -= iA * LA;

    vB.addMul(mB, P);
    wB += iB * LB;
  }

  this.m_bodyA.c_velocity.v = vA;
  this.m_bodyA.c_velocity.w = wA;
  this.m_bodyB.c_velocity.v = vB;
  this.m_bodyB.c_velocity.w = wB;
}

PrismaticJoint.prototype.solvePositionConstraints = function(step) {
  var cA = this.m_bodyA.c_position.c;
  var aA = this.m_bodyA.c_position.a;
  var cB = this.m_bodyB.c_position.c;
  var aB = this.m_bodyB.c_position.a;

  var qA = Rot.neo(aA);
  var qB = Rot.neo(aB);

  var mA = this.m_invMassA;
  var mB = this.m_invMassB;
  var iA = this.m_invIA;
  var iB = this.m_invIB;

  // Compute fresh Jacobians
  var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA)); // Vec2
  var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB)); // Vec2
  var d = Vec2.sub(Vec2.add(cB, rB), Vec2.add(cA, rA)); // Vec2

  var axis = Rot.mulVec2(qA, this.m_localXAxisA); // Vec2
  var a1 = Vec2.cross(Vec2.add(d, rA), axis); // float
  var a2 = Vec2.cross(rB, axis); // float
  var perp = Rot.mulVec2(qA, this.m_localYAxisA); // Vec2

  var s1 = Vec2.cross(Vec2.add(d, rA), perp); // float
  var s2 = Vec2.cross(rB, perp); // float

  var impulse = Vec3();
  var C1 = Vec2.zero(); // Vec2
  C1.x = Vec2.dot(perp, d);
  C1.y = aB - aA - this.m_referenceAngle;

  var linearError = Math.abs(C1.x); // float
  var angularError = Math.abs(C1.y); // float

  var linearSlop = Settings.linearSlop;
  var maxLinearCorrection = Settings.maxLinearCorrection;

  var active = false; // bool
  var C2 = 0.0; // float
  if (this.m_enableLimit) {

    var translation = Vec2.dot(axis, d); // float
    if (Math.abs(this.m_upperTranslation - this.m_lowerTranslation) < 2.0 * linearSlop) {
      // Prevent large angular corrections
      C2 = Math.clamp(translation, -maxLinearCorrection, maxLinearCorrection);
      linearError = Math.max(linearError, Math.abs(translation));
      active = true;

    } else if (translation <= this.m_lowerTranslation) {
      // Prevent large linear corrections and allow some slop.
      C2 = Math.clamp(translation - this.m_lowerTranslation + linearSlop,
          -maxLinearCorrection, 0.0);
      linearError = Math
          .max(linearError, this.m_lowerTranslation - translation);
      active = true;

    } else if (translation >= this.m_upperTranslation) {
      // Prevent large linear corrections and allow some slop.
      C2 = Math.clamp(translation - this.m_upperTranslation - linearSlop, 0.0,
          maxLinearCorrection);
      linearError = Math
          .max(linearError, translation - this.m_upperTranslation);
      active = true;
    }
  }

  if (active) {
    var k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2; // float
    var k12 = iA * s1 + iB * s2; // float
    var k13 = iA * s1 * a1 + iB * s2 * a2; // float
    var k22 = iA + iB; // float
    if (k22 == 0.0) {
      // For fixed rotation
      k22 = 1.0;
    }
    var k23 = iA * a1 + iB * a2; // float
    var k33 = mA + mB + iA * a1 * a1 + iB * a2 * a2; // float

    var K = new Mat33()
    K.ex.set(k11, k12, k13);
    K.ey.set(k12, k22, k23);
    K.ez.set(k13, k23, k33);

    var C = Vec3();
    C.x = C1.x;
    C.y = C1.y;
    C.z = C2;

    impulse = K.solve33(Vec3.neg(C));
  } else {
    var k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2; // float
    var k12 = iA * s1 + iB * s2; // float
    var k22 = iA + iB; // float
    if (k22 == 0.0) {
      k22 = 1.0;
    }

    var K = new Mat22();
    K.ex.set(k11, k12);
    K.ey.set(k12, k22);

    var impulse1 = K.solve(Vec2.neg(C1)); // Vec2
    impulse.x = impulse1.x;
    impulse.y = impulse1.y;
    impulse.z = 0.0;
  }

  var P = Vec2.combine(impulse.x, perp, impulse.z, axis); // Vec2
  var LA = impulse.x * s1 + impulse.y + impulse.z * a1; // float
  var LB = impulse.x * s2 + impulse.y + impulse.z * a2; // float

  cA.subMul(mA, P);
  aA -= iA * LA;
  cB.addMul(mB, P);
  aB += iB * LB;

  this.m_bodyA.c_position.c = cA;
  this.m_bodyA.c_position.a = aA;
  this.m_bodyB.c_position.c = cB;
  this.m_bodyB.c_position.a = aB;

  return linearError <= Settings.linearSlop
      && angularError <= Settings.angularSlop;
}


/***/ }),
/* 104 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

module.exports = MotorJoint;

var common = __webpack_require__(61);
var options = __webpack_require__(60);
var create = __webpack_require__(64);
var Settings = __webpack_require__(66);

var Math = __webpack_require__(63);
var Vec2 = __webpack_require__(62);
var Vec3 = __webpack_require__(84);
var Mat22 = __webpack_require__(80);
var Mat33 = __webpack_require__(85);
var Rot = __webpack_require__(72);
var Sweep = __webpack_require__(73);
var Transform = __webpack_require__(74);
var Velocity = __webpack_require__(75);
var Position = __webpack_require__(76);

var Joint = __webpack_require__(86);
var Body = __webpack_require__(71);

MotorJoint.TYPE = 'motor-joint';
Joint.TYPES[MotorJoint.TYPE] = MotorJoint;

MotorJoint._super = Joint;
MotorJoint.prototype = create(MotorJoint._super.prototype);

/**
 * @typedef {Object} MotorJointDef
 *
 * Motor joint definition.
 * 
 * @prop {float} angularOffset The bodyB angle minus bodyA angle in radians.
 * @prop {float} maxForce The maximum motor force in N.
 * @prop {float} maxTorque The maximum motor torque in N-m.
 * @prop {float} correctionFactor Position correction factor in the range [0,1].
 * @prop {Vec2} linearOffset Position of bodyB minus the position of bodyA, in
 *       bodyA's frame, in meters.
 */

var DEFAULTS = {
  maxForce : 1.0,
  maxTorque : 1.0,
  correctionFactor : 0.3
};

/**
 * A motor joint is used to control the relative motion between two bodies. A
 * typical usage is to control the movement of a dynamic body with respect to
 * the ground.
 *
 * @param {MotorJointDef} def
 * @param {Body} bodyA
 * @param {Body} bodyB
 */
function MotorJoint(def, bodyA, bodyB) {
  if (!(this instanceof MotorJoint)) {
    return new MotorJoint(def, bodyA, bodyB);
  }

  def = options(def, DEFAULTS);
  Joint.call(this, def, bodyA, bodyB);
  bodyA = this.m_bodyA;
  bodyB = this.m_bodyB;

  this.m_type = MotorJoint.TYPE;

  this.m_linearOffset = Math.isFinite(def.linearOffset) ? def.linearOffset : bodyA.getLocalPoint(bodyB.getPosition());
  this.m_angularOffset = Math.isFinite(def.angularOffset) ? def.angularOffset : bodyB.getAngle() - bodyA.getAngle();

  this.m_linearImpulse = Vec2.zero();
  this.m_angularImpulse = 0.0;

  this.m_maxForce = def.maxForce;
  this.m_maxTorque = def.maxTorque;
  this.m_correctionFactor = def.correctionFactor;

  // Solver temp
  this.m_rA; // Vec2
  this.m_rB; // Vec2
  this.m_localCenterA; // Vec2
  this.m_localCenterB; // Vec2
  this.m_linearError; // Vec2
  this.m_angularError; // float
  this.m_invMassA; // float
  this.m_invMassB; // float
  this.m_invIA; // float
  this.m_invIB; // float
  this.m_linearMass; // Mat22
  this.m_angularMass; // float

  // Point-to-point constraint
  // Cdot = v2 - v1
  // = v2 + cross(w2, r2) - v1 - cross(w1, r1)
  // J = [-I -r1_skew I r2_skew ]
  // Identity used:
  // w k % (rx i + ry j) = w * (-ry i + rx j)

  // Angle constraint
  // Cdot = w2 - w1
  // J = [0 0 -1 0 0 1]
  // K = invI1 + invI2
}

MotorJoint.prototype._serialize = function() {
  return {
    type: this.m_type,
    bodyA: this.m_bodyA,
    bodyB: this.m_bodyB,
    collideConnected: this.m_collideConnected,

    maxForce: this.m_maxForce,
    maxTorque: this.m_maxTorque,
    correctionFactor: this.m_correctionFactor,

    linearOffset: this.m_linearOffset,
    angularOffset: this.m_angularOffset,
  };
};

MotorJoint._deserialize = function(data, world, restore) {
  data = Object.assign({}, data);
  data.bodyA = restore(Body, data.bodyA, world);
  data.bodyB = restore(Body, data.bodyB, world);
  var joint = new MotorJoint(data);
  return joint;
};

/**
 * @internal
 */
MotorJoint.prototype._setAnchors = function(def) {
  if (def.anchorA) {
    this.m_localAnchorA.set(this.m_bodyA.getLocalPoint(def.anchorA));
  } else if (def.localAnchorA) {
    this.m_localAnchorA.set(def.localAnchorA);
  }

  if (def.anchorB) {
    this.m_localAnchorB.set(this.m_bodyB.getLocalPoint(def.anchorB));
  } else if (def.localAnchorB) {
    this.m_localAnchorB.set(def.localAnchorB);
  }
}

/**
 * Set the maximum friction force in N.
 */
MotorJoint.prototype.setMaxForce = function(force) {
  _ASSERT && common.assert(Math.isFinite(force) && force >= 0.0);
  this.m_maxForce = force;
}

/**
 * Get the maximum friction force in N.
 */
MotorJoint.prototype.getMaxForce = function() {
  return this.m_maxForce;
}

/**
 * Set the maximum friction torque in N*m.
 */
MotorJoint.prototype.setMaxTorque = function(torque) {
  _ASSERT && common.assert(Math.isFinite(torque) && torque >= 0.0);
  this.m_maxTorque = torque;
}

/**
 * Get the maximum friction torque in N*m.
 */
MotorJoint.prototype.getMaxTorque = function() {
  return this.m_maxTorque;
}

/**
 * Set the position correction factor in the range [0,1].
 */
MotorJoint.prototype.setCorrectionFactor = function(factor) {
  _ASSERT && common.assert(Math.isFinite(factor) && 0.0 <= factor && factor <= 1.0);
  this.m_correctionFactor = factor;
}

/**
 * Get the position correction factor in the range [0,1].
 */
MotorJoint.prototype.getCorrectionFactor = function() {
  return this.m_correctionFactor;
}

/**
 * Set/get the target linear offset, in frame A, in meters.
 */
MotorJoint.prototype.setLinearOffset = function(linearOffset) {
  if (linearOffset.x != this.m_linearOffset.x
      || linearOffset.y != this.m_linearOffset.y) {
    this.m_bodyA.setAwake(true);
    this.m_bodyB.setAwake(true);
    this.m_linearOffset = linearOffset;
  }
}

MotorJoint.prototype.getLinearOffset = function() {
  return this.m_linearOffset;
}

/**
 * Set/get the target angular offset, in radians.
 */
MotorJoint.prototype.setAngularOffset = function(angularOffset) {
  if (angularOffset != this.m_angularOffset) {
    this.m_bodyA.setAwake(true);
    this.m_bodyB.setAwake(true);
    this.m_angularOffset = angularOffset;
  }
}

MotorJoint.prototype.getAngularOffset = function() {
  return this.m_angularOffset;
}

MotorJoint.prototype.getAnchorA = function() {
  return this.m_bodyA.getPosition();
}

MotorJoint.prototype.getAnchorB = function() {
  return this.m_bodyB.getPosition();
}

MotorJoint.prototype.getReactionForce = function(inv_dt) {
  return Vec2.mul(inv_dt, this.m_linearImpulse);
}

MotorJoint.prototype.getReactionTorque = function(inv_dt) {
  return inv_dt * this.m_angularImpulse;
}

MotorJoint.prototype.initVelocityConstraints = function(step) {
  this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
  this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
  this.m_invMassA = this.m_bodyA.m_invMass;
  this.m_invMassB = this.m_bodyB.m_invMass;
  this.m_invIA = this.m_bodyA.m_invI;
  this.m_invIB = this.m_bodyB.m_invI;

  var cA = this.m_bodyA.c_position.c;
  var aA = this.m_bodyA.c_position.a;
  var vA = this.m_bodyA.c_velocity.v;
  var wA = this.m_bodyA.c_velocity.w;

  var cB = this.m_bodyB.c_position.c;
  var aB = this.m_bodyB.c_position.a;
  var vB = this.m_bodyB.c_velocity.v;
  var wB = this.m_bodyB.c_velocity.w;

  var qA = Rot.neo(aA), qB = Rot.neo(aB);

  // Compute the effective mass matrix.
  this.m_rA = Rot.mulVec2(qA, Vec2.neg(this.m_localCenterA));
  this.m_rB = Rot.mulVec2(qB, Vec2.neg(this.m_localCenterB));

  // J = [-I -r1_skew I r2_skew]
  // [ 0 -1 0 1]
  // r_skew = [-ry; rx]

  // Matlab
  // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]
  // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]
  // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]

  var mA = this.m_invMassA;
  var mB = this.m_invMassB;
  var iA = this.m_invIA;
  var iB = this.m_invIB;

  var K = new Mat22();
  K.ex.x = mA + mB + iA * this.m_rA.y * this.m_rA.y + iB * this.m_rB.y
      * this.m_rB.y;
  K.ex.y = -iA * this.m_rA.x * this.m_rA.y - iB * this.m_rB.x * this.m_rB.y;
  K.ey.x = K.ex.y;
  K.ey.y = mA + mB + iA * this.m_rA.x * this.m_rA.x + iB * this.m_rB.x
      * this.m_rB.x;

  this.m_linearMass = K.getInverse();

  this.m_angularMass = iA + iB;
  if (this.m_angularMass > 0.0) {
    this.m_angularMass = 1.0 / this.m_angularMass;
  }

  this.m_linearError = Vec2.zero();
  this.m_linearError.addCombine(1, cB, 1, this.m_rB);
  this.m_linearError.subCombine(1, cA, 1, this.m_rA);
  this.m_linearError.sub(Rot.mulVec2(qA, this.m_linearOffset));

  this.m_angularError = aB - aA - this.m_angularOffset;

  if (step.warmStarting) {
    // Scale impulses to support a variable time step.
    this.m_linearImpulse.mul(step.dtRatio);
    this.m_angularImpulse *= step.dtRatio;

    var P = Vec2.neo(this.m_linearImpulse.x, this.m_linearImpulse.y);

    vA.subMul(mA, P);
    wA -= iA * (Vec2.cross(this.m_rA, P) + this.m_angularImpulse);

    vB.addMul(mB, P);
    wB += iB * (Vec2.cross(this.m_rB, P) + this.m_angularImpulse);

  } else {
    this.m_linearImpulse.setZero();
    this.m_angularImpulse = 0.0;
  }

  this.m_bodyA.c_velocity.v = vA;
  this.m_bodyA.c_velocity.w = wA;
  this.m_bodyB.c_velocity.v = vB;
  this.m_bodyB.c_velocity.w = wB;
}

MotorJoint.prototype.solveVelocityConstraints = function(step) {
  var vA = this.m_bodyA.c_velocity.v;
  var wA = this.m_bodyA.c_velocity.w;
  var vB = this.m_bodyB.c_velocity.v;
  var wB = this.m_bodyB.c_velocity.w;

  var mA = this.m_invMassA, mB = this.m_invMassB;
  var iA = this.m_invIA, iB = this.m_invIB;

  var h = step.dt;
  var inv_h = step.inv_dt;

  // Solve angular friction
  {
    var Cdot = wB - wA + inv_h * this.m_correctionFactor * this.m_angularError;
    var impulse = -this.m_angularMass * Cdot;

    var oldImpulse = this.m_angularImpulse;
    var maxImpulse = h * this.m_maxTorque;
    this.m_angularImpulse = Math.clamp(this.m_angularImpulse + impulse,
        -maxImpulse, maxImpulse);
    impulse = this.m_angularImpulse - oldImpulse;

    wA -= iA * impulse;
    wB += iB * impulse;
  }

  // Solve linear friction
  {
    var Cdot = Vec2.zero();
    Cdot.addCombine(1, vB, 1, Vec2.cross(wB, this.m_rB));
    Cdot.subCombine(1, vA, 1, Vec2.cross(wA, this.m_rA));
    Cdot.addMul(inv_h * this.m_correctionFactor, this.m_linearError);

    var impulse = Vec2.neg(Mat22.mulVec2(this.m_linearMass, Cdot));
    var oldImpulse = Vec2.clone(this.m_linearImpulse);
    this.m_linearImpulse.add(impulse);

    var maxImpulse = h * this.m_maxForce;

    this.m_linearImpulse.clamp(maxImpulse);

    impulse = Vec2.sub(this.m_linearImpulse, oldImpulse);

    vA.subMul(mA, impulse);
    wA -= iA * Vec2.cross(this.m_rA, impulse);

    vB.addMul(mB, impulse);
    wB += iB * Vec2.cross(this.m_rB, impulse);
  }

  this.m_bodyA.c_velocity.v = vA;
  this.m_bodyA.c_velocity.w = wA;
  this.m_bodyB.c_velocity.v = vB;
  this.m_bodyB.c_velocity.w = wB;
}

MotorJoint.prototype.solvePositionConstraints = function(step) {
  return true;
}


/***/ }),
/* 105 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

module.exports = MouseJoint;

var common = __webpack_require__(61);
var options = __webpack_require__(60);
var create = __webpack_require__(64);

var Math = __webpack_require__(63);
var Vec2 = __webpack_require__(62);
var Vec3 = __webpack_require__(84);
var Mat22 = __webpack_require__(80);
var Mat33 = __webpack_require__(85);
var Rot = __webpack_require__(72);
var Sweep = __webpack_require__(73);
var Transform = __webpack_require__(74);
var Velocity = __webpack_require__(75);
var Position = __webpack_require__(76);

var Joint = __webpack_require__(86);
var Body = __webpack_require__(71);

MouseJoint.TYPE = 'mouse-joint';
Joint.TYPES[MouseJoint.TYPE] = MouseJoint;

MouseJoint._super = Joint;
MouseJoint.prototype = create(MouseJoint._super.prototype);

/**
 * @typedef {Object} MouseJointDef
 *
 * Mouse joint definition. This requires a world target point, tuning
 * parameters, and the time step.
 * 
 * @prop [maxForce = 0.0] The maximum constraint force that can be exerted to
 *       move the candidate body. Usually you will express as some multiple of
 *       the weight (multiplier * mass * gravity).
 * @prop [frequencyHz = 5.0] The response speed.
 * @prop [dampingRatio = 0.7] The damping ratio. 0 = no damping, 1 = critical
 *       damping.
 *
 * @prop {Vec2} target The initial world target point. This is assumed to
 *       coincide with the body anchor initially.
 */

var DEFAULTS = {
  maxForce : 0.0,
  frequencyHz : 5.0,
  dampingRatio : 0.7
};

/**
 * A mouse joint is used to make a point on a body track a specified world
 * point. This a soft constraint with a maximum force. This allows the
 * constraint to stretch and without applying huge forces.
 * 
 * NOTE: this joint is not documented in the manual because it was developed to
 * be used in the testbed. If you want to learn how to use the mouse joint, look
 * at the testbed.
 *
 * @param {MouseJointDef} def
 * @param {Body} bodyA
 * @param {Body} bodyB
 */
function MouseJoint(def, bodyA, bodyB, target) {
  if (!(this instanceof MouseJoint)) {
    return new MouseJoint(def, bodyA, bodyB, target);
  }

  def = options(def, DEFAULTS);
  Joint.call(this, def, bodyA, bodyB);
  bodyA = this.m_bodyA;
  bodyB = this.m_bodyB;

  this.m_type = MouseJoint.TYPE;

  _ASSERT && common.assert(Math.isFinite(def.maxForce) && def.maxForce >= 0.0);
  _ASSERT && common.assert(Math.isFinite(def.frequencyHz) && def.frequencyHz >= 0.0);
  _ASSERT && common.assert(Math.isFinite(def.dampingRatio) && def.dampingRatio >= 0.0);

  this.m_targetA = target ? Vec2.clone(target) : def.target || Vec2.zero();
  this.m_localAnchorB = Transform.mulTVec2(bodyB.getTransform(), this.m_targetA);

  this.m_maxForce = def.maxForce;
  this.m_impulse = Vec2.zero();

  this.m_frequencyHz = def.frequencyHz;
  this.m_dampingRatio = def.dampingRatio;

  this.m_beta = 0.0;
  this.m_gamma = 0.0;

  // Solver temp
  this.m_rB = Vec2.zero();
  this.m_localCenterB = Vec2.zero();
  this.m_invMassB = 0.0;
  this.m_invIB = 0.0;
  this.mass = new Mat22()
  this.m_C = Vec2.zero();

  // p = attached point, m = mouse point
  // C = p - m
  // Cdot = v
  // = v + cross(w, r)
  // J = [I r_skew]
  // Identity used:
  // w k % (rx i + ry j) = w * (-ry i + rx j)
}

MouseJoint.prototype._serialize = function() {
  return {
    type: this.m_type,
    bodyA: this.m_bodyA,
    bodyB: this.m_bodyB,
    collideConnected: this.m_collideConnected,

    target: this.m_targetA,
    maxForce: this.m_maxForce,
    frequencyHz: this.m_frequencyHz,
    dampingRatio: this.m_dampingRatio,

    _localAnchorB: this.m_localAnchorB,
  };
};

MouseJoint._deserialize = function(data, world, restore) {
  data = Object.assign({}, data);
  data.bodyA = restore(Body, data.bodyA, world);
  data.bodyB = restore(Body, data.bodyB, world);
  data.target = Vec2(data.target);
  var joint = new MouseJoint(data);
  if (data._localAnchorB) {
    joint.m_localAnchorB = data._localAnchorB;
  }
  return joint;
};

/**
 * Use this to update the target point.
 */
MouseJoint.prototype.setTarget = function(target) {
  if (this.m_bodyB.isAwake() == false) {
    this.m_bodyB.setAwake(true);
  }
  this.m_targetA = Vec2.clone(target);
}

MouseJoint.prototype.getTarget = function() {
  return this.m_targetA;
}

/**
 * Set/get the maximum force in Newtons.
 */
MouseJoint.prototype.setMaxForce = function(force) {
  this.m_maxForce = force;
}

MouseJoint.getMaxForce = function() {
  return this.m_maxForce;
}

/**
 * Set/get the frequency in Hertz.
 */
MouseJoint.prototype.setFrequency = function(hz) {
  this.m_frequencyHz = hz;
}

MouseJoint.prototype.getFrequency = function() {
  return this.m_frequencyHz;
}

/**
 * Set/get the damping ratio (dimensionless).
 */
MouseJoint.prototype.setDampingRatio = function(ratio) {
  this.m_dampingRatio = ratio;
}

MouseJoint.prototype.getDampingRatio = function() {
  return this.m_dampingRatio;
}

MouseJoint.prototype.getAnchorA = function() {
  return Vec2.clone(this.m_targetA);
}

MouseJoint.prototype.getAnchorB = function() {
  return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
}

MouseJoint.prototype.getReactionForce = function(inv_dt) {
  return Vec2.mul(inv_dt, this.m_impulse);
}

MouseJoint.prototype.getReactionTorque = function(inv_dt) {
  return inv_dt * 0.0;
}

MouseJoint.prototype.shiftOrigin = function(newOrigin) {
  this.m_targetA.sub(newOrigin);
}

MouseJoint.prototype.initVelocityConstraints = function(step) {
  this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
  this.m_invMassB = this.m_bodyB.m_invMass;
  this.m_invIB = this.m_bodyB.m_invI;

  var position = this.m_bodyB.c_position;
  var velocity = this.m_bodyB.c_velocity;

  var cB = position.c;
  var aB = position.a;
  var vB = velocity.v;
  var wB = velocity.w;

  var qB = Rot.neo(aB);

  var mass = this.m_bodyB.getMass();

  // Frequency
  var omega = 2.0 * Math.PI * this.m_frequencyHz;

  // Damping coefficient
  var d = 2.0 * mass * this.m_dampingRatio * omega;

  // Spring stiffness
  var k = mass * (omega * omega);

  // magic formulas
  // gamma has units of inverse mass.
  // beta has units of inverse time.
  var h = step.dt;
  _ASSERT && common.assert(d + h * k > Math.EPSILON);
  this.m_gamma = h * (d + h * k);
  if (this.m_gamma != 0.0) {
    this.m_gamma = 1.0 / this.m_gamma;
  }
  this.m_beta = h * k * this.m_gamma;

  // Compute the effective mass matrix.
  this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));

  // K = [(1/m1 + 1/m2) * eye(2) - skew(r1) * invI1 * skew(r1) - skew(r2) *
  // invI2 * skew(r2)]
  // = [1/m1+1/m2 0 ] + invI1 * [r1.y*r1.y -r1.x*r1.y] + invI2 * [r1.y*r1.y
  // -r1.x*r1.y]
  // [ 0 1/m1+1/m2] [-r1.x*r1.y r1.x*r1.x] [-r1.x*r1.y r1.x*r1.x]
  var K = new Mat22();
  K.ex.x = this.m_invMassB + this.m_invIB * this.m_rB.y * this.m_rB.y
      + this.m_gamma;
  K.ex.y = -this.m_invIB * this.m_rB.x * this.m_rB.y;
  K.ey.x = K.ex.y;
  K.ey.y = this.m_invMassB + this.m_invIB * this.m_rB.x * this.m_rB.x
      + this.m_gamma;

  this.m_mass = K.getInverse();

  this.m_C.set(cB);
  this.m_C.addCombine(1, this.m_rB, -1, this.m_targetA);
  this.m_C.mul(this.m_beta);

  // Cheat with some damping
  wB *= 0.98;

  if (step.warmStarting) {
    this.m_impulse.mul(step.dtRatio);
    vB.addMul(this.m_invMassB, this.m_impulse);
    wB += this.m_invIB * Vec2.cross(this.m_rB, this.m_impulse);

  } else {
    this.m_impulse.setZero();
  }

  velocity.v.set(vB);
  velocity.w = wB;
}

MouseJoint.prototype.solveVelocityConstraints = function(step) {
  var velocity = this.m_bodyB.c_velocity;
  var vB = Vec2.clone(velocity.v);
  var wB = velocity.w;

  // Cdot = v + cross(w, r)

  var Cdot = Vec2.cross(wB, this.m_rB);
  Cdot.add(vB);

  Cdot.addCombine(1, this.m_C, this.m_gamma, this.m_impulse);
  Cdot.neg();

  var impulse = Mat22.mulVec2(this.m_mass, Cdot);

  var oldImpulse = Vec2.clone(this.m_impulse);
  this.m_impulse.add(impulse);
  var maxImpulse = step.dt * this.m_maxForce;
  this.m_impulse.clamp(maxImpulse);
  impulse = Vec2.sub(this.m_impulse, oldImpulse);

  vB.addMul(this.m_invMassB, impulse);
  wB += this.m_invIB * Vec2.cross(this.m_rB, impulse);

  velocity.v.set(vB);
  velocity.w = wB;
}

MouseJoint.prototype.solvePositionConstraints = function(step) {
  return true;
}


/***/ }),
/* 106 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

module.exports = PulleyJoint;

var common = __webpack_require__(61);
var options = __webpack_require__(60);
var create = __webpack_require__(64);
var Settings = __webpack_require__(66);

var Math = __webpack_require__(63);
var Vec2 = __webpack_require__(62);
var Vec3 = __webpack_require__(84);
var Mat22 = __webpack_require__(80);
var Mat33 = __webpack_require__(85);
var Rot = __webpack_require__(72);
var Sweep = __webpack_require__(73);
var Transform = __webpack_require__(74);
var Velocity = __webpack_require__(75);
var Position = __webpack_require__(76);

var Joint = __webpack_require__(86);
var Body = __webpack_require__(71);

PulleyJoint.TYPE = 'pulley-joint';
PulleyJoint.MIN_PULLEY_LENGTH = 2.0; // minPulleyLength
Joint.TYPES[PulleyJoint.TYPE] = PulleyJoint;

PulleyJoint._super = Joint;
PulleyJoint.prototype = create(PulleyJoint._super.prototype);

/**
 * @typedef {Object} PulleyJointDef
 *
 * Pulley joint definition. This requires two ground anchors, two dynamic body
 * anchor points, and a pulley ratio.
 *
 * @prop {Vec2} groundAnchorA The first ground anchor in world coordinates.
 *          This point never moves.
 * @prop {Vec2} groundAnchorB The second ground anchor in world coordinates.
 *          This point never moves.
 * @prop {Vec2} localAnchorA The local anchor point relative to bodyA's origin.
 * @prop {Vec2} localAnchorB The local anchor point relative to bodyB's origin.
 * @prop {float} ratio The pulley ratio, used to simulate a block-and-tackle.
 * @prop {float} lengthA The reference length for the segment attached to bodyA.
 * @prop {float} lengthB The reference length for the segment attached to bodyB.
 */
var PulleyJointDef = {
  collideConnected : true
};

/**
 * The pulley joint is connected to two bodies and two fixed ground points. The
 * pulley supports a ratio such that: length1 + ratio * length2 <= constant
 * 
 * Yes, the force transmitted is scaled by the ratio.
 * 
 * Warning: the pulley joint can get a bit squirrelly by itself. They often work
 * better when combined with prismatic joints. You should also cover the the
 * anchor points with static shapes to prevent one side from going to zero
 * length.
 *
 * @param {PulleyJointDef} def
 * @param {Body} bodyA
 * @param {Body} bodyB
 */
function PulleyJoint(def, bodyA, bodyB, groundA, groundB, anchorA, anchorB, ratio) {
  if (!(this instanceof PulleyJoint)) {
    return new PulleyJoint(def, bodyA, bodyB, groundA, groundB, anchorA, anchorB, ratio);
  }

  def = options(def, PulleyJointDef);
  Joint.call(this, def, bodyA, bodyB);
  bodyA = this.m_bodyA;
  bodyB = this.m_bodyB;

  this.m_type = PulleyJoint.TYPE;
  this.m_groundAnchorA = groundA ? groundA : def.groundAnchorA || Vec2.neo(-1.0, 1.0);
  this.m_groundAnchorB = groundB ? groundB : def.groundAnchorB || Vec2.neo(1.0, 1.0);
  this.m_localAnchorA = anchorA ? bodyA.getLocalPoint(anchorA) : def.localAnchorA || Vec2.neo(-1.0, 0.0);
  this.m_localAnchorB = anchorB ? bodyB.getLocalPoint(anchorB) : def.localAnchorB || Vec2.neo(1.0, 0.0);
  this.m_lengthA = Math.isFinite(def.lengthA) ? def.lengthA : Vec2.distance(anchorA, groundA);
  this.m_lengthB = Math.isFinite(def.lengthB) ? def.lengthB : Vec2.distance(anchorB, groundB);
  this.m_ratio = Math.isFinite(ratio) ? ratio : def.ratio;

  _ASSERT && common.assert(ratio > Math.EPSILON);

  this.m_constant = this.m_lengthA + this.m_ratio * this.m_lengthB;

  this.m_impulse = 0.0;

  // Solver temp
  this.m_uA; // Vec2
  this.m_uB; // Vec2
  this.m_rA; // Vec2
  this.m_rB; // Vec2
  this.m_localCenterA; // Vec2
  this.m_localCenterB; // Vec2
  this.m_invMassA; // float
  this.m_invMassB; // float
  this.m_invIA; // float
  this.m_invIB; // float
  this.m_mass; // float

  // Pulley:
  // length1 = norm(p1 - s1)
  // length2 = norm(p2 - s2)
  // C0 = (length1 + ratio * length2)_initial
  // C = C0 - (length1 + ratio * length2)
  // u1 = (p1 - s1) / norm(p1 - s1)
  // u2 = (p2 - s2) / norm(p2 - s2)
  // Cdot = -dot(u1, v1 + cross(w1, r1)) - ratio * dot(u2, v2 + cross(w2, r2))
  // J = -[u1 cross(r1, u1) ratio * u2 ratio * cross(r2, u2)]
  // K = J * invM * JT
  // = invMass1 + invI1 * cross(r1, u1)^2 + ratio^2 * (invMass2 + invI2 *
  // cross(r2, u2)^2)
}

PulleyJoint.prototype._serialize = function() {
  return {
    type: this.m_type,
    bodyA: this.m_bodyA,
    bodyB: this.m_bodyB,
    collideConnected: this.m_collideConnected,

    groundAnchorA: this.m_groundAnchorA,
    groundAnchorB: this.m_groundAnchorB,
    localAnchorA: this.m_localAnchorA,
    localAnchorB: this.m_localAnchorB,
    lengthA: this.m_lengthA,
    lengthB: this.m_lengthB,
    ratio: this.m_ratio,
  };
};

PulleyJoint._deserialize = function(data, world, restore) {
  data = Object.assign({}, data);
  data.bodyA = restore(Body, data.bodyA, world);
  data.bodyB = restore(Body, data.bodyB, world);
  var joint = new PulleyJoint(data);
  return joint;
};

/**
 * Get the first ground anchor.
 */
PulleyJoint.prototype.getGroundAnchorA = function() {
  return this.m_groundAnchorA;
}

/**
 * Get the second ground anchor.
 */
PulleyJoint.prototype.getGroundAnchorB = function() {
  return this.m_groundAnchorB;
}

/**
 * Get the current length of the segment attached to bodyA.
 */
PulleyJoint.prototype.getLengthA = function() {
  return this.m_lengthA;
}

/**
 * Get the current length of the segment attached to bodyB.
 */
PulleyJoint.prototype.getLengthB = function() {
  return this.m_lengthB;
}

/**
 * Get the pulley ratio.
 */
PulleyJoint.prototype.getRatio = function() {
  return this.m_ratio;
}

/**
 * Get the current length of the segment attached to bodyA.
 */
PulleyJoint.prototype.getCurrentLengthA = function() {
  var p = this.m_bodyA.getWorldPoint(this.m_localAnchorA);
  var s = this.m_groundAnchorA;
  return Vec2.distance(p, s);
}

/**
 * Get the current length of the segment attached to bodyB.
 */
PulleyJoint.prototype.getCurrentLengthB = function() {
  var p = this.m_bodyB.getWorldPoint(this.m_localAnchorB);
  var s = this.m_groundAnchorB;
  return Vec2.distance(p, s);
}

PulleyJoint.prototype.shiftOrigin = function(newOrigin) {
  this.m_groundAnchorA.sub(newOrigin);
  this.m_groundAnchorB.sub(newOrigin);
}

PulleyJoint.prototype.getAnchorA = function() {
  return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
}

PulleyJoint.prototype.getAnchorB = function() {
  return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
}

PulleyJoint.prototype.getReactionForce = function(inv_dt) {
  return Vec2.mul(this.m_impulse, this.m_uB).mul(inv_dt);
}

PulleyJoint.prototype.getReactionTorque = function(inv_dt) {
  return 0.0;
}

PulleyJoint.prototype.initVelocityConstraints = function(step) {
  this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
  this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
  this.m_invMassA = this.m_bodyA.m_invMass;
  this.m_invMassB = this.m_bodyB.m_invMass;
  this.m_invIA = this.m_bodyA.m_invI;
  this.m_invIB = this.m_bodyB.m_invI;

  var cA = this.m_bodyA.c_position.c;
  var aA = this.m_bodyA.c_position.a;
  var vA = this.m_bodyA.c_velocity.v;
  var wA = this.m_bodyA.c_velocity.w;

  var cB = this.m_bodyB.c_position.c;
  var aB = this.m_bodyB.c_position.a;
  var vB = this.m_bodyB.c_velocity.v;
  var wB = this.m_bodyB.c_velocity.w;

  var qA = Rot.neo(aA);
  var qB = Rot.neo(aB);

  this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
  this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));

  // Get the pulley axes.
  this.m_uA = Vec2.sub(Vec2.add(cA, this.m_rA), this.m_groundAnchorA);
  this.m_uB = Vec2.sub(Vec2.add(cB, this.m_rB), this.m_groundAnchorB);

  var lengthA = this.m_uA.length();
  var lengthB = this.m_uB.length();

  if (lengthA > 10.0 * Settings.linearSlop) {
    this.m_uA.mul(1.0 / lengthA);
  } else {
    this.m_uA.setZero();
  }

  if (lengthB > 10.0 * Settings.linearSlop) {
    this.m_uB.mul(1.0 / lengthB);
  } else {
    this.m_uB.setZero();
  }

  // Compute effective mass.
  var ruA = Vec2.cross(this.m_rA, this.m_uA); // float
  var ruB = Vec2.cross(this.m_rB, this.m_uB); // float

  var mA = this.m_invMassA + this.m_invIA * ruA * ruA; // float
  var mB = this.m_invMassB + this.m_invIB * ruB * ruB; // float

  this.m_mass = mA + this.m_ratio * this.m_ratio * mB;

  if (this.m_mass > 0.0) {
    this.m_mass = 1.0 / this.m_mass;
  }

  if (step.warmStarting) {
    // Scale impulses to support variable time steps.
    this.m_impulse *= step.dtRatio;

    // Warm starting.
    var PA = Vec2.mul(-this.m_impulse, this.m_uA);
    var PB = Vec2.mul(-this.m_ratio * this.m_impulse, this.m_uB);

    vA.addMul(this.m_invMassA, PA);
    wA += this.m_invIA * Vec2.cross(this.m_rA, PA);

    vB.addMul(this.m_invMassB, PB);
    wB += this.m_invIB * Vec2.cross(this.m_rB, PB);

  } else {
    this.m_impulse = 0.0;
  }

  this.m_bodyA.c_velocity.v = vA;
  this.m_bodyA.c_velocity.w = wA;
  this.m_bodyB.c_velocity.v = vB;
  this.m_bodyB.c_velocity.w = wB;
}

PulleyJoint.prototype.solveVelocityConstraints = function(step) {
  var vA = this.m_bodyA.c_velocity.v;
  var wA = this.m_bodyA.c_velocity.w;
  var vB = this.m_bodyB.c_velocity.v;
  var wB = this.m_bodyB.c_velocity.w;

  var vpA = Vec2.add(vA, Vec2.cross(wA, this.m_rA));
  var vpB = Vec2.add(vB, Vec2.cross(wB, this.m_rB));

  var Cdot = -Vec2.dot(this.m_uA, vpA) - this.m_ratio
      * Vec2.dot(this.m_uB, vpB); // float
  var impulse = -this.m_mass * Cdot; // float
  this.m_impulse += impulse;

  var PA = Vec2.mul(-impulse, this.m_uA); // Vec2
  var PB = Vec2.mul(-this.m_ratio * impulse, this.m_uB); // Vec2
  vA.addMul(this.m_invMassA, PA);
  wA += this.m_invIA * Vec2.cross(this.m_rA, PA);
  vB.addMul(this.m_invMassB, PB);
  wB += this.m_invIB * Vec2.cross(this.m_rB, PB);

  this.m_bodyA.c_velocity.v = vA;
  this.m_bodyA.c_velocity.w = wA;
  this.m_bodyB.c_velocity.v = vB;
  this.m_bodyB.c_velocity.w = wB;
}

PulleyJoint.prototype.solvePositionConstraints = function(step) {
  var cA = this.m_bodyA.c_position.c;
  var aA = this.m_bodyA.c_position.a;
  var cB = this.m_bodyB.c_position.c;
  var aB = this.m_bodyB.c_position.a;

  var qA = Rot.neo(aA), qB = Rot.neo(aB);

  var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
  var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));

  // Get the pulley axes.
  var uA = Vec2.sub(Vec2.add(cA, this.m_rA), this.m_groundAnchorA);
  var uB = Vec2.sub(Vec2.add(cB, this.m_rB), this.m_groundAnchorB);

  var lengthA = uA.length();
  var lengthB = uB.length();

  if (lengthA > 10.0 * Settings.linearSlop) {
    uA.mul(1.0 / lengthA);
  } else {
    uA.setZero();
  }

  if (lengthB > 10.0 * Settings.linearSlop) {
    uB.mul(1.0 / lengthB);
  } else {
    uB.setZero();
  }

  // Compute effective mass.
  var ruA = Vec2.cross(rA, uA);
  var ruB = Vec2.cross(rB, uB);

  var mA = this.m_invMassA + this.m_invIA * ruA * ruA; // float
  var mB = this.m_invMassB + this.m_invIB * ruB * ruB; // float

  var mass = mA + this.m_ratio * this.m_ratio * mB; // float

  if (mass > 0.0) {
    mass = 1.0 / mass;
  }

  var C = this.m_constant - lengthA - this.m_ratio * lengthB; // float
  var linearError = Math.abs(C); // float

  var impulse = -mass * C; // float

  var PA = Vec2.mul(-impulse, uA); // Vec2
  var PB = Vec2.mul(-this.m_ratio * impulse, uB); // Vec2

  cA.addMul(this.m_invMassA, PA);
  aA += this.m_invIA * Vec2.cross(rA, PA);
  cB.addMul(this.m_invMassB, PB);
  aB += this.m_invIB * Vec2.cross(rB, PB);

  this.m_bodyA.c_position.c = cA;
  this.m_bodyA.c_position.a = aA;
  this.m_bodyB.c_position.c = cB;
  this.m_bodyB.c_position.a = aB;

  return linearError < Settings.linearSlop;
}


/***/ }),
/* 107 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

module.exports = RopeJoint;

var options = __webpack_require__(60);
var create = __webpack_require__(64);
var Settings = __webpack_require__(66);

var Math = __webpack_require__(63);
var Vec2 = __webpack_require__(62);
var Vec3 = __webpack_require__(84);
var Mat22 = __webpack_require__(80);
var Mat33 = __webpack_require__(85);
var Rot = __webpack_require__(72);
var Sweep = __webpack_require__(73);
var Transform = __webpack_require__(74);
var Velocity = __webpack_require__(75);
var Position = __webpack_require__(76);

var Joint = __webpack_require__(86);
var Body = __webpack_require__(71);

var inactiveLimit = 0;
var atLowerLimit = 1;
var atUpperLimit = 2;
var equalLimits = 3;

RopeJoint.TYPE = 'rope-joint';
Joint.TYPES[RopeJoint.TYPE] = RopeJoint;

RopeJoint._super = Joint;
RopeJoint.prototype = create(RopeJoint._super.prototype);

/**
 * @typedef {Object} RopeJointDef
 *
 * Rope joint definition. This requires two body anchor points and a maximum
 * lengths. Note: by default the connected objects will not collide. see
 * collideConnected in JointDef.
 *
 * @prop {float} maxLength The maximum length of the rope. Warning: this must be
 *       larger than linearSlop or the joint will have no effect.
 *
 * @prop {Vec2} def.localAnchorA The local anchor point relative to bodyA's origin.
 * @prop {Vec2} def.localAnchorB The local anchor point relative to bodyB's origin.
 */

var DEFAULTS = {
  maxLength : 0.0,
};

/**
 * A rope joint enforces a maximum distance between two points on two bodies. It
 * has no other effect.
 * 
 * Warning: if you attempt to change the maximum length during the simulation
 * you will get some non-physical behavior.
 * 
 * A model that would allow you to dynamically modify the length would have some
 * sponginess, so I chose not to implement it that way. See DistanceJoint if you
 * want to dynamically control length.
 *
 * @param {RopeJointDef} def
 * @param {Body} bodyA
 * @param {Body} bodyB
 */
function RopeJoint(def, bodyA, bodyB, anchor) {
  if (!(this instanceof RopeJoint)) {
    return new RopeJoint(def, bodyA, bodyB, anchor);
  }

  def = options(def, DEFAULTS);
  Joint.call(this, def, bodyA, bodyB);
  bodyA = this.m_bodyA;
  bodyB = this.m_bodyB;

  this.m_type = RopeJoint.TYPE;
  this.m_localAnchorA = anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.neo(-1.0, 0.0);
  this.m_localAnchorB = anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.neo(1.0, 0.0);

  this.m_maxLength = def.maxLength;

  this.m_mass = 0.0;
  this.m_impulse = 0.0;
  this.m_length = 0.0;
  this.m_state = inactiveLimit;

  // Solver temp
  this.m_u; // Vec2
  this.m_rA; // Vec2
  this.m_rB; // Vec2
  this.m_localCenterA; // Vec2
  this.m_localCenterB; // Vec2
  this.m_invMassA; // float
  this.m_invMassB; // float
  this.m_invIA; // float
  this.m_invIB; // float
  this.m_mass; // float

  // Limit:
  // C = norm(pB - pA) - L
  // u = (pB - pA) / norm(pB - pA)
  // Cdot = dot(u, vB + cross(wB, rB) - vA - cross(wA, rA))
  // J = [-u -cross(rA, u) u cross(rB, u)]
  // K = J * invM * JT
  // = invMassA + invIA * cross(rA, u)^2 + invMassB + invIB * cross(rB, u)^2
};

RopeJoint.prototype._serialize = function() {
  return {
    type: this.m_type,
    bodyA: this.m_bodyA,
    bodyB: this.m_bodyB,
    collideConnected: this.m_collideConnected,

    localAnchorA: this.m_localAnchorA,
    localAnchorB: this.m_localAnchorB,
    maxLength: this.m_maxLength,
  };
};

RopeJoint._deserialize = function(data, world, restore) {
  data = Object.assign({}, data);
  data.bodyA = restore(Body, data.bodyA, world);
  data.bodyB = restore(Body, data.bodyB, world);
  var joint = new RopeJoint(data);
  return joint;
};

/**
 * The local anchor point relative to bodyA's origin.
 */
RopeJoint.prototype.getLocalAnchorA = function() {
  return this.m_localAnchorA;
}

/**
 * The local anchor point relative to bodyB's origin.
 */
RopeJoint.prototype.getLocalAnchorB = function() {
  return this.m_localAnchorB;
}

/**
 * Set/Get the maximum length of the rope.
 */
RopeJoint.prototype.setMaxLength = function(length) {
  this.m_maxLength = length;
}

RopeJoint.prototype.getMaxLength = function() {
  return this.m_maxLength;
}

RopeJoint.prototype.getLimitState = function() {
  // TODO LimitState
  return this.m_state;
}

RopeJoint.prototype.getAnchorA = function() {
  return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
}

RopeJoint.prototype.getAnchorB = function() {
  return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
}

RopeJoint.prototype.getReactionForce = function(inv_dt) {
  return Vec2.mul(this.m_impulse, this.m_u).mul(inv_dt);
}

RopeJoint.prototype.getReactionTorque = function(inv_dt) {
  return 0.0;
}

RopeJoint.prototype.initVelocityConstraints = function(step) {
  this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
  this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
  this.m_invMassA = this.m_bodyA.m_invMass;
  this.m_invMassB = this.m_bodyB.m_invMass;
  this.m_invIA = this.m_bodyA.m_invI;
  this.m_invIB = this.m_bodyB.m_invI;

  var cA = this.m_bodyA.c_position.c;
  var aA = this.m_bodyA.c_position.a;
  var vA = this.m_bodyA.c_velocity.v;
  var wA = this.m_bodyA.c_velocity.w;

  var cB = this.m_bodyB.c_position.c;
  var aB = this.m_bodyB.c_position.a;
  var vB = this.m_bodyB.c_velocity.v;
  var wB = this.m_bodyB.c_velocity.w;

  var qA = Rot.neo(aA);
  var qB = Rot.neo(aB);

  this.m_rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);
  this.m_rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);
  this.m_u = Vec2.zero();
  this.m_u.addCombine(1, cB, 1, this.m_rB);
  this.m_u.subCombine(1, cA, 1, this.m_rA); // Vec2

  this.m_length = this.m_u.length();

  var C = this.m_length - this.m_maxLength; // float
  if (C > 0.0) {
    this.m_state = atUpperLimit;
  } else {
    this.m_state = inactiveLimit;
  }

  if (this.m_length > Settings.linearSlop) {
    this.m_u.mul(1.0 / this.m_length);
  } else {
    this.m_u.setZero();
    this.m_mass = 0.0;
    this.m_impulse = 0.0;
    return;
  }

  // Compute effective mass.
  var crA = Vec2.cross(this.m_rA, this.m_u); // float
  var crB = Vec2.cross(this.m_rB, this.m_u); // float
  var invMass = this.m_invMassA + this.m_invIA * crA * crA + this.m_invMassB
      + this.m_invIB * crB * crB; // float

  this.m_mass = invMass != 0.0 ? 1.0 / invMass : 0.0;

  if (step.warmStarting) {
    // Scale the impulse to support a variable time step.
    this.m_impulse *= step.dtRatio;

    var P = Vec2.mul(this.m_impulse, this.m_u);
    
    vA.subMul(this.m_invMassA, P);
    wA -= this.m_invIA * Vec2.cross(this.m_rA, P);
    
    vB.addMul(this.m_invMassB, P);
    wB += this.m_invIB * Vec2.cross(this.m_rB, P);
    
  } else {
    this.m_impulse = 0.0;
  }

  this.m_bodyA.c_velocity.v.set(vA);
  this.m_bodyA.c_velocity.w = wA;
  this.m_bodyB.c_velocity.v.set(vB);
  this.m_bodyB.c_velocity.w = wB;
}

RopeJoint.prototype.solveVelocityConstraints = function(step) {
  var vA = this.m_bodyA.c_velocity.v;
  var wA = this.m_bodyA.c_velocity.w;
  var vB = this.m_bodyB.c_velocity.v;
  var wB = this.m_bodyB.c_velocity.w;

  // Cdot = dot(u, v + cross(w, r))
  var vpA = Vec2.addCross(vA, wA, this.m_rA); // Vec2
  var vpB = Vec2.addCross(vB, wB, this.m_rB); // Vec2
  var C = this.m_length - this.m_maxLength; // float
  var Cdot = Vec2.dot(this.m_u, Vec2.sub(vpB, vpA)); // float

  // Predictive constraint.
  if (C < 0.0) {
    Cdot += step.inv_dt * C;
  }

  var impulse = -this.m_mass * Cdot; // float
  var oldImpulse = this.m_impulse; // float
  this.m_impulse = Math.min(0.0, this.m_impulse + impulse);
  impulse = this.m_impulse - oldImpulse;

  var P = Vec2.mul(impulse, this.m_u); // Vec2
  vA.subMul(this.m_invMassA, P);
  wA -= this.m_invIA * Vec2.cross(this.m_rA, P);
  vB.addMul(this.m_invMassB, P);
  wB += this.m_invIB * Vec2.cross(this.m_rB, P);

  this.m_bodyA.c_velocity.v = vA;
  this.m_bodyA.c_velocity.w = wA;
  this.m_bodyB.c_velocity.v = vB;
  this.m_bodyB.c_velocity.w = wB;
}

RopeJoint.prototype.solvePositionConstraints = function(step) {
  var cA = this.m_bodyA.c_position.c; // Vec2
  var aA = this.m_bodyA.c_position.a; // float
  var cB = this.m_bodyB.c_position.c; // Vec2
  var aB = this.m_bodyB.c_position.a; // float

  var qA = Rot.neo(aA);
  var qB = Rot.neo(aB);

  var rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);
  var rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);
  var u = Vec2.zero();
  u.addCombine(1, cB, 1, rB);
  u.subCombine(1, cA, 1, rA); // Vec2

  var length = u.normalize(); // float
  var C = length - this.m_maxLength; // float

  C = Math.clamp(C, 0.0, Settings.maxLinearCorrection);

  var impulse = -this.m_mass * C; // float
  var P = Vec2.mul(impulse, u); // Vec2

  cA.subMul(this.m_invMassA, P);
  aA -= this.m_invIA * Vec2.cross(rA, P);
  cB.addMul(this.m_invMassB, P);
  aB += this.m_invIB * Vec2.cross(rB, P);

  this.m_bodyA.c_position.c.set(cA);
  this.m_bodyA.c_position.a = aA;
  this.m_bodyB.c_position.c.set(cB);
  this.m_bodyB.c_position.a = aB;

  return length - this.m_maxLength < Settings.linearSlop;
}


/***/ }),
/* 108 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

module.exports = WeldJoint;

var options = __webpack_require__(60);
var create = __webpack_require__(64);
var Settings = __webpack_require__(66);

var Math = __webpack_require__(63);
var Vec2 = __webpack_require__(62);
var Vec3 = __webpack_require__(84);
var Mat22 = __webpack_require__(80);
var Mat33 = __webpack_require__(85);
var Rot = __webpack_require__(72);
var Sweep = __webpack_require__(73);
var Transform = __webpack_require__(74);
var Velocity = __webpack_require__(75);
var Position = __webpack_require__(76);

var Joint = __webpack_require__(86);
var Body = __webpack_require__(71);

WeldJoint.TYPE = 'weld-joint';
Joint.TYPES[WeldJoint.TYPE] = WeldJoint;

WeldJoint._super = Joint;
WeldJoint.prototype = create(WeldJoint._super.prototype);

/**
 * @typedef {Object} WeldJointDef
 *
 * Weld joint definition. You need to specify local anchor points where they are
 * attached and the relative body angle. The position of the anchor points is
 * important for computing the reaction torque.
 * 
 * @prop {float} frequencyHz The mass-spring-damper frequency in Hertz. Rotation
 *       only. Disable softness with a value of 0.
 * @prop {float} dampingRatio The damping ratio. 0 = no damping, 1 = critical
 *       damping.
 *
 * @prop {Vec2} localAnchorA The local anchor point relative to bodyA's origin.
 * @prop {Vec2} localAnchorB The local anchor point relative to bodyB's origin.
 * @prop {float} referenceAngle The bodyB angle minus bodyA angle in the
 *       reference state (radians).
 */
var DEFAULTS = {
  frequencyHz : 0.0,
  dampingRatio : 0.0,
}

/**
 * A weld joint essentially glues two bodies together. A weld joint may distort
 * somewhat because the island constraint solver is approximate.
 *
 * @param {WeldJointDef} def
 * @param {Body} bodyA
 * @param {Body} bodyB
 */
function WeldJoint(def, bodyA, bodyB, anchor) {
  if (!(this instanceof WeldJoint)) {
    return new WeldJoint(def, bodyA, bodyB, anchor);
  }

  def = options(def, DEFAULTS);
  Joint.call(this, def, bodyA, bodyB);
  bodyA = this.m_bodyA;
  bodyB = this.m_bodyB;

  this.m_type = WeldJoint.TYPE;

  this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());
  this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());
  this.m_referenceAngle = Math.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();

  this.m_frequencyHz = def.frequencyHz;
  this.m_dampingRatio = def.dampingRatio;

  this.m_impulse = Vec3();

  this.m_bias = 0.0;
  this.m_gamma = 0.0;

  // Solver temp
  this.m_rA; // Vec2
  this.m_rB; // Vec2
  this.m_localCenterA; // Vec2
  this.m_localCenterB; // Vec2
  this.m_invMassA; // float
  this.m_invMassB; // float
  this.m_invIA; // float
  this.m_invIB; // float
  this.m_mass = new Mat33();

  // Point-to-point constraint
  // C = p2 - p1
  // Cdot = v2 - v1
  // / = v2 + cross(w2, r2) - v1 - cross(w1, r1)
  // J = [-I -r1_skew I r2_skew ]
  // Identity used:
  // w k % (rx i + ry j) = w * (-ry i + rx j)

  // Angle constraint
  // C = angle2 - angle1 - referenceAngle
  // Cdot = w2 - w1
  // J = [0 0 -1 0 0 1]
  // K = invI1 + invI2
}

WeldJoint.prototype._serialize = function() {
  return {
    type: this.m_type,
    bodyA: this.m_bodyA,
    bodyB: this.m_bodyB,
    collideConnected: this.m_collideConnected,
    
    frequencyHz: this.m_frequencyHz,
    dampingRatio: this.m_dampingRatio,

    localAnchorA: this.m_localAnchorA,
    localAnchorB: this.m_localAnchorB,
    referenceAngle: this.m_referenceAngle,
  };
};

WeldJoint._deserialize = function(data, world, restore) {
  data = Object.assign({}, data);
  data.bodyA = restore(Body, data.bodyA, world);
  data.bodyB = restore(Body, data.bodyB, world);
  var joint = new WeldJoint(data);
  return joint;
};

/**
 * @internal
 */
WeldJoint.prototype._setAnchors = function(def) {
  if (def.anchorA) {
    this.m_localAnchorA.set(this.m_bodyA.getLocalPoint(def.anchorA));
  } else if (def.localAnchorA) {
    this.m_localAnchorA.set(def.localAnchorA);
  }

  if (def.anchorB) {
    this.m_localAnchorB.set(this.m_bodyB.getLocalPoint(def.anchorB));
  } else if (def.localAnchorB) {
    this.m_localAnchorB.set(def.localAnchorB);
  }
}

/**
 * The local anchor point relative to bodyA's origin.
 */
WeldJoint.prototype.getLocalAnchorA = function() {
  return this.m_localAnchorA;
};

/**
 * The local anchor point relative to bodyB's origin.
 */
WeldJoint.prototype.getLocalAnchorB = function() {
  return this.m_localAnchorB;
};

/**
 * Get the reference angle.
 */
WeldJoint.prototype.getReferenceAngle = function() {
  return this.m_referenceAngle;
};

/**
 * Set/get frequency in Hz.
 */
WeldJoint.prototype.setFrequency = function(hz) {
  this.m_frequencyHz = hz;
};

WeldJoint.prototype.getFrequency = function() {
  return this.m_frequencyHz;
};

/**
 * Set/get damping ratio.
 */
WeldJoint.prototype.setDampingRatio = function(ratio) {
  this.m_dampingRatio = ratio;
};

WeldJoint.prototype.getDampingRatio = function() {
  return this.m_dampingRatio;
};

WeldJoint.prototype.getAnchorA = function() {
  return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
};

WeldJoint.prototype.getAnchorB = function() {
  return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
};

WeldJoint.prototype.getReactionForce = function(inv_dt) {
  return Vec2.neo(this.m_impulse.x, this.m_impulse.y).mul(inv_dt);
};

WeldJoint.prototype.getReactionTorque = function(inv_dt) {
  return inv_dt * this.m_impulse.z;
};

WeldJoint.prototype.initVelocityConstraints = function(step) {
  this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
  this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
  this.m_invMassA = this.m_bodyA.m_invMass;
  this.m_invMassB = this.m_bodyB.m_invMass;
  this.m_invIA = this.m_bodyA.m_invI;
  this.m_invIB = this.m_bodyB.m_invI;

  var aA = this.m_bodyA.c_position.a;
  var vA = this.m_bodyA.c_velocity.v;
  var wA = this.m_bodyA.c_velocity.w;

  var aB = this.m_bodyB.c_position.a;
  var vB = this.m_bodyB.c_velocity.v;
  var wB = this.m_bodyB.c_velocity.w;

  var qA = Rot.neo(aA), qB = Rot.neo(aB);

  this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
  this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));

  // J = [-I -r1_skew I r2_skew]
  // [ 0 -1 0 1]
  // r_skew = [-ry; rx]

  // Matlab
  // K = [ mA+r1y^2*iA+mB+r2y^2*iB, -r1y*iA*r1x-r2y*iB*r2x, -r1y*iA-r2y*iB]
  // [ -r1y*iA*r1x-r2y*iB*r2x, mA+r1x^2*iA+mB+r2x^2*iB, r1x*iA+r2x*iB]
  // [ -r1y*iA-r2y*iB, r1x*iA+r2x*iB, iA+iB]

  var mA = this.m_invMassA;
  var mB = this.m_invMassB; // float
  var iA = this.m_invIA;
  var iB = this.m_invIB; // float

  var K = new Mat33();
  K.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y * this.m_rB.y
      * iB;
  K.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y * this.m_rB.x * iB;
  K.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;
  K.ex.y = K.ey.x;
  K.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x * this.m_rB.x
      * iB;
  K.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;
  K.ex.z = K.ez.x;
  K.ey.z = K.ez.y;
  K.ez.z = iA + iB;

  if (this.m_frequencyHz > 0.0) {
    K.getInverse22(this.m_mass);

    var invM = iA + iB; // float
    var m = invM > 0.0 ? 1.0 / invM : 0.0; // float

    var C = aB - aA - this.m_referenceAngle; // float

    // Frequency
    var omega = 2.0 * Math.PI * this.m_frequencyHz; // float

    // Damping coefficient
    var d = 2.0 * m * this.m_dampingRatio * omega; // float

    // Spring stiffness
    var k = m * omega * omega; // float

    // magic formulas
    var h = step.dt; // float
    this.m_gamma = h * (d + h * k);
    this.m_gamma = this.m_gamma != 0.0 ? 1.0 / this.m_gamma : 0.0;
    this.m_bias = C * h * k * this.m_gamma;

    invM += this.m_gamma;
    this.m_mass.ez.z = invM != 0.0 ? 1.0 / invM : 0.0;
  } else if (K.ez.z == 0.0) {
    K.getInverse22(this.m_mass);
    this.m_gamma = 0.0;
    this.m_bias = 0.0;
  } else {
    K.getSymInverse33(this.m_mass);
    this.m_gamma = 0.0;
    this.m_bias = 0.0;
  }

  if (step.warmStarting) {
    // Scale impulses to support a variable time step.
    this.m_impulse.mul(step.dtRatio);

    var P = Vec2.neo(this.m_impulse.x, this.m_impulse.y);

    vA.subMul(mA, P);
    wA -= iA * (Vec2.cross(this.m_rA, P) + this.m_impulse.z);

    vB.addMul(mB, P);
    wB += iB * (Vec2.cross(this.m_rB, P) + this.m_impulse.z);

  } else {
    this.m_impulse.setZero();
  }

  this.m_bodyA.c_velocity.v = vA;
  this.m_bodyA.c_velocity.w = wA;
  this.m_bodyB.c_velocity.v = vB;
  this.m_bodyB.c_velocity.w = wB;
}

WeldJoint.prototype.solveVelocityConstraints = function(step) {
  var vA = this.m_bodyA.c_velocity.v;
  var wA = this.m_bodyA.c_velocity.w;
  var vB = this.m_bodyB.c_velocity.v;
  var wB = this.m_bodyB.c_velocity.w;

  var mA = this.m_invMassA;
  var mB = this.m_invMassB; // float
  var iA = this.m_invIA;
  var iB = this.m_invIB; // float

  if (this.m_frequencyHz > 0.0) {
    var Cdot2 = wB - wA; // float

    var impulse2 = -this.m_mass.ez.z
        * (Cdot2 + this.m_bias + this.m_gamma * this.m_impulse.z); // float
    this.m_impulse.z += impulse2;

    wA -= iA * impulse2;
    wB += iB * impulse2;

    var Cdot1 = Vec2.zero();
    Cdot1.addCombine(1, vB, 1, Vec2.cross(wB, this.m_rB));
    Cdot1.subCombine(1, vA, 1, Vec2.cross(wA, this.m_rA)); // Vec2

    var impulse1 = Vec2.neg(Mat33.mulVec2(this.m_mass, Cdot1)); // Vec2
    this.m_impulse.x += impulse1.x;
    this.m_impulse.y += impulse1.y;

    var P = Vec2.clone(impulse1); // Vec2

    vA.subMul(mA, P);
    wA -= iA * Vec2.cross(this.m_rA, P);

    vB.addMul(mB, P);
    wB += iB * Vec2.cross(this.m_rB, P);
  } else {
    var Cdot1 = Vec2.zero();
    Cdot1.addCombine(1, vB, 1, Vec2.cross(wB, this.m_rB));
    Cdot1.subCombine(1, vA, 1, Vec2.cross(wA, this.m_rA)); // Vec2
    var Cdot2 = wB - wA; // float
    var Cdot = Vec3(Cdot1.x, Cdot1.y, Cdot2); // Vec3

    var impulse = Vec3.neg(Mat33.mulVec3(this.m_mass, Cdot)); // Vec3
    this.m_impulse.add(impulse);

    var P = Vec2.neo(impulse.x, impulse.y);

    vA.subMul(mA, P);
    wA -= iA * (Vec2.cross(this.m_rA, P) + impulse.z);

    vB.addMul(mB, P);
    wB += iB * (Vec2.cross(this.m_rB, P) + impulse.z);
  }

  this.m_bodyA.c_velocity.v = vA;
  this.m_bodyA.c_velocity.w = wA;
  this.m_bodyB.c_velocity.v = vB;
  this.m_bodyB.c_velocity.w = wB;
}

WeldJoint.prototype.solvePositionConstraints = function(step) {
  var cA = this.m_bodyA.c_position.c;
  var aA = this.m_bodyA.c_position.a;
  var cB = this.m_bodyB.c_position.c;
  var aB = this.m_bodyB.c_position.a;

  var qA = Rot.neo(aA), qB = Rot.neo(aB);

  var mA = this.m_invMassA, mB = this.m_invMassB; // float
  var iA = this.m_invIA, iB = this.m_invIB; // float

  var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
  var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));

  var positionError, angularError; // float

  var K = new Mat33();
  K.ex.x = mA + mB + rA.y * rA.y * iA + rB.y * rB.y * iB;
  K.ey.x = -rA.y * rA.x * iA - rB.y * rB.x * iB;
  K.ez.x = -rA.y * iA - rB.y * iB;
  K.ex.y = K.ey.x;
  K.ey.y = mA + mB + rA.x * rA.x * iA + rB.x * rB.x * iB;
  K.ez.y = rA.x * iA + rB.x * iB;
  K.ex.z = K.ez.x;
  K.ey.z = K.ez.y;
  K.ez.z = iA + iB;

  if (this.m_frequencyHz > 0.0) {
    var C1 = Vec2.zero();
    C1.addCombine(1, cB, 1, rB);
    C1.subCombine(1, cA, 1, rA); // Vec2

    positionError = C1.length();
    angularError = 0.0;

    var P = Vec2.neg(K.solve22(C1)); // Vec2

    cA.subMul(mA, P);
    aA -= iA * Vec2.cross(rA, P);

    cB.addMul(mB, P);
    aB += iB * Vec2.cross(rB, P);
  } else {
    var C1 = Vec2.zero();
    C1.addCombine(1, cB, 1, rB);
    C1.subCombine(1, cA, 1, rA);

    var C2 = aB - aA - this.m_referenceAngle; // float

    positionError = C1.length();
    angularError = Math.abs(C2);

    var C = Vec3(C1.x, C1.y, C2);

    var impulse = Vec3();
    if (K.ez.z > 0.0) {
      impulse = Vec3.neg(K.solve33(C));
    } else {
      var impulse2 = Vec2.neg(K.solve22(C1));
      impulse.set(impulse2.x, impulse2.y, 0.0);
    }

    var P = Vec2.neo(impulse.x, impulse.y);

    cA.subMul(mA, P);
    aA -= iA * (Vec2.cross(rA, P) + impulse.z);

    cB.addMul(mB, P);
    aB += iB * (Vec2.cross(rB, P) + impulse.z);
  }

  this.m_bodyA.c_position.c = cA;
  this.m_bodyA.c_position.a = aA;
  this.m_bodyB.c_position.c = cB;
  this.m_bodyB.c_position.a = aB;

  return positionError <= Settings.linearSlop
      && angularError <= Settings.angularSlop;
}


/***/ }),
/* 109 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * Planck.js
 * The MIT License
 * Copyright (c) 2021 Erin Catto, Ali Shakiba
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

var _DEBUG = typeof DEBUG === 'undefined' ? false : DEBUG;
var _ASSERT = typeof ASSERT === 'undefined' ? false : ASSERT;

module.exports = WheelJoint;

var options = __webpack_require__(60);
var create = __webpack_require__(64);
var Settings = __webpack_require__(66);

var Math = __webpack_require__(63);
var Vec2 = __webpack_require__(62);
var Vec3 = __webpack_require__(84);
var Mat22 = __webpack_require__(80);
var Mat33 = __webpack_require__(85);
var Rot = __webpack_require__(72);
var Sweep = __webpack_require__(73);
var Transform = __webpack_require__(74);
var Velocity = __webpack_require__(75);
var Position = __webpack_require__(76);

var Joint = __webpack_require__(86);
var Body = __webpack_require__(71);

WheelJoint.TYPE = 'wheel-joint';
Joint.TYPES[WheelJoint.TYPE] = WheelJoint;

WheelJoint._super = Joint;
WheelJoint.prototype = create(WheelJoint._super.prototype);

/**
 * @typedef {Object} WheelJointDef
 *
 * Wheel joint definition. This requires defining a line of motion using an axis
 * and an anchor point. The definition uses local anchor points and a local axis
 * so that the initial configuration can violate the constraint slightly. The
 * joint translation is zero when the local anchor points coincide in world
 * space. Using local anchors and a local axis helps when saving and loading a
 * game.
 *
 * @prop {boolean} enableMotor Enable/disable the joint motor.
 * @prop {float} maxMotorTorque The maximum motor torque, usually in N-m.
 * @prop {float} motorSpeed The desired motor speed in radians per second.
 * @prop {float} frequencyHz Suspension frequency, zero indicates no suspension.
 * @prop {float} dampingRatio Suspension damping ratio, one indicates critical
 *       damping.
 *
 * @prop {Vec2} localAnchorA The local anchor point relative to bodyA's origin.
 * @prop {Vec2} localAnchorB The local anchor point relative to bodyB's origin.
 * @prop {Vec2} localAxisA The local translation axis in bodyA.
 */
var DEFAULTS = {
  enableMotor : false,
  maxMotorTorque : 0.0,
  motorSpeed : 0.0,
  frequencyHz : 2.0,
  dampingRatio : 0.7,
};

/**
 * A wheel joint. This joint provides two degrees of freedom: translation along
 * an axis fixed in bodyA and rotation in the plane. In other words, it is a
 * point to line constraint with a rotational motor and a linear spring/damper.
 * This joint is designed for vehicle suspensions.
 *
 * @param {WheelJointDef} def
 * @param {Body} bodyA
 * @param {Body} bodyB
 */
function WheelJoint(def, bodyA, bodyB, anchor, axis) {
  if (!(this instanceof WheelJoint)) {
    return new WheelJoint(def, bodyA, bodyB, anchor, axis);
  }

  def = options(def, DEFAULTS);
  Joint.call(this, def, bodyA, bodyB);
  bodyA = this.m_bodyA;
  bodyB = this.m_bodyB;

  this.m_type = WheelJoint.TYPE;

  this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());
  this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());
  this.m_localXAxisA = Vec2.clone(axis ? bodyA.getLocalVector(axis) : def.localAxisA || def.localAxis || Vec2.neo(1.0, 0.0));
  this.m_localYAxisA = Vec2.cross(1.0, this.m_localXAxisA);

  this.m_mass = 0.0;
  this.m_impulse = 0.0;
  this.m_motorMass = 0.0;
  this.m_motorImpulse = 0.0;
  this.m_springMass = 0.0;
  this.m_springImpulse = 0.0;

  this.m_maxMotorTorque = def.maxMotorTorque;
  this.m_motorSpeed = def.motorSpeed;
  this.m_enableMotor = def.enableMotor;

  this.m_frequencyHz = def.frequencyHz;
  this.m_dampingRatio = def.dampingRatio;

  this.m_bias = 0.0;
  this.m_gamma = 0.0;

  // Solver temp
  this.m_localCenterA; // Vec2
  this.m_localCenterB; // Vec2
  this.m_invMassA; // float
  this.m_invMassB; // float
  this.m_invIA; // float
  this.m_invIB; // float

  this.m_ax = Vec2.zero();
  this.m_ay = Vec2.zero(); // Vec2
  this.m_sAx;
  this.m_sBx; // float
  this.m_sAy;
  this.m_sBy; // float

  // Linear constraint (point-to-line)
  // d = pB - pA = xB + rB - xA - rA
  // C = dot(ay, d)
  // Cdot = dot(d, cross(wA, ay)) + dot(ay, vB + cross(wB, rB) - vA - cross(wA,
  // rA))
  // = -dot(ay, vA) - dot(cross(d + rA, ay), wA) + dot(ay, vB) + dot(cross(rB,
  // ay), vB)
  // J = [-ay, -cross(d + rA, ay), ay, cross(rB, ay)]

  // Spring linear constraint
  // C = dot(ax, d)
  // Cdot = = -dot(ax, vA) - dot(cross(d + rA, ax), wA) + dot(ax, vB) +
  // dot(cross(rB, ax), vB)
  // J = [-ax -cross(d+rA, ax) ax cross(rB, ax)]

  // Motor rotational constraint
  // Cdot = wB - wA
  // J = [0 0 -1 0 0 1]
}

WheelJoint.prototype._serialize = function() {
  return {
    type: this.m_type,
    bodyA: this.m_bodyA,
    bodyB: this.m_bodyB,
    collideConnected: this.m_collideConnected,

    enableMotor: this.m_enableMotor,
    maxMotorTorque: this.m_maxMotorTorque,
    motorSpeed: this.m_motorSpeed,
    frequencyHz: this.m_frequencyHz,
    dampingRatio: this.m_dampingRatio,

    localAnchorA: this.m_localAnchorA,
    localAnchorB: this.m_localAnchorB,
    localAxisA: this.m_localXAxisA,
  };
};

WheelJoint._deserialize = function(data, world, restore) {
  data = Object.assign({}, data);
  data.bodyA = restore(Body, data.bodyA, world);
  data.bodyB = restore(Body, data.bodyB, world);
  var joint = new WheelJoint(data);
  return joint;
};

/**
 * @internal
 */
WheelJoint.prototype._setAnchors = function(def) {
  if (def.anchorA) {
    this.m_localAnchorA.set(this.m_bodyA.getLocalPoint(def.anchorA));
  } else if (def.localAnchorA) {
    this.m_localAnchorA.set(def.localAnchorA);
  }

  if (def.anchorB) {
    this.m_localAnchorB.set(this.m_bodyB.getLocalPoint(def.anchorB));
  } else if (def.localAnchorB) {
    this.m_localAnchorB.set(def.localAnchorB);
  }

  if (def.localAxisA) {
    this.m_localXAxisA.set(def.localAxisA);
    this.m_localYAxisA.set(Vec2.cross(1.0, def.localAxisA));
  }
}

/**
 * The local anchor point relative to bodyA's origin.
 */
WheelJoint.prototype.getLocalAnchorA = function() {
  return this.m_localAnchorA;
}

/**
 * The local anchor point relative to bodyB's origin.
 */
WheelJoint.prototype.getLocalAnchorB = function() {
  return this.m_localAnchorB;
}

/**
 * The local joint axis relative to bodyA.
 */
WheelJoint.prototype.getLocalAxisA = function() {
  return this.m_localXAxisA;
}

/**
 * Get the current joint translation, usually in meters.
 */
WheelJoint.prototype.getJointTranslation = function() {
  var bA = this.m_bodyA;
  var bB = this.m_bodyB;

  var pA = bA.getWorldPoint(this.m_localAnchorA); // Vec2
  var pB = bB.getWorldPoint(this.m_localAnchorB); // Vec2
  var d = Vec2.sub(pB, pA); // Vec2
  var axis = bA.getWorldVector(this.m_localXAxisA); // Vec2

  var translation = Vec2.dot(d, axis); // float
  return translation;
}

/**
 * Get the current joint translation speed, usually in meters per second.
 */
WheelJoint.prototype.getJointSpeed = function() {
  var wA = this.m_bodyA.m_angularVelocity;
  var wB = this.m_bodyB.m_angularVelocity;
  return wB - wA;
}

/**
 * Is the joint motor enabled?
 */
WheelJoint.prototype.isMotorEnabled = function() {
  return this.m_enableMotor;
}

/**
 * Enable/disable the joint motor.
 */
WheelJoint.prototype.enableMotor = function(flag) {
  this.m_bodyA.setAwake(true);
  this.m_bodyB.setAwake(true);
  this.m_enableMotor = flag;
}

/**
 * Set the motor speed, usually in radians per second.
 */
WheelJoint.prototype.setMotorSpeed = function(speed) {
  this.m_bodyA.setAwake(true);
  this.m_bodyB.setAwake(true);
  this.m_motorSpeed = speed;
}

/**
 * Get the motor speed, usually in radians per second.
 */
WheelJoint.prototype.getMotorSpeed = function() {
  return this.m_motorSpeed;
}

/**
 * Set/Get the maximum motor force, usually in N-m.
 */
WheelJoint.prototype.setMaxMotorTorque = function(torque) {
  this.m_bodyA.setAwake(true);
  this.m_bodyB.setAwake(true);
  this.m_maxMotorTorque = torque;
}

WheelJoint.prototype.getMaxMotorTorque = function() {
  return this.m_maxMotorTorque;
}

/**
 * Get the current motor torque given the inverse time step, usually in N-m.
 */
WheelJoint.prototype.getMotorTorque = function(inv_dt) {
  return inv_dt * this.m_motorImpulse;
}

/**
 * Set/Get the spring frequency in hertz. Setting the frequency to zero disables
 * the spring.
 */
WheelJoint.prototype.setSpringFrequencyHz = function(hz) {
  this.m_frequencyHz = hz;
}

WheelJoint.prototype.getSpringFrequencyHz = function() {
  return this.m_frequencyHz;
}

/**
 * Set/Get the spring damping ratio
 */
WheelJoint.prototype.setSpringDampingRatio = function(ratio) {
  this.m_dampingRatio = ratio;
}

WheelJoint.prototype.getSpringDampingRatio = function() {
  return this.m_dampingRatio;
}

WheelJoint.prototype.getAnchorA = function() {
  return this.m_bodyA.getWorldPoint(this.m_localAnchorA);
}

WheelJoint.prototype.getAnchorB = function() {
  return this.m_bodyB.getWorldPoint(this.m_localAnchorB);
}

WheelJoint.prototype.getReactionForce = function(inv_dt) {
  return Vec2.combine(this.m_impulse, this.m_ay, this.m_springImpulse, this.m_ax).mul(inv_dt);
}

WheelJoint.prototype.getReactionTorque = function(inv_dt) {
  return inv_dt * this.m_motorImpulse;
}

WheelJoint.prototype.initVelocityConstraints = function(step) {
  this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;
  this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;
  this.m_invMassA = this.m_bodyA.m_invMass;
  this.m_invMassB = this.m_bodyB.m_invMass;
  this.m_invIA = this.m_bodyA.m_invI;
  this.m_invIB = this.m_bodyB.m_invI;

  var mA = this.m_invMassA;
  var mB = this.m_invMassB; // float
  var iA = this.m_invIA;
  var iB = this.m_invIB; // float

  var cA = this.m_bodyA.c_position.c;
  var aA = this.m_bodyA.c_position.a;
  var vA = this.m_bodyA.c_velocity.v;
  var wA = this.m_bodyA.c_velocity.w;

  var cB = this.m_bodyB.c_position.c;
  var aB = this.m_bodyB.c_position.a;
  var vB = this.m_bodyB.c_velocity.v;
  var wB = this.m_bodyB.c_velocity.w;

  var qA = Rot.neo(aA);
  var qB = Rot.neo(aB);

  // Compute the effective masses.
  var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
  var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
  var d = Vec2.zero();
  d.addCombine(1, cB, 1, rB);
  d.subCombine(1, cA, 1, rA); // Vec2

  // Point to line constraint
  {
    this.m_ay = Rot.mulVec2(qA, this.m_localYAxisA);
    this.m_sAy = Vec2.cross(Vec2.add(d, rA), this.m_ay);
    this.m_sBy = Vec2.cross(rB, this.m_ay);

    this.m_mass = mA + mB + iA * this.m_sAy * this.m_sAy + iB * this.m_sBy
        * this.m_sBy;

    if (this.m_mass > 0.0) {
      this.m_mass = 1.0 / this.m_mass;
    }
  }

  // Spring constraint
  this.m_springMass = 0.0;
  this.m_bias = 0.0;
  this.m_gamma = 0.0;
  if (this.m_frequencyHz > 0.0) {
    this.m_ax = Rot.mulVec2(qA, this.m_localXAxisA);
    this.m_sAx = Vec2.cross(Vec2.add(d, rA), this.m_ax);
    this.m_sBx = Vec2.cross(rB, this.m_ax);

    var invMass = mA + mB + iA * this.m_sAx * this.m_sAx + iB * this.m_sBx
        * this.m_sBx; // float

    if (invMass > 0.0) {
      this.m_springMass = 1.0 / invMass;

      var C = Vec2.dot(d, this.m_ax); // float

      // Frequency
      var omega = 2.0 * Math.PI * this.m_frequencyHz; // float

      // Damping coefficient
      var d = 2.0 * this.m_springMass * this.m_dampingRatio * omega; // float

      // Spring stiffness
      var k = this.m_springMass * omega * omega; // float

      // magic formulas
      var h = step.dt; // float
      this.m_gamma = h * (d + h * k);
      if (this.m_gamma > 0.0) {
        this.m_gamma = 1.0 / this.m_gamma;
      }

      this.m_bias = C * h * k * this.m_gamma;

      this.m_springMass = invMass + this.m_gamma;
      if (this.m_springMass > 0.0) {
        this.m_springMass = 1.0 / this.m_springMass;
      }
    }
  } else {
    this.m_springImpulse = 0.0;
  }

  // Rotational motor
  if (this.m_enableMotor) {
    this.m_motorMass = iA + iB;
    if (this.m_motorMass > 0.0) {
      this.m_motorMass = 1.0 / this.m_motorMass;
    }
  } else {
    this.m_motorMass = 0.0;
    this.m_motorImpulse = 0.0;
  }

  if (step.warmStarting) {
    // Account for variable time step.
    this.m_impulse *= step.dtRatio;
    this.m_springImpulse *= step.dtRatio;
    this.m_motorImpulse *= step.dtRatio;

    var P = Vec2.combine(this.m_impulse, this.m_ay, this.m_springImpulse, this.m_ax);
    var LA = this.m_impulse * this.m_sAy + this.m_springImpulse * this.m_sAx + this.m_motorImpulse;
    var LB = this.m_impulse * this.m_sBy + this.m_springImpulse * this.m_sBx + this.m_motorImpulse;

    vA.subMul(this.m_invMassA, P);
    wA -= this.m_invIA * LA;

    vB.addMul(this.m_invMassB, P);
    wB += this.m_invIB * LB;

  } else {
    this.m_impulse = 0.0;
    this.m_springImpulse = 0.0;
    this.m_motorImpulse = 0.0;
  }

  this.m_bodyA.c_velocity.v.set(vA);
  this.m_bodyA.c_velocity.w = wA;
  this.m_bodyB.c_velocity.v.set(vB);
  this.m_bodyB.c_velocity.w = wB;
}

WheelJoint.prototype.solveVelocityConstraints = function(step) {
  var mA = this.m_invMassA;
  var mB = this.m_invMassB; // float
  var iA = this.m_invIA;
  var iB = this.m_invIB; // float

  var vA = this.m_bodyA.c_velocity.v;
  var wA = this.m_bodyA.c_velocity.w;
  var vB = this.m_bodyB.c_velocity.v;
  var wB = this.m_bodyB.c_velocity.w;

  // Solve spring constraint
  {
    var Cdot = Vec2.dot(this.m_ax, vB) - Vec2.dot(this.m_ax, vA) + this.m_sBx
        * wB - this.m_sAx * wA; // float
    var impulse = -this.m_springMass
        * (Cdot + this.m_bias + this.m_gamma * this.m_springImpulse); // float
    this.m_springImpulse += impulse;

    var P = Vec2.mul(impulse, this.m_ax); // Vec2
    var LA = impulse * this.m_sAx; // float
    var LB = impulse * this.m_sBx; // float

    vA.subMul(mA, P);
    wA -= iA * LA;

    vB.addMul(mB, P);
    wB += iB * LB;
  }

  // Solve rotational motor constraint
  {
    var Cdot = wB - wA - this.m_motorSpeed; // float
    var impulse = -this.m_motorMass * Cdot; // float

    var oldImpulse = this.m_motorImpulse; // float
    var maxImpulse = step.dt * this.m_maxMotorTorque; // float
    this.m_motorImpulse = Math.clamp(this.m_motorImpulse + impulse,
        -maxImpulse, maxImpulse);
    impulse = this.m_motorImpulse - oldImpulse;

    wA -= iA * impulse;
    wB += iB * impulse;
  }

  // Solve point to line constraint
  {
    var Cdot = Vec2.dot(this.m_ay, vB) - Vec2.dot(this.m_ay, vA) + this.m_sBy
        * wB - this.m_sAy * wA; // float
    var impulse = -this.m_mass * Cdot; // float
    this.m_impulse += impulse;

    var P = Vec2.mul(impulse, this.m_ay); // Vec2
    var LA = impulse * this.m_sAy; // float
    var LB = impulse * this.m_sBy; // float

    vA.subMul(mA, P);
    wA -= iA * LA;

    vB.addMul(mB, P);
    wB += iB * LB;
  }

  this.m_bodyA.c_velocity.v.set(vA);
  this.m_bodyA.c_velocity.w = wA;
  this.m_bodyB.c_velocity.v.set(vB);
  this.m_bodyB.c_velocity.w = wB;
}

WheelJoint.prototype.solvePositionConstraints = function(step) {
  var cA = this.m_bodyA.c_position.c;
  var aA = this.m_bodyA.c_position.a;
  var cB = this.m_bodyB.c_position.c;
  var aB = this.m_bodyB.c_position.a;

  var qA = Rot.neo(aA);
  var qB = Rot.neo(aB);

  var rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));
  var rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));
  var d = Vec2.zero();
  d.addCombine(1, cB, 1, rB);
  d.subCombine(1, cA, 1, rA);

  var ay = Rot.mulVec2(qA, this.m_localYAxisA);

  var sAy = Vec2.cross(Vec2.add(d, rA), ay); // float
  var sBy = Vec2.cross(rB, ay); // float

  var C = Vec2.dot(d, ay); // float

  var k = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_sAy
      * this.m_sAy + this.m_invIB * this.m_sBy * this.m_sBy; // float

  var impulse; // float
  if (k != 0.0) {
    impulse = -C / k;
  } else {
    impulse = 0.0;
  }

  var P = Vec2.mul(impulse, ay); // Vec2
  var LA = impulse * sAy; // float
  var LB = impulse * sBy; // float

  cA.subMul(this.m_invMassA, P);
  aA -= this.m_invIA * LA;
  cB.addMul(this.m_invMassB, P);
  aB += this.m_invIB * LB;

  this.m_bodyA.c_position.c.set(cA);
  this.m_bodyA.c_position.a = aA;
  this.m_bodyB.c_position.c.set(cB);
  this.m_bodyB.c_position.a = aB;

  return Math.abs(C) <= Settings.linearSlop;
}


/***/ }),
/* 110 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PhysicsWorld3D": () => (/* binding */ PhysicsWorld3D)
/* harmony export */ });

// 
//  FILE NAME: physicsworld3d.js
//  DESC:      Wrapper class for Bullet physics
//

class PhysicsWorld3D
{
    constructor()
    {
    }
}


/***/ }),
/* 111 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UIControlNavNode": () => (/* binding */ UIControlNavNode)
/* harmony export */ });
/* harmony import */ var _common_defs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);

// 
//  FILE NAME: uicontrolnavnode.js
//  DESC:      UI Control Navigation Node
//




class UIControlNavNode
{
    constructor( uiControl = null )
    {
        // UI Control pointer
        this.uiControl = uiControl;

        // Navigation node pointers
        this.upNode = null;
        this.downNode = null;
        this.leftNode = null;
        this.rightNode = null;
    }
    
    // 
    //  DESC: Set/Get Right Node
    //
    setNode( navId, node )
    {
        if( navId === _common_defs__WEBPACK_IMPORTED_MODULE_0__.ENAV_NODE_UP )
            this.upNode = node;
        else if( navId === _common_defs__WEBPACK_IMPORTED_MODULE_0__.ENAV_NODE_DOWN )
            this.downNode = node;
        else if( navId === _common_defs__WEBPACK_IMPORTED_MODULE_0__.ENAV_NODE_LEFT )
            this.leftNode = node;
        else if( navId === _common_defs__WEBPACK_IMPORTED_MODULE_0__.ENAV_NODE_RIGHT )
            this.rightNode = node;
    }

    getNode( navNode )
    {
        if( navNode === _common_defs__WEBPACK_IMPORTED_MODULE_0__.ENAV_NODE_UP )
            return this.upNode;
        else if( navNode === _common_defs__WEBPACK_IMPORTED_MODULE_0__.ENAV_NODE_DOWN )
            return this.downNode;
        else if( navNode === _common_defs__WEBPACK_IMPORTED_MODULE_0__.ENAV_NODE_LEFT )
            return this.leftNode;
        else if( navNode === _common_defs__WEBPACK_IMPORTED_MODULE_0__.ENAV_NODE_RIGHT )
            return this.rightNode;

        return null;
    }
}


/***/ }),
/* 112 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "objectDataManager": () => (/* binding */ objectDataManager)
/* harmony export */ });
/* harmony import */ var _managers_managerbase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(25);
/* harmony import */ var _managers_texturemanager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7);
/* harmony import */ var _managers_meshmanager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(113);
/* harmony import */ var _managers_vertexbuffermanager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(42);
/* harmony import */ var _managers_spritesheetmanager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(116);
/* harmony import */ var _utilities_assetholder__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(33);
/* harmony import */ var _objectdata2d__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(119);
/* harmony import */ var _objectdata3d__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(125);
/* harmony import */ var _utilities_genfunc__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(26);

//
//  FILE NAME: objactdatamanager.js
//  DESC:      Singlton that holds a map of all 2D/3D object data used for later loading
//













class ObjectDataManager extends _managers_managerbase__WEBPACK_IMPORTED_MODULE_0__.ManagerBase
{
    constructor()
    {
        super();

        this.objectDataMapMap = new Map;
    }

    //
    //  DESC: Load all XML's associated with this group
    //
    loadGroup( groupAry )
    {
        return super.loadGroupAry( 'Object data list', this.objectDataMapMap, groupAry )
            .then(() => this.loadAssets( groupAry ))
            .then(() => this.createFromData( groupAry ));
    }

    //
    //  DESC: Load all object information from an xml node
    //
    loadFromNode( group, node )
    {
        const LOAD_2D = 0;
        const LOAD_3D = 1;

        // Get the group map
        let groupMap = this.objectDataMapMap.get( group );

        // Determin the laod type
        let loadType = LOAD_2D;
        if( node.nodeName === 'objectDataList3D' )
            loadType = LOAD_3D;

        let defaultData;
        if( loadType === LOAD_2D )
            defaultData = new _objectdata2d__WEBPACK_IMPORTED_MODULE_6__.ObjectData2D;
        else
            defaultData = new _objectdata3d__WEBPACK_IMPORTED_MODULE_7__.ObjectData3D;

        // Load the default data
        defaultData.loadObjData( node.getElementsByTagName('default')[0], '', '' );

        // Get the node to the list of objects
        let objNode = node.getElementsByTagName('object');

        for( let i = 0; i < objNode.length; ++i )
        {
            // Get the object's name
            let name = objNode[i].getAttribute( 'name' );
            
            // Check that this object doesn't already exist
            if( groupMap.get(name) === undefined )
            {
                let objData
                if( loadType === LOAD_2D )
                    objData = new _objectdata2d__WEBPACK_IMPORTED_MODULE_6__.ObjectData2D;
                else
                    objData = new _objectdata3d__WEBPACK_IMPORTED_MODULE_7__.ObjectData3D;
                
                objData.copy(defaultData);

                // Load in the object data
                objData.loadObjData( objNode[i], group, name );

                // Save it to the map map
                groupMap.set( name, objData );
            }
            else
            {
                throw new Error( `Group object already exists (${group}, ${name})!` );
            }
        }
    }

    //
    //  DESC: Load all the assets associated with these groups
    //
    loadAssets( groupAry )
    {
        let promiseAry = [];

        for( let grp = 0; grp < groupAry.length; ++grp )
        {
            let group = groupAry[grp];

            // Get the group map
            let groupMap = this.objectDataMapMap.get( group );
            if( groupMap !== undefined )
            {
                for( let objData of groupMap.values() )
                {
                    // Load 2D elements
                    if( objData.is2D() )
                    {
                        let filePathAry = objData.visualData.getTextureFilePathAry();

                        for( let i = 0; i < filePathAry.length; ++i )
                        {
                            let filePath = filePathAry[i];

                            if( filePath && _managers_texturemanager__WEBPACK_IMPORTED_MODULE_1__.textureManager.allowLoad( group, filePath ) )
                            {
                                // Load the texture file
                                promiseAry.push( 
                                    _utilities_genfunc__WEBPACK_IMPORTED_MODULE_8__.downloadFile( 'img', filePath )
                                        .then(( image ) => _managers_texturemanager__WEBPACK_IMPORTED_MODULE_1__.textureManager.load( group, filePath, image ))
                                        .catch(( error ) => { console.error(error.stack); throw error; }));
                            }
                        }
                        
                        // Load the XML mesh
                        let meshFilePath = objData.visualData.meshFilePath;
                        if( meshFilePath && _utilities_assetholder__WEBPACK_IMPORTED_MODULE_5__.assetHolder.allowLoad( group, meshFilePath ) )
                        {
                            // Load the mesh file
                            promiseAry.push( 
                                _utilities_genfunc__WEBPACK_IMPORTED_MODULE_8__.downloadFile( 'xml', meshFilePath )
                                    .then(( xmlNode ) => _utilities_assetholder__WEBPACK_IMPORTED_MODULE_5__.assetHolder.set( group, meshFilePath, xmlNode ))
                                    .catch(( error ) => { console.error(error.stack); throw error; }));
                        }

                        // Load the XML sprite sheet
                        let spriteSheetfilePath = objData.visualData.spriteSheetFilePath;
                        if( spriteSheetfilePath && _managers_spritesheetmanager__WEBPACK_IMPORTED_MODULE_4__.spriteSheetManager.allowLoad( group, spriteSheetfilePath ) )
                        {
                            // Load the mesh file
                            promiseAry.push( 
                                _utilities_genfunc__WEBPACK_IMPORTED_MODULE_8__.downloadFile( 'xml', spriteSheetfilePath )
                                    .then(( xmlNode ) => _managers_spritesheetmanager__WEBPACK_IMPORTED_MODULE_4__.spriteSheetManager.load( group, spriteSheetfilePath, xmlNode ))
                                    .catch(( error ) => { console.error(error.stack); throw error; }));
                        }
                    }
                    // Load 3D elements
                    else
                    {
                        let filePath = objData.visualData.meshFilePath;

                        if( filePath && _managers_meshmanager__WEBPACK_IMPORTED_MODULE_2__.meshManager.allowLoad( group, filePath ) )
                        {
                            // Load the mesh file
                            promiseAry.push( 
                                _utilities_genfunc__WEBPACK_IMPORTED_MODULE_8__.downloadFile( 'binary', filePath )
                                    .then(( binaryFile ) => this.loadMesh3D( group, filePath, objData, binaryFile ))
                                    .catch(( error ) => { console.error(error.stack); throw error; }));
                        }
                    }
                }
            }
            else
            {
                throw new Error( `Can't download asset because object group does not exist (${group})!` );
            }
        }

        return Promise.all( promiseAry );
    }

    //
    //  DESC: Load all the assets associated with this group
    //
    loadMesh3D( group, binaryFilePath, objData, binaryFile )
    {
        let promiseAry = [];

        objData.visualData.meshGrp =
            _managers_meshmanager__WEBPACK_IMPORTED_MODULE_2__.meshManager.load( group, binaryFilePath, binaryFile );

        let filePathAry = objData.visualData.meshGrp.uniqueTexturePathAry;

        // Load the mesh textures
        for( let i = 0; i < filePathAry.length; ++i )
        {
            let filePath = filePathAry[i].path;
            
            if( filePath && _managers_texturemanager__WEBPACK_IMPORTED_MODULE_1__.textureManager.allowLoad( group, filePath ) )
            {
                // Load the texture file
                promiseAry.push( 
                    _utilities_genfunc__WEBPACK_IMPORTED_MODULE_8__.downloadFile( 'img', filePath )
                        .then(( image ) => _managers_texturemanager__WEBPACK_IMPORTED_MODULE_1__.textureManager.load( group, filePath, image ))
                        .catch(( error ) => { console.error(error.stack); throw error; }));
            }
        }

        return Promise.all( promiseAry );
    }

    //
    //  DESC: Create OpenGL objects from data
    //
    createFromData( groupAry )
    {
        for( let grp = 0; grp < groupAry.length; ++grp )
        {
            let group = groupAry[grp];
            
            // Get the group map
            let groupMap = this.objectDataMapMap.get( group );
            if( groupMap !== undefined )
            {
                // Create OpenGL objects from data
                for( let objData of groupMap.values() )
                    objData.createFromData( group );
            }
        }

        return 0;
        
        // Temporary assets can now be freed
        //assetHolder.deleteGroup( groupAry );
        //spriteSheetManager.deleteGroup( groupAry );
    }
    
    //
    //  DESC: Free all of the meshes materials and data of a specific group
    //
    freeGroup( groupAry )
    {
        for( let grp = 0; grp < groupAry.length; ++grp )
        {
            let group = groupAry[grp];
            
            // Make sure the group we are looking for exists
            if( this.listTableMap.get( group ) === undefined )
                throw new Error( `Object data list group name can't be found (${group})!` );

            // Get the group map
            if( this.objectDataMapMap.has( group ) )
            {
                _managers_texturemanager__WEBPACK_IMPORTED_MODULE_1__.textureManager.deleteGroup( group );
                _managers_vertexbuffermanager__WEBPACK_IMPORTED_MODULE_3__.vertexBufferManager.deleteGroup( group );
                _managers_meshmanager__WEBPACK_IMPORTED_MODULE_2__.meshManager.deleteGroup( group );

                this.objectDataMapMap.delete( group );
            }
        }
    }
    
    //
    //  DESC: Get a specific object data
    //
    getData( group, name )
    {
        // Get the group map
        let groupMap = this.objectDataMapMap.get( group );
        if( groupMap !== undefined )
        {
            let objData = groupMap.get( name );
            if( objData )
                return objData;

            throw new Error( `Object data not found (${group}, ${name})!` );
        }

        throw new Error( `Object group not found (${group}, ${name})!` );
    }

    //
    // DESC:  Find the group an object name belongs to
    //
    findGroup( objectName )
    {
        for( let [ groupKey, groupMap ] of this.objectDataMapMap.entries() )
        {
            if( groupMap.get( objectName ) !== undefined )
                return groupKey;
        }

        return undefined;
    }
}

var objectDataManager = new ObjectDataManager;


/***/ }),
/* 113 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "meshManager": () => (/* binding */ meshManager)
/* harmony export */ });
/* harmony import */ var _system_device__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9);
/* harmony import */ var _common_meshbinaryfileheader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(114);
/* harmony import */ var _common_mesh3d__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(115);

//
//  FILE NAME: meshmanager.js
//  DESC:      mesh manager class singleton
//







class MeshManager
{
    constructor()
    {
        // Map containing a group array of vbo, ibo and texture id's
        this.meshBufMapMap = new Map;

        // Map for collision mesh
        //this.collisionMeshBufMapMap = new Map;
        
        // counter for indexing into binary data when loading
        this.counter = 0;
    }
    
    //
    //  DESC: Load the binary mesh data
    //  NOTE: To keep it simple, loading the textures is done seperately
    //
    load( group, filePath, binaryData )
    {
        // Create the group map if it doesn't already exist
        let groupMap = this.meshBufMapMap.get( group );
        if( groupMap === undefined )
        {
            groupMap = new Map;
            this.meshBufMapMap.set( group, groupMap );
        }
        
        let meshGrp = groupMap.get( filePath );
        if( meshGrp === undefined || meshGrp === -1 )
        {
            meshGrp = new _common_mesh3d__WEBPACK_IMPORTED_MODULE_2__.MeshGroup;
            groupMap.set( filePath, meshGrp );
            
            this.loadData( group, filePath, binaryData, meshGrp );
        }

        return meshGrp;
    }

    // 
    //  DESC: Set a place holder that this data is scheduled to be loaded
    //
    allowLoad( group, filePath )
    {
        let groupMap = this.meshBufMapMap.get( group );
        if( groupMap === undefined )
        {
            groupMap = new Map;
            this.meshBufMapMap.set( group, groupMap );
        }
        
        let meshGrp = groupMap.get( filePath );
        if( meshGrp === undefined )
        {
            // Add an entry to the map as a 
            // place holder for future checks
            groupMap.set( filePath, -1 );

            return true;
        }

        return false;
    }

    //
    //  DESC: Get the 2D texture class
    //
    get( group, filePath )
    {
        let groupMap = this.meshBufMapMap.get( group );
        if( groupMap === undefined )
            throw new Error( `Texture group does not exists! (${group}, ${filePath}).` );

        let meshBuf = groupMap.get( filePath );
        if( meshBuf === undefined || meshBuf === -1 )
            throw new Error( `Texture does not exists! (${group}, ${filePath}).` );

        return meshBuf;
    }
    
    //
    //  DESC: Load the binary mesh data
    //
    loadData( group, filePath, binaryData, meshGrp )
    {
        this.counter = 0;

        // Load the binary data into the data view for easy access to different data types
        let dataView = new DataView( binaryData );
        
        // Load the binary mesh file header
        let fileHeader = this.loadFileHeader( dataView, group, filePath );
        
        
        // Check to insure we are in the correct spot in the binary file
        this.tagCheck( dataView, (fileHeader.text_count > 0), group, filePath );
        
        // Load the texture file paths
        this.loadTexturePaths( dataView, fileHeader, meshGrp );
        
        
        // Check to insure we are in the correct spot in the binary file
        this.tagCheck( dataView, true, group, filePath );
        
        // Load the verts
        let vertAry = [];
        this.loadVerts( dataView, fileHeader, vertAry );
        
        
        // Check to insure we are in the correct spot in the binary file
        this.tagCheck( dataView, true, group, filePath );
        
        // Load the normals
        let normAry = [];
        this.loadNormals( dataView, fileHeader, normAry );
        
        
        // Check to insure we are in the correct spot in the binary file
        this.tagCheck( dataView, (fileHeader.uv_count > 0), group, filePath );
        
        // Load the uv's
        let uvAry = [];
        this.loadUVs( dataView, fileHeader, uvAry );
        
        // Build the meshes
        this.buildMeshes( dataView, group, filePath, fileHeader, meshGrp, vertAry, normAry, uvAry );
    }
    
    //
    //  DESC: Load the binary mesh file header
    //
    loadFileHeader( dataView, group, filePath )
    {
        let fileHeader = new _common_meshbinaryfileheader__WEBPACK_IMPORTED_MODULE_1__.MeshBinaryFileHeader;
        
        fileHeader.file_header      = dataView.getUint32( this.counter, true ); this.counter += 4;
        fileHeader.vert_count       = dataView.getUint16( this.counter, true ); this.counter += 2;
        fileHeader.uv_count         = dataView.getUint16( this.counter, true ); this.counter += 2;
        fileHeader.vert_norm_count  = dataView.getUint16( this.counter, true ); this.counter += 2;
        fileHeader.face_group_count = dataView.getUint16( this.counter, true ); this.counter += 2;
        fileHeader.text_count       = dataView.getUint16( this.counter, true ); this.counter += 2;
        fileHeader.joint_count      = dataView.getUint16( this.counter, true ); this.counter += 2;
        
        // Check to make sure we're loading in the right kind of file
        if( fileHeader.file_header !== _common_meshbinaryfileheader__WEBPACK_IMPORTED_MODULE_1__.MESH_FILE_HEADER )
            throw new Error( `File header mismatch! (${group}, ${filePath}).` );
        
        return fileHeader;
    }
    
    //
    //  DESC: Load the binary mesh file header
    //
    loadTexturePaths( dataView, fileHeader, meshGrp )
    {
        for( let i = 0; i < fileHeader.text_count; ++i )
        {
            let uniqueTextAry = new _common_meshbinaryfileheader__WEBPACK_IMPORTED_MODULE_1__.BinaryTexture;
            meshGrp.uniqueTexturePathAry.push( uniqueTextAry );

            uniqueTextAry.type = dataView.getInt8( this.counter, true ); this.counter += 1;

            for( let j = 0; j < _common_meshbinaryfileheader__WEBPACK_IMPORTED_MODULE_1__.TEXT_PATH_SIZE; ++j )
            {
                let charCode = dataView.getInt8( this.counter, true ); this.counter += 1;

                if( charCode )
                {
                    uniqueTextAry.path += String.fromCharCode(charCode);
                }
                else
                {
                    this.counter += _common_meshbinaryfileheader__WEBPACK_IMPORTED_MODULE_1__.TEXT_PATH_SIZE - j - 1;
                    break;
                }
            }
        }
    }
    
    //
    //  DESC: Load the verts
    //
    loadVerts( dataView, fileHeader, vertAry )
    {
        // Load the verts
        for( let i = 0; i < fileHeader.vert_count; ++i )
        {
            let data = [0,0,0];
            vertAry.push( data );
            
            for( let j = 0; j < 3; ++j )
            {
                data[j] = dataView.getFloat32( this.counter, true ); this.counter += 4;
            }
        }
    }
    
    //
    //  DESC: Load the normals
    //
    loadNormals( dataView, fileHeader, normAry )
    {
        for( let i = 0; i < fileHeader.vert_norm_count; ++i )
        {
            let data = [0,0,0];
            normAry.push( data );
            
            for( let j = 0; j < 3; ++j )
            {
                data[j] = dataView.getFloat32( this.counter, true ); this.counter += 4;
            }
        }
    }
    
    //
    //  DESC: Load the uv's
    //
    loadUVs( dataView, fileHeader, uvAry )
    {
        // Load the normals
        for( let i = 0; i < fileHeader.uv_count; ++i )
        {
            let data = [0,0];
            uvAry.push( data );
            
            for( let j = 0; j < 2; ++j )
            {
                data[j] = dataView.getFloat32( this.counter, true ); this.counter += 4;
            }
        }
    }
    
    //
    //  DESC: Build the meshes
    //
    buildMeshes( dataView, group, filePath, fileHeader, meshGrp, vertAry, normAry, uvAry )
    {
        let gl = _system_device__WEBPACK_IMPORTED_MODULE_0__.device.gl;
        let faceGroup = new _common_meshbinaryfileheader__WEBPACK_IMPORTED_MODULE_1__.BinaryFaceGroup;
        
        // Read in each face group
        for( let i = 0; i < fileHeader.face_group_count; ++i )
        {
            // Check to insure we are in the correct spot in the binary file
            this.tagCheck( dataView, true, group, filePath );
            
            // Allocate the mesh storage
            let mesh = new _common_mesh3d__WEBPACK_IMPORTED_MODULE_2__.Mesh;
            meshGrp.meshAry.push( mesh );
            
            faceGroup.groupFaceCount = dataView.getUint16( this.counter, true ); this.counter += 2;
            faceGroup.vertexBufCount = dataView.getUint16( this.counter, true ); this.counter += 2;
            faceGroup.indexBufCount  = dataView.getUint16( this.counter, true ); this.counter += 2;
            faceGroup.textureCount   = dataView.getUint16( this.counter, true ); this.counter += 2;
            
            // Read in the indexes that are the textures
            for( let j = 0; j < faceGroup.textureCount; ++j )
            {
                mesh.textureIndexAry.push( dataView.getUint16( this.counter, true ) );
                this.counter += 2;
            }

            // Read in the indexes used to create the VBO
            let vertBufAry = [];
            for( let j = 0; j < faceGroup.vertexBufCount; ++j )
            {
                let binaryVertex = new _common_meshbinaryfileheader__WEBPACK_IMPORTED_MODULE_1__.BinaryVertex;
                vertBufAry.push( binaryVertex );
                
                binaryVertex.vert = dataView.getUint16( this.counter, true ); this.counter += 2;
                binaryVertex.norm = dataView.getUint16( this.counter, true ); this.counter += 2;
                
                if( fileHeader.uv_count )
                {
                    binaryVertex.uv = dataView.getUint16( this.counter, true ); this.counter += 2;
                }
            }

            // Read in the indexes that are the IBO
            let iboAry = [];
            for( let j = 0; j < faceGroup.indexBufCount; ++j )
            {
                iboAry.push( dataView.getUint16( this.counter, true ) );
                this.counter += 2;
            }
            
            // Create a temporary array for building the VBO
            let vboAry = [];

            // Build the VBO
            for( let j = 0; j < faceGroup.vertexBufCount; ++j )
            {
                Array.prototype.push.apply( vboAry, vertAry[ vertBufAry[j].vert ] );
                Array.prototype.push.apply( vboAry, normAry[ vertBufAry[j].norm ] );
                
                if( fileHeader.uv_count )
                    Array.prototype.push.apply( vboAry, uvAry[ vertBufAry[j].uv ] );
            }
            
            // Create the vbo
            mesh.vbo = gl.createBuffer();
            gl.bindBuffer( gl.ARRAY_BUFFER, mesh.vbo );
            gl.bufferData( gl.ARRAY_BUFFER, new Float32Array(vboAry), gl.STATIC_DRAW );
            gl.bindBuffer( gl.ARRAY_BUFFER, null );
            
            // Create the ibo
            mesh.ibo = gl.createBuffer();
            gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, mesh.ibo );
            gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(iboAry), gl.STATIC_DRAW );
            gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, null );
            
            // Save the number of indexes in the IBO buffer - Will need this for the render call
            mesh.iboCount = faceGroup.indexBufCount;
        }
    }
    
    //
    //  DESC: Load the binary mesh file header
    //
    tagCheck( dataView, allowCheck, group, filePath )
    {
        if( allowCheck )
        {
            let tag = dataView.getUint32( this.counter, true ); this.counter += 4;
            if( tag !== _common_meshbinaryfileheader__WEBPACK_IMPORTED_MODULE_1__.TAG_CHECK )
                throw new Error( `Tag check mismatch! (${group}, ${filePath}).` );
        }
    }
    
    //
    //  DESC: Delete the group of textures
    //
    deleteGroup( group )
    {
        let groupMap = this.meshBufMapMap.get( group );
        if( groupMap !== undefined )
        {
            let gl = _system_device__WEBPACK_IMPORTED_MODULE_0__.device.gl;
            
            for( const each of groupMap.values() )
            {
                for( const mesh of each.meshAry )
                {
                    gl.deleteBuffer( mesh.vbo );
                    gl.deleteBuffer( mesh.ibo );
                }
            }

            this.meshBufMapMap.delete( group );
        }
    }
}

var meshManager = new MeshManager;


/***/ }),
/* 114 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MESH_FILE_HEADER": () => (/* binding */ MESH_FILE_HEADER),
/* harmony export */   "TAG_CHECK": () => (/* binding */ TAG_CHECK),
/* harmony export */   "TEXT_PATH_SIZE": () => (/* binding */ TEXT_PATH_SIZE),
/* harmony export */   "JOINT_NAME_SIZE": () => (/* binding */ JOINT_NAME_SIZE),
/* harmony export */   "MeshBinaryFileHeader": () => (/* binding */ MeshBinaryFileHeader),
/* harmony export */   "BinaryTexture": () => (/* binding */ BinaryTexture),
/* harmony export */   "BinaryFaceGroup": () => (/* binding */ BinaryFaceGroup),
/* harmony export */   "BinaryFace": () => (/* binding */ BinaryFace),
/* harmony export */   "BinaryVertex": () => (/* binding */ BinaryVertex)
/* harmony export */ });

//
//  FILE NAME: meshbinaryfileheader.js
//  DESC:      mesh binary file headers
//



// Hex for RSS (Rabbid Squirrel Sprite)
const MESH_FILE_HEADER = 0x415382AE;

// Hex for tag check
const TAG_CHECK = 0x6A82Fc4d;

// Max character sizes for the texture path and joint name
const TEXT_PATH_SIZE = 128;
const JOINT_NAME_SIZE = 20;

class MeshBinaryFileHeader
{
    constructor()
    {
        this.file_header      = 0; // uint32
        this.vert_count       = 0; // uint16
        this.uv_count         = 0; // uint16
        this.vert_norm_count  = 0; // uint16
        this.face_group_count = 0; // uint16
        this.text_count       = 0; // uint16
        this.joint_count      = 0; // uint16
    }
}

// class for reading in texture info
class BinaryTexture
{
    constructor()
    {
        this.type = 0;       // int8
        this.path = '';      // file path [TEXT_PATH_SIZE]
    }
}

// Class for reading and writing the total face count within a group and the material
// it belongs to
class BinaryFaceGroup
{
    constructor()
    {
        this.groupFaceCount = 0; // uint16
        this.vertexBufCount = 0; // uint16
        this.indexBufCount  = 0; // uint16
        this.textureCount   = 0; // uint16
    }
}

// Class for reading and writing face information
class BinaryFace
{
    constructor()
    {
        this.vert = [];
        this.norm = [];
        this.uv = [];
    }
}

// Class for reading and writing face information
class BinaryVertex
{
    constructor()
    {
        this.vert = 0;
        this.norm = 0;
        this.uv = 0;
    }
}

/***/ }),
/* 115 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MeshGroup": () => (/* binding */ MeshGroup),
/* harmony export */   "Mesh": () => (/* binding */ Mesh)
/* harmony export */ });

//
//  FILE NAME: mesh3d.js
//  DESC:      3D mesh class
//



class MeshGroup
{
    constructor()
    {
        // Array texture paths for loading
        this.uniqueTexturePathAry = [];
        
        // Array of loaded textures
        this.meshAry = [];
    }
}

class Mesh
{
    constructor()
    {
        // Texture indexes into the uniqueTexturePathAry
        this.textureIndexAry = [];
        
        // Loaded texture data
        this.textureAry = [];

        // VBO
        this.vbo = null;

        // IBO
        this.ibo = null;

        // Number of IBOs needed for rendering
        this.iboCount = 0;
    }
}


/***/ }),
/* 116 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "spriteSheetManager": () => (/* binding */ spriteSheetManager)
/* harmony export */ });
/* harmony import */ var _sprite_spritesheet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(117);

//
//  FILE NAME: spritesheetmanager.js
//  DESC:      Temporary container for loading sprite sheet data
//             so that the same large complex xml is not reloaded.
//




class SpriteSheetManager
{
    constructor()
    {
        this.spriteSheetMapMap = new Map;
    }
    
    //
    //  DESC: Load the glyph data from XML node
    //
    load( group, filePath, node )
    {
        let groupMap = this.spriteSheetMapMap.get( group );
        if( groupMap === undefined )
        {
            groupMap = new Map;
            this.spriteSheetMapMap.set( group, groupMap );
        }
        
        let spriteSheet = groupMap.get( filePath );
        if( spriteSheet === undefined || spriteSheet === -1 )
        {
            spriteSheet = new _sprite_spritesheet__WEBPACK_IMPORTED_MODULE_0__.SpriteSheet;
            
            // Load the glyph data from XML node
            spriteSheet.loadFromNode( node );
            
            // Add a new entry to the map
            groupMap.set( filePath, spriteSheet );
        }
    }

    // 
    //  DESC: Set a place holder that this data is scheduled to be loaded
    //
    allowLoad( group, filePath )
    {
        let groupMap = this.spriteSheetMapMap.get( group );
        if( groupMap === undefined )
        {
            groupMap = new Map;
            this.spriteSheetMapMap.set( group, groupMap );
        }
        
        let spriteSheet = groupMap.get( filePath );
        if( spriteSheet === undefined )
        {
            // Add an entry to the map as a 
            // place holder for future checks
            groupMap.set( filePath, -1 );

            return true;
        }

        return false;
    }
    
    //
    //  DESC: Load the glyph data from XML node
    //
    get( group, filePath )
    {
        let groupMap = this.spriteSheetMapMap.get( group );
        if( groupMap === undefined )
            throw new Error( `Sprite sheet group does not exist! (${group}).` );
            
        let data = groupMap.get( filePath );
        if( data === undefined )
            throw new Error( `Sprite sheet mesh file missing! (${filePath}).` );
        
        return data;
    }
    
    // 
    //  DESC: Delete the group
    //
    deleteGroup( groupAry )
    {
        for( let i = 0; i < groupAry.length; ++i )
            this.spriteSheetMapMap.delete( groupAry[i] );
    }
    
    //
    //  DESC: Clear all the sprite sheet data
    //
    clear()
    {
        if( this.spriteSheetMapMap.size )
            this.spriteSheetMapMap.clear();
    }
}

var spriteSheetManager = new SpriteSheetManager;


/***/ }),
/* 117 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SpriteSheet": () => (/* binding */ SpriteSheet)
/* harmony export */ });
/* harmony import */ var _spritesheetglyph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(118);
/* harmony import */ var _common_size__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4);
/* harmony import */ var _common_rect__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(21);
/* harmony import */ var _utilities_xmlparsehelper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(19);

// 
//  FILE NAME:  spritesheet.js
//  DESC:       Class for holding sprite sheet data
//







class SpriteSheet
{
    constructor( defaultIndex = 0, glyphCount = 0, columns = 0 )
    {
        // Sprite Sheet default index
        this.defaultIndex = defaultIndex;

        // Sprite Sheet element count
        this.glyphCount = glyphCount;

        // Sprite Sheet columns
        this.columns = columns;
        
        // An array of all the glyphs built manually that are of the same size
        this.glyphAry = null;

        // A map of all the glyphs
        this.glyphMap = null;
    }
    
    // 
    //  DESC: Copy the passed in data
    //
    copy( obj )
    {
        this.defaultIndex = obj.defaultIndex;
        this.glyphCount = obj.glyphCount;
        this.columns = obj.columns;
        
        if( obj.glyphAry )
        {
            if( this.glyphAry === null )
                this.glyphAry = [];
            
            for( let i = 0; i < obj.glyphAry.length; ++i )
            {
                let glyph = obj.glyphAry[i];
                let size = new _common_size__WEBPACK_IMPORTED_MODULE_1__.Size( glyph.size.w, glyph.size.h );
                let rect = new _common_rect__WEBPACK_IMPORTED_MODULE_2__.Rect( glyph.uv.x1, glyph.uv.y1, glyph.uv.x2, glyph.uv.y2 );
                let cropOffset = null;
                if( glyph.cropOffset )
                    cropOffset = new _common_size__WEBPACK_IMPORTED_MODULE_1__.Size( glyph.cropOffset.w, glyph.cropOffset.h );
                
                this.glyphAry.push( new _spritesheetglyph__WEBPACK_IMPORTED_MODULE_0__.SpriteSheetGlyph( size, rect, cropOffset ) );
            }
        }
    }
    
    // 
    //  DESC: Build the simple (grid) sprite sheet data
    //
    build( sheetSize )
    {
        if( (this.glyphCount != 0) && (this.columns != 0) )
        {
            this.glyphAry = [];
            
            let rows = Math.trunc(this.glyphCount / this.columns);

            if( (this.glyphCount % this.columns) > 0 )
                ++rows;

            // Calculate the size of the individual glyph. They are all the same size
            let size = new _common_size__WEBPACK_IMPORTED_MODULE_1__.Size( sheetSize.w / this.columns, sheetSize.h / rows );

            for( let i = 0; i < rows; ++i )
            {
                for( let j = 0; j < this.columns; ++j )
                {
                    let rect = new _common_rect__WEBPACK_IMPORTED_MODULE_2__.Rect(
                        (j * size.w) / sheetSize.w,
                        (i * size.h) / sheetSize.h,
                        size.w / sheetSize.w,
                        size.h / sheetSize.h );
                    
                    this.glyphAry.push( new _spritesheetglyph__WEBPACK_IMPORTED_MODULE_0__.SpriteSheetGlyph( size, rect ) );

                    // Break out after all the gylphs have been defined
                    if( this.glyphAry.length === this.glyphCount )
                        break;
                }
            }
        }
    }
    
    // 
    //  DESC: Load the glyph data from XML node
    //
    loadFromNode( node )
    {
        this.glyphMap = new Map;
        
        let sheetSize = new _common_size__WEBPACK_IMPORTED_MODULE_1__.Size;
        let attr = node.getAttribute('width');
        if( attr )
            sheetSize.w = Number(attr);

        attr = node.getAttribute('height');
        if( attr )
            sheetSize.h = Number(attr);

        let rectNode = node.getElementsByTagName('rect');
        if( rectNode.length )
        {
            for( let i = 0; i < rectNode.length; ++i )
            {
                let rect = _utilities_xmlparsehelper__WEBPACK_IMPORTED_MODULE_3__.loadRectFromChild( rectNode[i] );

                let size = new _common_size__WEBPACK_IMPORTED_MODULE_1__.Size( rect.x2, rect.y2 );

                let uv = new _common_rect__WEBPACK_IMPORTED_MODULE_2__.Rect(
                    rect.x1 / sheetSize.w,
                    rect.y1 / sheetSize.h,
                    rect.x2 / sheetSize.w,
                    rect.y2 / sheetSize.h );

                let cropOffset = new _common_size__WEBPACK_IMPORTED_MODULE_1__.Size(
                    Number(rectNode[i].getAttribute( 'cx' )),
                    Number(rectNode[i].getAttribute( 'cy' )) );

                // Add to the map
                let strId = rectNode[i].getAttribute( 'name' );
                this.glyphMap.set( strId, new _spritesheetglyph__WEBPACK_IMPORTED_MODULE_0__.SpriteSheetGlyph( size, uv, cropOffset) );
            }
        }
    }
    
    // 
    //  DESC: Load the glyph data from XML node
    //
    getGlyph( index = -1 )
    {
        if( index > -1 )
            return this.glyphAry[ index ];

        else
            return this.glyphAry[ this.defaultIndex ];
    }
    
    
    // 
    //  DESC: Find the glyph by Id
    //
    findGlyph( glyphId )
    {
        let glyph = this.glyphMap.get( glyphId );
        if( glyph === undefined )
        {
            throw new Error( 'Glyph name is missing (' + glyphId + ')!' );
        }
        
        return glyph;
    }
    
    
    // 
    //  DESC: Set the gylph data
    //
    setGlyph( spriteSheet, glyphId )
    {
        let glyph = this.glyphMap.get( glyphId );
        if( glyph !== undefined )
        {
            if( spriteSheet.glyphAry === null )
                spriteSheet.glyphAry = [];
            
            spriteSheet.glyphAry.push( glyph );
        }
        else
        {
            throw new Error( 'Glyph name is missing (' + glyphId + ')!' );
        }
    }
    
    // 
    //  DESC: Get the number of gylphs in this sprite sheet
    //
    getCount()
    {
        if( (this.glyphAry !== null) && (this.glyphAry.length) )
            return this.glyphAry.length;
        
        else if( (this.glyphMap !== null) && (this.glyphMap.length) )
            return this.glyphMap.length;

        return this.glyphCount;
    }
    
    // 
    //  DESC: Copy over the gylph data
    //
    copyTo( spriteSheet, strIdAry )
    {
        if( strIdAry.length === 0 )
        {
            spriteSheet.glyphAry = this.glyphAry;
        }
        else if( this.glyphMap.size )
        {
            // Init the sprite sheet class when each glyph is defined in the object data
            if( spriteSheet.glyphCount === 0 )
            {
                for( let i = 0; i < strIdAry.length; ++i )
                    this.setGlyph( spriteSheet, strIdAry[i] );
            }
            // Init the sprite sheet class with an animation that is one glyph defined with a format code
            else
            {
                // Should only be one entry
                if( strIdAry.length === 1 )
                {
                    for( let i = 0; i < spriteSheet.glyphCount; ++i )
                        this.setGlyph( spriteSheet, strIdAry[0] + i );
                }
                else
                {
                    throw new Error( 'Sprite Sheet Incorrect configuration!' );
                }
            }
        }
    }
}


/***/ }),
/* 118 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SpriteSheetGlyph": () => (/* binding */ SpriteSheetGlyph)
/* harmony export */ });

// 
//  FILE NAME:  spritesheetglyph.js
//  DESC:       Class to hold sprite sheet glyph data
//



class SpriteSheetGlyph
{
    constructor( size, uv, cropOffset = null )
    {
        // Size of the sprite on the sheet
        this.size = size;

        // UV coordinates RECT
        this.uv = uv;

        // Crop Offset
        this.cropOffset = cropOffset;
    }
}


/***/ }),
/* 119 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ObjectData2D": () => (/* binding */ ObjectData2D)
/* harmony export */ });
/* harmony import */ var _iobjectdata__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(120);
/* harmony import */ var _objectphysicsdata2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(121);
/* harmony import */ var _objectvisualdata2d__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(122);
/* harmony import */ var _common_size__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4);
/* harmony import */ var _utilities_xmlparsehelper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(19);

// 
//  FILE NAME: objectdata2d.js
//  DESC:      Class that holds a 2D object data
//









class ObjectData2D extends _iobjectdata__WEBPACK_IMPORTED_MODULE_0__.iObjectData
{
    constructor()
    {
        super();

        // Visual data of the object
        this.visualData = new _objectvisualdata2d__WEBPACK_IMPORTED_MODULE_2__.ObjectVisualData2D;

        // Physics data of the object
        this.physicsData = new _objectphysicsdata2d__WEBPACK_IMPORTED_MODULE_1__.ObjectPhysicsData2D;

        // The name of the object data
        this.name = null;

        // The group the object data is in
        this.group = null;

        // The initial size of the object
        this.size = new _common_size__WEBPACK_IMPORTED_MODULE_3__.Size;
    }
    
    // 
    //  DESC: Copy the passed in data
    //
    copy( obj )
    {
        this.visualData.copy( obj.visualData );
        this.physicsData.copy( obj.physicsData );
        this.size.copy( obj.size );
    }
    
    // 
    //  DESC: Load the object data from the passed in node
    //
    loadObjData( node, group, name )
    {
        this.name = name;
        this.group = group;

        // Load the size
        this.size = _utilities_xmlparsehelper__WEBPACK_IMPORTED_MODULE_4__.loadSize( node, this.size );

        // Load the visual data
        this.visualData.loadObjData( node );

        // Load the physics data
        this.physicsData.loadObjData( node );
    }
    
    // 
    //  DESC: Create OpenGL objects from data
    //
    createFromData( group )
    {
        // Create the visuales
        this.visualData.createFromData( group, this.size );
    }

    // 
    //  DESC: Is this 2D object data?
    //
    is2D()
    {
        return true;
    }
}


/***/ }),
/* 120 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "iObjectData": () => (/* binding */ iObjectData)
/* harmony export */ });

// 
//  FILE NAME: iobjectdata.js
//  DESC:      Object data interface class
//



class iObjectData
{
    constructor()
    {
    }
    
    // 
    //  DESC: Is this 2D object data?
    //
    is2D()
    {
        return false;
    }

    // 
    //  DESC: Is this 3D object data?
    //
    is3D()
    {
        return false;
    }
}


/***/ }),
/* 121 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Fixture": () => (/* binding */ Fixture),
/* harmony export */   "ObjectPhysicsData2D": () => (/* binding */ ObjectPhysicsData2D)
/* harmony export */ });
/* harmony import */ var planck_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(57);

// 
//  FILE NAME:  objectphysicsdata2d.js
//  DESC:       Class containing the 2D object's physics data
//





class Fixture
{
    constructor()
    {
        // Shape of the fixture
        this.shape = null;

        // Radius if shape is a circle
        this.radius = 0.0;

        // The friction is how much drag this object has on another object  
        this.friction = 0.2;

        // The density is how much the object resists movement  
        this.density = 0.2;

        // The percetange of velocity retained upon colliding with this object
        this.restitution = 0.2;

        // Amount to adjust the top, bottom, left, and right side size of the mesh
        this.topMod = 0;
        this.bottomMod = 0;
        this.leftMod = 0;
        this.rightMod = 0;

        // Flag to define if chain shape is a loop
        this.chainLoop = false;

        // Flag to indicate if fixture is a sensor. Reports collision but doesn't react to it
        this.sensor = false;

        // Collision filter
        this.filterGroupIndex = 0;
        this.filterCategoryBits = 1;
        this.filterMaskBits = 65535;

        // Polygon point vector
        this.vertAry = [];
    }
    
    // 
    //  DESC: Copy the passed in data
    //
    copy( obj )
    {
        this.shape = obj.shape;
        this.radius = obj.radius;  
        this.friction = obj.friction;  
        this.density = obj.density;
        this.restitution = obj.restitution;
        this.topMod = obj.topMod;
        this.bottomMod = obj.bottomMod;
        this.leftMod = obj.leftMod;
        this.rightMod = obj.rightMod;
        this.chainLoop = obj.chainLoop;
        this.sensor = obj.sensor;
        this.filterGroupIndex = obj.filterGroupIndex;
        this.filterCategoryBits = obj.filterCategoryBits;
        this.filterMaskBits = obj.filterMaskBits;
        
        for( let i = 0; i < obj.vertAry.length; ++i )
        {
            let vert = obj.vertAry[i];
            this.vertAry.push( new planck_js__WEBPACK_IMPORTED_MODULE_0__.Vec2( vert.x, vert.y ) );
        }
    }
}

class ObjectPhysicsData2D
{
    constructor()
    {
        // The name of the physics world
        this.world = null;

        // Type of physics body
        this.bodyType = null;

        // The constant decceleration of movement and rotation
        this.linearDamping = 0;
        this.angularDamping = 0;

        // If we want to prevent the object from rotating due to physicss
        this.fixedRotation = false;

        // vector of fixtures
        this.fixtureAry = [];
    }
    
    // 
    //  DESC: Copy the passed in data
    //
    copy( obj )
    {
        this.world = obj.world;
        this.bodyType = obj.bodyType;
        this.linearDamping = obj.linearDamping;
        this.angularDamping = obj.angularDamping;
        this.fixedRotation = obj.fixedRotation;
        
        for( let i = 0; i < obj.fixtureAry.length; ++i )
        {
            let fixture = new Fixture;
            fixture.copy( obj.fixtureAry[i] );
            this.fixtureAry.push(fixture);
        }
    }
    
    // 
    //  DESC: Load the object data
    //
    loadObjData( node )
    {
        let physicsNode = node.getElementsByTagName( 'physics' );

        // Check if the object has any physics data
        if( physicsNode.length )
        {
            let attr = physicsNode[0].getAttribute( 'world' );
            if( attr )
                this.world = attr;

            // The body of the physics sprite used for physics
            let bodyNode = physicsNode[0].getElementsByTagName( 'body' );
            if( bodyNode.length )
            {
                // Get the body type - default is static
                attr = bodyNode[0].getAttribute( 'type' );
                if( attr )
                    this.bodyType = attr;

                // The damping is the constant decceleration of movement
                attr = bodyNode[0].getAttribute( 'linearDamping' );
                if( attr )
                    this.linearDamping = Number( attr );

                // The angular damping is the constant decceleration of rotation
                attr = bodyNode[0].getAttribute( 'angularDamping' );
                if( attr )
                    this.angularDamping = Number( attr );

                // Whether the rotation due to physicss is fixed
                attr = bodyNode[0].getAttribute( 'fixedRotation' );
                if( attr )
                    this.fixedRotation = (attr === 'true');
            }

            // The body of the physics sprite used for physics
            let fixtureNode = physicsNode[0].getElementsByTagName( 'fixture' );

            for( let i = 0; i < fixtureNode.length; ++i )
            {
                let fixture = this.fixtureAry[i];

                if( fixture === undefined )
                {
                    fixture = new Fixture;
                    this.fixtureAry.push(fixture);
                }

                // Get the fixture shape
                attr = fixtureNode[i].getAttribute( 'shape' );
                if( attr )
                    fixture.shape = attr;

                // The friction is how much drag this object has on another object
                attr = fixtureNode[i].getAttribute( 'friction' );
                if( attr )
                    fixture.friction = Number( attr );

                // The density is how much the object resists movement
                attr = fixtureNode[i].getAttribute( 'density' );
                if( attr )
                    fixture.density = Number( attr );

                // The restitution is the percentage of velocity retained upon physics
                attr = fixtureNode[i].getAttribute( 'restitution' );
                if( attr )
                    fixture.restitution = Number( attr );

                // Radius if shape is a circle
                attr = fixtureNode[i].getAttribute( 'radius' );
                if( attr )
                    fixture.radius = Number( attr );

                // Is chain shape a loop?
                attr = fixtureNode[i].getAttribute( 'chainLoop' );
                if( attr )
                    fixture.chainLoop = (attr === 'true');

                // Is fixture a sensor?
                attr = fixtureNode[i].getAttribute( 'sensor' );
                if( attr )
                    fixture.sensor = (attr === 'true');

                // See if there is a vert list
                let vertNode = fixtureNode[i].getElementsByTagName( 'vert' );

                for( let j = 0; j < vertNode.length; ++j )
                {
                    fixture.vertAry.push( 
                        new planck_js__WEBPACK_IMPORTED_MODULE_0__.Vec2(
                            Number( vertNode[j].getAttribute('x') ),
                            Number( vertNode[j].getAttribute('y') ) ) );
                }

                // See if the filter is defined
                let filterNode = fixtureNode[i].getElementsByTagName( 'collisionFilter' );
                if( filterNode.length )
                {
                    attr = filterNode[0].getAttribute('categoryBits');
                    if( attr )
                        fixture.filterGroupIndex = Number( attr );

                    attr = filterNode[0].getAttribute('maskBits');
                    if( attr )
                        fixture.filterMaskBits = Number( attr );

                    attr = filterNode[0].getAttribute('groupIndex');
                    if( attr )
                        fixture.filterGroupIndex = Number( attr );
                }

                // The size mod is how much the mesh size should be adjusted on each side
                let sizeModNode = fixtureNode[i].getElementsByTagName( 'sizeMod' );
                if( sizeModNode.length )
                {
                    attr = sizeModNode[0].getAttribute('top');
                    if( attr )
                        fixture.topMod = Number( attr );

                    attr = sizeModNode[0].getAttribute('bottom');
                    if( attr )
                        fixture.bottomMod = Number( attr );

                    attr = sizeModNode[0].getAttribute('left');
                    if( attr )
                        fixture.leftMod = Number( attr );

                    attr = sizeModNode[0].getAttribute('right');
                    if( attr )
                        fixture.rightMod = Number( attr );
                }
            }
        }
    }
    
    // 
    //  DESC: Is this genType active
    //
    isActive()
    {
        return (this.bodyType !== null);
    }
}


/***/ }),
/* 122 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ObjectVisualData2D": () => (/* binding */ ObjectVisualData2D)
/* harmony export */ });
/* harmony import */ var _iobjectvisualdata__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(123);
/* harmony import */ var _common_rect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(21);
/* harmony import */ var _common_color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20);
/* harmony import */ var _common_size__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4);
/* harmony import */ var _common_scaledframe__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(124);
/* harmony import */ var _sprite_spritesheet__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(117);
/* harmony import */ var _managers_texturemanager__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(7);
/* harmony import */ var _managers_vertexbuffermanager__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(42);
/* harmony import */ var _managers_spritesheetmanager__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(116);
/* harmony import */ var _utilities_assetholder__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(33);
/* harmony import */ var _common_defs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(6);
/* harmony import */ var _utilities_xmlparsehelper__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(19);

// 
//  FILE NAME: ojectvisualdata2d.js
//  DESC:      Class containing the 2D object's visual data
//
















class ObjectVisualData2D extends _iobjectvisualdata__WEBPACK_IMPORTED_MODULE_0__.iObjectVisualData
{
    constructor()
    {
        super();
        
        // texture id
        this.textureAry = [];

        // VBO
        this.vbo = null;

        // IBO
        this.ibo = null;

        // VBO/IBO generation type
        this.genType = _common_defs__WEBPACK_IMPORTED_MODULE_10__.EGT_NULL;

        // Name of the shader
        this.shaderID = null;

        // Initial color of the object
        this.color = new _common_color__WEBPACK_IMPORTED_MODULE_2__.Color;

        // texture file path
        this.textureFilePath = '';
        
        // Texture Sequence count
        this.textureSequenceCount = 0;

        // mesh file path
        this.meshFilePath = null;
        
        // Sprite sheet file path
        this.spriteSheetFilePath = null;

        // ibo count
        this.iboCount = 0;

        // The vertex scale of the object
        this.vertexScale = new _common_size__WEBPACK_IMPORTED_MODULE_3__.Size;

        // Scaled frame
        this.scaledFrame = null;

        // Sprite Sheet
        this.spriteSheet = null;

        // String of glyph ids
        this.glyphIDs = null;

        // Default scale
        this.defaultUniformScale = 1;
        
        // Mirror value
        this.mirror = _common_defs__WEBPACK_IMPORTED_MODULE_10__.EM_NULL;
    }
    
    // 
    //  DESC: Copy the passed in data
    //
    copy( obj )
    {
        this.genType = obj.genType;
        this.shaderID = obj.shaderID;
        this.textureFilePath = obj.textureFilePath;
        this.textureSequenceCount = obj.textureSequenceCount;
        this.meshFilePath = obj.meshFilePath;
        this.spriteSheetFilePath = obj.spriteSheetFilePath;
        this.defaultUniformScale = obj.defaultUniformScale;
        this.mirror = obj.mirror;
        this.color.copy( obj.color );
        
        if( obj.glyphIDs )
        {
            if( this.glyphIDs === null )
                this.glyphIDs = [];
            
            for( let i = 0; i < obj.glyphIDs.length; ++i )
                this.glyphIDs[i] = obj.glyphIDs[i];
        }
        
        if( obj.scaledFrame )
        {
            this.scaledFrame = new _common_scaledframe__WEBPACK_IMPORTED_MODULE_4__.ScaledFrame;
            this.scaledFrame.copy( obj.scaledFrame );
        }
        
        if( obj.spriteSheet )
        {
            this.spriteSheet = new _sprite_spritesheet__WEBPACK_IMPORTED_MODULE_5__.SpriteSheet;
            this.spriteSheet.copy( obj.spriteSheet );
        }
    }
    
    // 
    //  DESC: Load the object data
    //
    loadObjData( node )
    {
        let visualNode = node.getElementsByTagName( 'visual' );
        if( visualNode.length )
        {
            let attr = visualNode[0].getAttribute( 'defaultUniformScale' );
            if( attr !== null )
                this.defaultUniformScale = Number(attr);
            
            // See if we have a texture to load
            let textureNode = visualNode[0].getElementsByTagName( 'texture' );
            if( textureNode.length )
            {
                let attr = textureNode[0].getAttribute( 'file' );
                // Check for null because might want to replace with an empty string
                if( attr !== null )
                {
                    this.textureFilePath = attr;
                    this.textureSequenceCount = 1;
                }
                
                attr = textureNode[0].getAttribute( 'count' );
                // Check for null because might want to replace with an empty string
                if( attr !== null )
                    this.textureSequenceCount = Number(attr);
            }

            // Get the mesh node
            let meshNode = visualNode[0].getElementsByTagName( 'mesh' );
            if( meshNode.length )
            {
                let genTypeStr = meshNode[0].getAttribute('genType');
                if( genTypeStr )
                {
                    if( genTypeStr === 'quad' )
                        this.genType = _common_defs__WEBPACK_IMPORTED_MODULE_10__.EGT_QUAD;

                    else if( genTypeStr === 'sprite_sheet' )
                        this.genType = _common_defs__WEBPACK_IMPORTED_MODULE_10__.EGT_SPRITE_SHEET;

                    else if( genTypeStr === 'scaled_frame' )
                        this.genType = _common_defs__WEBPACK_IMPORTED_MODULE_10__.EGT_SCALED_FRAME;

                    else if( genTypeStr === 'mesh_file' )
                        this.genType = _common_defs__WEBPACK_IMPORTED_MODULE_10__.EGT_MESH_FILE;

                    else if( genTypeStr === 'font' )
                        this.genType = _common_defs__WEBPACK_IMPORTED_MODULE_10__.EGT_FONT;
                }
                
                let mirrorStr = meshNode[0].getAttribute('mirror');
                if( mirrorStr )
                {
                    if( mirrorStr === 'horizontal' )
                        this.mirror = _common_defs__WEBPACK_IMPORTED_MODULE_10__.EM_HORIZONTAL;

                    else if( mirrorStr === 'vertical' )
                        this.mirror = _common_defs__WEBPACK_IMPORTED_MODULE_10__.EM_VERTICAL;

                    else if( mirrorStr === 'horizontal_vertical' )
                        this.mirror = _common_defs__WEBPACK_IMPORTED_MODULE_10__.EM_HORIZONTAL_VERTICAL;
                }
                
                let spriteSheetNode = meshNode[0].getElementsByTagName( 'spriteSheet' );
                if( spriteSheetNode.length )
                {
                    let defaultIndex = 0;
                    let glyphCount = 0;
                    let columns = 0;
                    
                    let attr = spriteSheetNode[0].getAttribute( 'defIndex' );
                    if( attr !== null )
                        defaultIndex = Number(attr);

                    // Make sure all elements are defined for manually building the sprite sheet data
                    attr = spriteSheetNode[0].getAttribute( 'glyphCount' );
                    if( attr !== null )
                    {
                        glyphCount = Number(attr);

                        attr = spriteSheetNode[0].getAttribute( 'columns' );
                        if( attr !== null )
                            columns = Number(attr);
                    }
                    
                    // Get the sprite sheet glyph file
                    attr = spriteSheetNode[0].getAttribute( 'file' );
                    // Check for null because might want to replace with an empty string
                    if( attr !== null )
                        this.spriteSheetFilePath = attr;

                    // See if any glyph Id's have been defined
                    let glyphNode = spriteSheetNode[0].getElementsByTagName( 'glyph' );
                    if( glyphNode.length )
                    {
                        this.glyphIDs = [];
                        for( let i = 0; i < glyphNode.length; ++i )
                            this.glyphIDs.push( glyphNode[i].getAttribute( 'id' ) );
                    }
                    
                    // make sure this is a valid sprite sheet before allocating
                    if( (this.spriteSheet === null) && (this.glyphIDs || defaultIndex || glyphCount || columns) )
                        this.spriteSheet = new _sprite_spritesheet__WEBPACK_IMPORTED_MODULE_5__.SpriteSheet( defaultIndex, glyphCount, columns );
                }

                let scaledFrameNode = meshNode[0].getElementsByTagName( 'scaledFrame' );
                if( scaledFrameNode.length )
                {
                    if( this.scaledFrame === null )
                        this.scaledFrame = new _common_scaledframe__WEBPACK_IMPORTED_MODULE_4__.ScaledFrame;
                    
                    this.scaledFrame.frame.w = Number(scaledFrameNode[0].getAttribute( 'thicknessWidth' ));
                    this.scaledFrame.frame.h = Number(scaledFrameNode[0].getAttribute( 'thicknessHeight' ));

                    let centerQuadAttr = scaledFrameNode[0].getAttribute( 'centerQuad' );
                    if( centerQuadAttr )
                        this.scaledFrame.centerQuad = (centerQuadAttr === 'true');

                    let frameBottomAttr = scaledFrameNode[0].getAttribute('frameBottom');
                    if( frameBottomAttr )
                        this.scaledFrame.bottomFrame = (frameBottomAttr === 'true');
                }

                let fileNode = meshNode[0].getElementsByTagName( 'file' );
                if( fileNode.length )
                    this.meshFilePath = fileNode[0].getAttribute( 'name' );
            }

            // The shader node determines which shader to use
            let shaderNode = visualNode[0].getElementsByTagName( 'shader' );
            if( shaderNode.length )
            {
                this.shaderID = shaderNode[0].getAttribute( 'id' );
            }

            // Load the color
            this.color = _utilities_xmlparsehelper__WEBPACK_IMPORTED_MODULE_11__.loadColor( visualNode[0], this.color );

            // Raise an exception if there's a genType but no shader
            if( (this.genType != _common_defs__WEBPACK_IMPORTED_MODULE_10__.EGT_NULL) && (this.shaderID === null) )
                throw new Error( 'Shader effect or techique not set!' );
        }
    }
    
    // 
    //  DESC: Create the objects from data
    //
    createFromData( group, size )
    {
        // Set the texture ID if one exists
        if( this.textureFilePath.length )
        {
            // Get the texture(s) for this object
            if( this.textureSequenceCount )
            {
                for( let i = 0; i < this.textureSequenceCount; ++i )
                {
                    let NUM = i; // NUM is defined in the file path and is consumed by the "eval' statement"
                    let filePath = eval('`' + this.textureFilePath + '`');
                    this.textureAry.push( _managers_texturemanager__WEBPACK_IMPORTED_MODULE_6__.textureManager.get( group, filePath ) );
                }
            }
            else
                this.textureAry.push( _managers_texturemanager__WEBPACK_IMPORTED_MODULE_6__.textureManager.get( group, this.textureFilePath ) );
            
            // If the passed in size is empty, set it to the texture size
            if( size.isEmpty() )
                size.copy( this.textureAry[0].size );
        }
        
        if( this.genType === _common_defs__WEBPACK_IMPORTED_MODULE_10__.EGT_QUAD )
        {
            this.generateQuad( group );
            
            this.vertexScale.w = size.w * this.defaultUniformScale;
            this.vertexScale.h = size.h * this.defaultUniformScale;
            size.w = Math.trunc(this.vertexScale.w);
            size.h = Math.trunc(this.vertexScale.h);
        }
        else if( this.genType === _common_defs__WEBPACK_IMPORTED_MODULE_10__.EGT_SPRITE_SHEET )
        {
            // Build the simple (grid) sprite sheet from XML data
            if( this.spriteSheetFilePath === null )
                this.spriteSheet.build( size );

            // Load complex sprite sheet data from the manager. It's assumed
            // that string Id's are for complex sprite sheets that are shared
            // among many sprites
            else
            {
                // This will return the sprite sheet if it's been loaded
                let spriteSheet = _managers_spritesheetmanager__WEBPACK_IMPORTED_MODULE_8__.spriteSheetManager.get( group, this.spriteSheetFilePath );

                // Copy the needed glyph data from the manager
                spriteSheet.copyTo( this.spriteSheet, this.glyphIDs );
            }

            // Generate a quad
            this.generateQuad( group );

            // For this generation type, the glyph size is the default scale
            let glyphSize = this.spriteSheet.getGlyph().size;

            this.vertexScale.w = glyphSize.w * this.defaultUniformScale;
            this.vertexScale.h = glyphSize.h * this.defaultUniformScale;
            size.w = Math.trunc(this.vertexScale.w);
            size.h = Math.trunc(this.vertexScale.h);
        }
        else if( this.genType === _common_defs__WEBPACK_IMPORTED_MODULE_10__.EGT_SCALED_FRAME )
        {
            if( this.glyphIDs !== null )
            {
                // This will return the sprite sheet
                let spriteSheet = _managers_spritesheetmanager__WEBPACK_IMPORTED_MODULE_8__.spriteSheetManager.get( group, this.spriteSheetFilePath );

                // Get the glyph to make the frame with
                let glyph = spriteSheet.findGlyph( this.glyphIDs[0] );
                
                // Create the scaled frame using glyph info
                if( this.meshFilePath )
                    this.generateScaledFrameMeshFile( group, this.textureAry[0].size, glyph.size, size, glyph.uv );
                else
                    this.generateScaledFrame( group, this.textureAry[0].size, glyph.size, size, glyph.uv );
            }
            else if( this.meshFilePath )
                this.generateScaledFrameMeshFile( group, this.textureAry[0].size, this.textureAry[0].size, size, new _common_rect__WEBPACK_IMPORTED_MODULE_1__.Rect );

            else
                // Generate a scaled frame
                this.generateScaledFrame( group, this.textureAry[0].size, this.textureAry[0].size, size, new _common_rect__WEBPACK_IMPORTED_MODULE_1__.Rect );
        }
    }
    
    // 
    //  DESC: Generate a quad
    //
    generateQuad( group )
    {
        // VBO data
        // The order of the verts is counter clockwise
        // 1----0
        // |   /|
        // |  / |
        // | /  |
        // 2----3
        let vertAry =
        [
             0.5,  0.5, 0.0,   1.0, 0.0,
            -0.5,  0.5, 0.0,   0.0, 0.0,
            -0.5, -0.5, 0.0,   0.0, 1.0,
             0.5, -0.5, 0.0,   1.0, 1.0
        ];
        
        let horzStr = '';
        let vertStr = '';
        
        if( (this.mirror === _common_defs__WEBPACK_IMPORTED_MODULE_10__.EM_HORIZONTAL) || (this.mirror === _common_defs__WEBPACK_IMPORTED_MODULE_10__.EM_HORIZONTAL_VERTICAL) )
        {
            horzStr = '_horz';
            
            vertAry[5 * 0 + 3] = 0.0;
            vertAry[5 * 1 + 3] = 1.0;
            vertAry[5 * 2 + 3] = 1.0;
            vertAry[5 * 3 + 3] = 0.0;
        }
        
        if( (this.mirror === _common_defs__WEBPACK_IMPORTED_MODULE_10__.EM_VERTICAL) || (this.mirror === _common_defs__WEBPACK_IMPORTED_MODULE_10__.EM_HORIZONTAL_VERTICAL) )
        {
            vertStr = '_vert';
            
            vertAry[5 * 0 + 4] = 1.0;
            vertAry[5 * 1 + 4] = 1.0;
            vertAry[5 * 2 + 4] = 0.0;
            vertAry[5 * 3 + 4] = 0.0;
        }
        
        this.vbo = _managers_vertexbuffermanager__WEBPACK_IMPORTED_MODULE_7__.vertexBufferManager.createVBO( group, 'guad_0011' + horzStr + vertStr, vertAry );
        this.ibo = _managers_vertexbuffermanager__WEBPACK_IMPORTED_MODULE_7__.vertexBufferManager.createIBO( group, 'quad_0123', [0, 1, 2, 3], true );
        
        this.iboCount = 4;
    }
    
    // 
    //  DESC: Generate a scaled frame
    //
    generateScaledFrame( group, textureSize, glyphSize, frameSize, textureOffset )
    {
        let frame = this.scaledFrame.frame;
        let tSize = textureSize;
        let gSize = glyphSize;
        let vboName = 'scaled_frame_' + frameSize.w + '_' + frameSize.h + '_' + frame.w + '_' + frame.h + '_' + tSize.w + '_' + tSize.h + '_' + gSize.w + '_' + gSize.h;

        this.vbo = _managers_vertexbuffermanager__WEBPACK_IMPORTED_MODULE_7__.vertexBufferManager.createScaledFrame(
            group, vboName, this.scaledFrame, textureSize, glyphSize, frameSize, textureOffset );

        let iboAry = [
            0,1,2,     0,3,1,
            2,4,5,     2,1,4,
            1,6,4,     1,7,6,
            7,8,6,     7,9,8,
            10,9,7,    10,11,9,
            12,11,10,  12,13,11,
            14,10,3,   14,12,10,
            15,3,0,    15,14,3,
            3,7,1,     3,10,7 ];

        // Create the reusable IBO buffer
        this.ibo = _managers_vertexbuffermanager__WEBPACK_IMPORTED_MODULE_7__.vertexBufferManager.createIBO( group, 'scaled_frame', iboAry, true );

        // Set the ibo count depending on the number of quads being rendered
        // If the center quad is not used, just adjust the ibo count because
        // the center quad is just reused verts anyways and is that last 6 in the IBO
        // If the frame bottom is not being use, just subtract.
        // Center quad and no frame bottom can't co-exist.
        this.iboCount = 6 * 8;
        if( this.scaledFrame.centerQuad )
            this.iboCount += 6;

        else if( !this.scaledFrame.bottomFrame )
            this.iboCount -= 6 * 3;
    }

    // 
    //  DESC: Generate a scaled frame with a mesh file
    //
    generateScaledFrameMeshFile( group, textureSize, glyphSize, frameSize, textureOffset )
    {
        // Construct the name used for vbo and ibo
        let name = 'scaled_frame_mesh_' + this.meshFilePath;
        
        let iboAry = [
                0,1,2,     0,3,1,
                2,4,5,     2,1,4,
                1,6,4,     1,7,6,
                7,8,6,     7,9,8,
                10,9,7,    10,11,9,
                12,11,10,  12,13,11,
                14,10,3,   14,12,10,
                15,3,0,    15,14,3 ];

        if( this.scaledFrame.centerQuad )
            Array.prototype.push.apply( iboAry, [ 3,7,1, 3,10,7 ] );

        // See if it already exists before loading the mesh file
        this.vbo = _managers_vertexbuffermanager__WEBPACK_IMPORTED_MODULE_7__.vertexBufferManager.isVBO( group, name );
        if( this.vbo === null )
        {
            // Load a mesh from XML file
            let meshFileVertAry = [];
            this.loadMeshFromXML( group, textureSize, frameSize, textureOffset, 16, meshFileVertAry, iboAry );

            // create the vbo
            this.vbo = _managers_vertexbuffermanager__WEBPACK_IMPORTED_MODULE_7__.vertexBufferManager.createScaledFrame(
                group, name, this.scaledFrame, textureSize, glyphSize, frameSize, textureOffset, meshFileVertAry );
        }
        
        // Create the reusable IBO buffer
        this.ibo = _managers_vertexbuffermanager__WEBPACK_IMPORTED_MODULE_7__.vertexBufferManager.createIBO( group, name, iboAry, true );
        this.iboCount = iboAry.length;
    }
    
    // 
    //  DESC: Load a mesh from XML file
    //
    loadMeshFromXML( group, textureSize, frameSize, textureOffset, iboOffset, vertAry, iboAry )
    {
        // Check if the width or height is odd. If so, we offset 
        // by 0.5 for proper orthographic rendering
        let additionalOffsetX = 0;
        if( Math.trunc(frameSize.w) % 2 != 0 )
            additionalOffsetX = 0.5;

        let additionalOffsetY = 0;
        if( Math.trunc(frameSize.h) % 2 != 0 )
            additionalOffsetY = 0.5;

        // This converts the data to a center aligned vertex buffer
        let centerAlignSize = new _common_size__WEBPACK_IMPORTED_MODULE_3__.Size(-(frameSize.w / 2), (frameSize.h / 2));

        // Open and parse the XML file:
        let node = _utilities_assetholder__WEBPACK_IMPORTED_MODULE_9__.assetHolder.get( group, this.meshFilePath );
        let vboNode = node.getElementsByTagName( 'vbo' );
        
        if( vboNode.length )
        {
            let vertNode = vboNode[0].getElementsByTagName( 'vert' );

            for( let i = 0; i < vertNode.length; ++i )
            {
                // Load the 2D vert
                let vert = _utilities_xmlparsehelper__WEBPACK_IMPORTED_MODULE_11__.loadVertex2d( vertNode[i] );
                
                // This converts the data to a center aligned vertex buffer
                vertAry.push( centerAlignSize.w + vert.x + additionalOffsetX );
                vertAry.push( centerAlignSize.h - vert.y + additionalOffsetY );
                vertAry.push( vert.z );
                vertAry.push( textureOffset.x1 + (vert.u / textureSize.w) );
                vertAry.push( textureOffset.y1 + (vert.v / textureSize.h) );
            }
        }

        let iboNode = node.getElementsByTagName( 'ibo' );
        if( iboNode.length )
        {
            let iNode = iboNode[0].getElementsByTagName( 'i' );
            
            for( let i = 0; i < iNode.length; ++i )
                iboAry.push( iboOffset + Number(iNode[i].childNodes[0].nodeValue) );
        }
    }
    
    // 
    //  DESC: Is this genType active
    //
    isActive()
    {
        return (this.genType !== _common_defs__WEBPACK_IMPORTED_MODULE_10__.EGT_NULL);
    }
    
    // 
    //  DESC: Get the frame count
    //
    getFrameCount()
    {
        if( this.genType === _common_defs__WEBPACK_IMPORTED_MODULE_10__.EGT_SPRITE_SHEET )
            return this.spriteSheet.getCount();

        return this.textureAry.length;
    }
    
    // 
    //  DESC: Get the texture
    //
    getTexture( index = 0 )
    {
        if( this.textureAry.length > index )
            return this.textureAry[index];

        return null;
    }
    
    // 
    //  DESC: Get the texture file paths
    //
    getTextureFilePathAry()
    {
        let filePathAry = [];
        
        // Get the texture(s) for this object
        if( this.textureSequenceCount )
        {
            for( let i = 0; i < this.textureSequenceCount; ++i )
            {
                let NUM = i; // NUM is defined in the file path and is consumed by the "eval' statement"
                filePathAry.push( eval('`' + this.textureFilePath + '`') );
            }
        }
        else if( this.textureFilePath.length )
            filePathAry.push( this.textureFilePath );
        
        return filePathAry;
    }
}


/***/ }),
/* 123 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "iObjectVisualData": () => (/* binding */ iObjectVisualData)
/* harmony export */ });

// 
//  FILE NAME: iobjectvisualdata.js
//  DESC:      Object visual data interface class
//



class iObjectVisualData
{
    constructor()
    {
    }
    
    // 
    //  DESC: Is this genType active
    //
    isActive()
    {
        return false;
    }
    
    // 
    //  DESC: Get the frame count
    //
    getFrameCount()
    {
        return 1;
    }
}


/***/ }),
/* 124 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ScaledFrame": () => (/* binding */ ScaledFrame)
/* harmony export */ });
/* harmony import */ var _common_size__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);

// 
//  FILE NAME:  scaledframe.js
//  DESC:       Class for holding scaled frame data
//




class ScaledFrame
{
    constructor()
    {
        // Size of the frame
        this.frame = new _common_size__WEBPACK_IMPORTED_MODULE_0__.Size;

        // Is there a center quad?
        this.centerQuad = true;
    
        // Is there a bottom frame?
        this.bottomFrame = true;
    }
    
    // 
    //  DESC: Copy the passed in data
    //
    copy( obj )
    {
        this.frame.copy( obj.frame );
        this.centerQuad = obj.centerQuad;
        this.bottomFrame = obj.bottomFrame;
    }
}


/***/ }),
/* 125 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ObjectData3D": () => (/* binding */ ObjectData3D)
/* harmony export */ });
/* harmony import */ var _iobjectdata__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(120);
/* harmony import */ var _objectvisualdata3d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(126);

// 
//  FILE NAME: objectdata3d.js
//  DESC:      Class that holds a 3D object data
//




//import { ObjectPhysicsData3D } from '../objectdatamanager/objectphysicsdata3d';


class ObjectData3D extends _iobjectdata__WEBPACK_IMPORTED_MODULE_0__.iObjectData
{
    constructor()
    {
        super();

        // Visual data of the object
        this.visualData = new _objectvisualdata3d__WEBPACK_IMPORTED_MODULE_1__.ObjectVisualData3D;

        // Physics data of the object
        //CObjectPhysicsData2D m_physicsData;

        // The name of the object data
        this.name = null;

        // The group the object data is in
        this.group = null;
    }
    
    // 
    //  DESC: Copy the passed in data
    //
    copy( obj )
    {
        this.visualData.copy( obj.visualData );
    }
    
    // 
    //  DESC: Load the object data from the passed in node
    //
    loadObjData( xmlNode, group, name )
    {
        this.name = name;
        this.group = group;

        // Load the visual data
        this.visualData.loadObjData( xmlNode );

        // Load the physics data
        //m_physicsData.LoadFromNode( xmlNode );
    }
    
    // 
    //  DESC: Add the textures to the mesh with the "createFromData" call
    //
    createFromData( group )
    {
        // Create the visuales
        this.visualData.addTexturesToMesh( group );
    }

    // 
    //  DESC: Is this 3D object data?
    //
    is3D()
    {
        return true;
    }
}


/***/ }),
/* 126 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ObjectVisualData3D": () => (/* binding */ ObjectVisualData3D)
/* harmony export */ });
/* harmony import */ var _iobjectvisualdata__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(123);
/* harmony import */ var _common_color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(20);
/* harmony import */ var _managers_texturemanager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);
/* harmony import */ var _utilities_xmlparsehelper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(19);

// 
//  FILE NAME: ojectvisualdata3d.js
//  DESC:      Class containing the 3D object's visual data
//








class ObjectVisualData3D extends _iobjectvisualdata__WEBPACK_IMPORTED_MODULE_0__.iObjectVisualData
{
    constructor()
    {
        super();
        
        // Mesh group object
        this.meshGrp = null;

        // Name of the shader
        this.shaderID = null;

        // Initial color of the object
        this.color = new _common_color__WEBPACK_IMPORTED_MODULE_1__.Color;

        // mesh file path
        this.meshFilePath = null;
    }
    
    // 
    //  DESC: Copy the passed in data
    //
    copy( obj )
    {
        this.shaderID = obj.shaderID;
        this.meshFilePath = obj.meshFilePath;
        this.color.copy( obj.color );
        this.meshGrp = obj.meshGrp;
    }
    
    // 
    //  DESC: Load the object data
    //
    loadObjData( node )
    {
        let visualNode = node.getElementsByTagName('visual');
        if( visualNode.length )
        {
            let attr = visualNode[0].getAttribute('file');
            // Check for null because might want to replace with an empty string
            if( attr !== null )
                this.meshFilePath = attr;
                
            // The shader node determines which shader to use
            let shaderNode = visualNode[0].getElementsByTagName( 'shader' );
            if( shaderNode.length )
            {
                this.shaderID = shaderNode[0].getAttribute( 'id' );
            }

            // Load the color
            this.color = _utilities_xmlparsehelper__WEBPACK_IMPORTED_MODULE_3__.loadColor( visualNode[0], this.color );
        }
    }
    
    // 
    //  DESC: Add the textures to the mesh
    //
    addTexturesToMesh( group )
    {
        for( let i = 0; i < this.meshGrp.meshAry.length; ++i )
        {
            for( let j = 0; j < this.meshGrp.meshAry[i].textureIndexAry.length; ++j )
            {
                let textIndex = this.meshGrp.meshAry[i].textureIndexAry[j]
                
                let textPath = this.meshGrp.uniqueTexturePathAry[textIndex].path;
                
                this.meshGrp.meshAry[i].textureAry.push( _managers_texturemanager__WEBPACK_IMPORTED_MODULE_2__.textureManager.get( group, textPath ) );
            }
        }
    }
    
    // 
    //  DESC: Is this genType active
    //
    isActive()
    {
        return (this.meshGrp !== null);
    }
}


/***/ }),
/* 127 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "create": () => (/* binding */ create)
/* harmony export */ });
/* harmony import */ var _uilabel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(128);
/* harmony import */ var _uibutton__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(133);
/* harmony import */ var _uisubcontrol__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(134);
/* harmony import */ var _uibuttonlist__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(135);
/* harmony import */ var _uicheckbox__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(136);
/* harmony import */ var _uislider__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(137);
/* harmony import */ var _uiscrollbox__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(138);
/* harmony import */ var _uimeter__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(139);
/* harmony import */ var _uiprogressbar__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(141);
// 
//  FILE NAME: uicontrolfactory.js
//  DESC:      factory for control creation
//












// 
//  DESC: Create the control info from XML node
//
function create( node, group )
{
    let control = null;

    // Get the control type. This is required
    let ctrlType = node.getAttribute( 'controlType' );

    // New up the control with its respected control type
    if( ctrlType === 'label' )
        control = new _uilabel__WEBPACK_IMPORTED_MODULE_0__.UILabel( group );

    else if( ctrlType === 'button' )
        control = new _uibutton__WEBPACK_IMPORTED_MODULE_1__.UIButton( group );

    else if( ctrlType === 'sub_control' )
        control = new _uisubcontrol__WEBPACK_IMPORTED_MODULE_2__.UISubControl( group );

    else if( ctrlType === 'button_list' )
        control = new _uibuttonlist__WEBPACK_IMPORTED_MODULE_3__.UIButtonList( group );

    else if( ctrlType === 'check_box' )
        control = new _uicheckbox__WEBPACK_IMPORTED_MODULE_4__.UICheckBox( group );

    else if( ctrlType === 'slider' )
        control = new _uislider__WEBPACK_IMPORTED_MODULE_5__.UISlider( group );

    else if( ctrlType === 'scroll_box' )
        control = new _uiscrollbox__WEBPACK_IMPORTED_MODULE_6__.UIScrollBox( group );

    else if( ctrlType === 'meter' )
        control = new _uimeter__WEBPACK_IMPORTED_MODULE_7__.UIMeter( group );

    else if( ctrlType === 'progress_bar' )
        control = new _uiprogressbar__WEBPACK_IMPORTED_MODULE_8__.UIProgressBar( group );

    else
        throw new Error( `UI Control not defined! (${ctrlType})` );

    // Have the control load it's share
    control.loadFromNode( node );

    return control;

}


/***/ }),
/* 128 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UILabel": () => (/* binding */ UILabel)
/* harmony export */ });
/* harmony import */ var _uicontrol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(129);
/* harmony import */ var _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(132);

// 
//  FILE NAME: uilabel.js
//  DESC:      Class for user interface labels
//





class UILabel extends _uicontrol__WEBPACK_IMPORTED_MODULE_0__.UIControl
{
    constructor( group )
    {
        super( group );
        
        this.type = _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_1__.ECT_LABEL;
    }
}



/***/ }),
/* 129 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UIControl": () => (/* binding */ UIControl)
/* harmony export */ });
/* harmony import */ var _controlbase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(130);
/* harmony import */ var _scrollparam__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(35);
/* harmony import */ var _sprite_sprite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
/* harmony import */ var _common_size__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4);
/* harmony import */ var _common_point__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(14);
/* harmony import */ var _common_quad__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(131);
/* harmony import */ var _common_rect__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(21);
/* harmony import */ var _utilities_matrix__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(12);
/* harmony import */ var _utilities_settings__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(3);
/* harmony import */ var _objectdatamanager_objectdatamanager__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(112);
/* harmony import */ var _managers_eventmanager__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(30);
/* harmony import */ var _managers_actionmanager__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(27);
/* harmony import */ var _utilities_xmlparsehelper__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(19);
/* harmony import */ var _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(132);
/* harmony import */ var _gui_menudefs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(36);
/* harmony import */ var _common_defs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(6);

// 
//  FILE NAME: uicontrol.js
//  DESC:      class for user interface controls
//




















class UIControl extends _controlbase__WEBPACK_IMPORTED_MODULE_0__.ControlBase
{
    constructor( group )
    {
        super( group );
        
        // sprite array
        this.spriteAry = [];

        // control's default state
        this.defaultState;

        // control's current state
        this.state = _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_NULL;
        this.lastState = _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_NULL;

        // Name of the action to perform under the correct circumstances
        this.executionAction;

        // How the control should respond when selected
        this.actionType = _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECAT_NULL;

        // This control's size
        this.size = new _common_size__WEBPACK_IMPORTED_MODULE_3__.Size;

        // This is the size modifier
        // when calculating the collision rect
        this.sizeModifier = new _common_rect__WEBPACK_IMPORTED_MODULE_6__.Rect;

        // Collision rect
        this.collisionQuad = new _common_quad__WEBPACK_IMPORTED_MODULE_5__.Quad;

        // Collision center
        this.collisionCenter = new _common_point__WEBPACK_IMPORTED_MODULE_4__.Point;

        // Mouse selection type
        this.mouseSelectType = _common_defs__WEBPACK_IMPORTED_MODULE_15__.EAP_UP;

        // Scrolling parameters
        this.scrollParam = null;
    }
    
    // 
    //  DESC: Load the control info from XML node
    //
    loadFromNode( xmlNode )
    {
        super.loadFromNode( xmlNode );

        // Set the default state of the control
        let attr = xmlNode.getAttribute( 'defaultState' );
        if( attr )
            this.setDefaultState( attr );

        // Set if mouse selection is the down message
        attr = xmlNode.getAttribute( 'mouseSelectDown' );
        if( attr && (attr === 'true') )
            this.mouseSelectType = _common_defs__WEBPACK_IMPORTED_MODULE_15__.EAP_DOWN;

        // Setup the action
        let actionNode = xmlNode.getElementsByTagName( 'action' );
        if( actionNode.length )
        {
            // Set the action type
            attr = actionNode[0].getAttribute( 'actionType' )
            if( attr )
                this.setActionType( attr );

            // Set the execution action
            attr = actionNode[0].getAttribute( 'executionAction' )
            if( attr )
                this.executionAction = attr;
        }

        // Check for scripting
        let scriptList = xmlNode.getElementsByTagName( 'scriptList' );
        if( scriptList.length )
            this.scriptComponent.initScriptIds( scriptList[0] );

        // Load the scroll data from node
        let scrollParamNode = xmlNode.getElementsByTagName( 'scroll' );
        if( scrollParamNode.length )
        {
            this.scrollParam = new _scrollparam__WEBPACK_IMPORTED_MODULE_1__.ScrollParam;
            this.scrollParam.loadFromNode( scrollParamNode );
        }

        // Get the size modifier info
        this.sizeModifier = _utilities_xmlparsehelper__WEBPACK_IMPORTED_MODULE_12__.loadRect( xmlNode );

        // Init to the default state
        this.revertToDefaultState();
    }

    // 
    //  DESC: Load the control specific info from XML node
    //
    loadControlFromNode( xmlNode )
    {
        // Get the list of object data associated with this button
        let spriteNode = xmlNode.getElementsByTagName( 'sprite' );
        if( spriteNode.length )
        {
            // This is to get around the fact that objects are passed by "copy of reference".
            // This simulates passing an int by reference.
            let fontSpriteCount = [0];

            // Load the sprite from node
            for( let i = 0; i < spriteNode.length; ++i )
                this.loadSpriteFromNode( spriteNode[i], fontSpriteCount );
        }
    }

    // 
    //  DESC: Load a sprite from an XML node
    //
    loadSpriteFromNode( xmlNode, fontSpriteCount )
    {
        // Get the type of object
        let objectName = xmlNode.getAttribute( 'objectName' );

        // allocate the sprite in the array
        let sprite = new _sprite_sprite__WEBPACK_IMPORTED_MODULE_2__.Sprite( _objectdatamanager_objectdatamanager__WEBPACK_IMPORTED_MODULE_9__.objectDataManager.getData( this.group, objectName ) );
        this.spriteAry.push( sprite );

        // Load the sprite data
        sprite.load( xmlNode );

        // See if this sprite is used for rendering a font string
        if( sprite.visualComponent.isFontSprite() )
        {
            // Set the font string to be created later
            if( this.stringAry.length && (fontSpriteCount[0] < this.stringAry.length) && (sprite.visualComponent.fontData.fontString === '' ) )
            {
                sprite.visualComponent.setFontString( this.stringAry[ fontSpriteCount[0] ] );
                ++fontSpriteCount[0];
            }

            // set the color if it is different
            sprite.visualComponent.color = _utilities_xmlparsehelper__WEBPACK_IMPORTED_MODULE_12__.loadColor( xmlNode, sprite.visualComponent.color );
        }
        else
        {
            // Find the largest size width and height of the different sprites for the controls size
            let width = sprite.objData.size.w + Math.abs( sprite.pos.x );
            let height = sprite.objData.size.h + Math.abs( sprite.pos.y );

            if( width > this.size.w )
                this.size.w = width;

            if( height > this.size.h )
                this.size.h = height;
        }
    }

    // 
    //  DESC: Update the control
    //
    update()
    {
        this.scriptComponent.update();

        for( let i = 0; i < this.spriteAry.length; ++i )
            this.spriteAry[i].update();
    }

    // 
    //  DESC: Transform the control
    //
    transform( object = null )
    {
        if( object )
            super.transform( object );
        else
            super.transform();

        for( let i = 0; i < this.spriteAry.length; ++i )
            this.spriteAry[i].transform( this );

        // Transform the collision
        this.transformCollision();
    }

    // 
    //  DESC: Transform the collision
    //
    transformCollision()
    {
        if( this.wasWorldPosTranformed() && !this.size.isEmpty() )
        {
            let finalMatrix = new _utilities_matrix__WEBPACK_IMPORTED_MODULE_7__.Matrix( this.matrix );
            finalMatrix.scaleFromValue( _utilities_settings__WEBPACK_IMPORTED_MODULE_8__.settings.orthoAspectRatio.h );
            finalMatrix.invertY();

            // Get half the screen size to convert to screen coordinates
            let screenHalf = _utilities_settings__WEBPACK_IMPORTED_MODULE_8__.settings.size_half;

            // Create the rect of the control based on half it's size
            let halfwidth = this.size.w * 0.5;
            let halfHeight = this.size.h * 0.5;

            let quad = new _common_quad__WEBPACK_IMPORTED_MODULE_5__.Quad;
            quad.point[0].x = -halfwidth + -this.sizeModifier.x1;
            quad.point[0].y = -halfHeight + -this.sizeModifier.y1;
            quad.point[1].x = halfwidth + this.sizeModifier.x2;
            quad.point[1].y = -halfHeight + -this.sizeModifier.y1;
            quad.point[2].x = halfwidth + this.sizeModifier.x2;
            quad.point[2].y = halfHeight + this.sizeModifier.y2;
            quad.point[3].x = -halfwidth + -this.sizeModifier.x1;
            quad.point[3].y = halfHeight + this.sizeModifier.y2;

            finalMatrix.transformQuad( this.collisionQuad, quad );

            // Convert the translated rect to screen coordinates
            this.collisionQuad.point[0].x += screenHalf.w;
            this.collisionQuad.point[0].y += screenHalf.h;
            this.collisionQuad.point[1].x += screenHalf.w;
            this.collisionQuad.point[1].y += screenHalf.h;
            this.collisionQuad.point[2].x += screenHalf.w;
            this.collisionQuad.point[2].y += screenHalf.h;
            this.collisionQuad.point[3].x += screenHalf.w;
            this.collisionQuad.point[3].y += screenHalf.h;

            finalMatrix.transformPoint( this.collisionCenter, new _common_point__WEBPACK_IMPORTED_MODULE_4__.Point );

            // Convert to screen coordinates
            this.collisionCenter.x += screenHalf.w;
            this.collisionCenter.y += screenHalf.h;
        }
    }

    // 
    //  DESC: do the render
    //
    render( camera )
    {
        for( let i = 0; i < this.spriteAry.length; ++i )
            this.spriteAry[i].render( camera );
    }

    // 
    //  DESC: Handle events
    //
    handleEvent( event )
    {
        if( event.type === _gui_menudefs__WEBPACK_IMPORTED_MODULE_14__.EGE_MENU_CONTROL_STATE_CHANGE )
        {
            this.onStateChange( event );
        }
        else if( event.type === _gui_menudefs__WEBPACK_IMPORTED_MODULE_14__.EGE_MENU_SELECT_EXECUTE )
        {
            this.onSelectExecute( event );
        }
        else if( event.type === _gui_menudefs__WEBPACK_IMPORTED_MODULE_14__.EGE_MENU_SET_ACTIVE_CONTROL )
        {
            this.onSetActiveControl( event );
        }
        else if( event.type === _gui_menudefs__WEBPACK_IMPORTED_MODULE_14__.EGE_MENU_REACTIVATE )
        {
            this.onReactivate( event );
        }
        else if( event.type === _gui_menudefs__WEBPACK_IMPORTED_MODULE_14__.EGE_MENU_TRANS_IN )
        {
            this.onTransIn( event );
        }
        else if( event.type === _gui_menudefs__WEBPACK_IMPORTED_MODULE_14__.EGE_MENU_TRANS_OUT )
        {
            this.onTransOut( event );
        }

        // Prepare script function associated with handling this game event
        this.prepareControlScript( _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_EVENT, event );
    }

    // 
    //  DESC: Handle OnTransIn message
    //
    onTransIn( event )
    {
        if( event.arg[0] === _gui_menudefs__WEBPACK_IMPORTED_MODULE_14__.ETC_BEGIN )
        {
            // Set the script functions for the current displayed state
            if( this.lastState != this.state )
                this.setDisplayState();
            
            // Prepare script function associated with handling this game event
            this.prepareControlScript( _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_TRANS_IN );
        }
    }

    // 
    //  DESC: Handle OnTransOut message
    //
    onTransOut( event )
    {
        if( event.arg[0] === _gui_menudefs__WEBPACK_IMPORTED_MODULE_14__.ETC_BEGIN )
        {
            // Reset the control
            this.reset();

            // Reset the sprite scripts
            this.resetSpriteScript();

            // Set the script functions for the current displayed state
            if( this.lastState != this.state )
                this.setDisplayState();
            
            // Prepare script function associated with handling this game event
            this.prepareControlScript( _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_TRANS_OUT );
        }
    }

    // 
    //  DESC: Handle OnStateChange message
    //
    onStateChange( event )
    {
        // This control is the focus of the state change
        // The control's "this" pointer is used as a means of identification
        if( event.arg[1] === this )
            this.changeState( event.arg[0] );
        else
            this.deactivateControl();
    }

    // 
    //  DESC: Handle OnSelectExecute message
    //
    onSelectExecute( /*event*/ )
    {
        if( this.state === _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_SELECT )
        {
            if( this.actionType === _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECAT_TO_TREE )
                _managers_eventmanager__WEBPACK_IMPORTED_MODULE_10__.eventManager.dispatchEvent( _gui_menudefs__WEBPACK_IMPORTED_MODULE_14__.EGE_MENU_TO_TREE, this.executionAction );

            else if( this.actionType === _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECAT_TO_MENU )
                _managers_eventmanager__WEBPACK_IMPORTED_MODULE_10__.eventManager.dispatchEvent( _gui_menudefs__WEBPACK_IMPORTED_MODULE_14__.EGE_MENU_TO_MENU, this.executionAction, this );

            else if( this.actionType === _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECAT_BACK )
                _managers_eventmanager__WEBPACK_IMPORTED_MODULE_10__.eventManager.dispatchEvent( _gui_menudefs__WEBPACK_IMPORTED_MODULE_14__.EGE_MENU_BACK_ACTION );

            else if( this.actionType === _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECAT_CLOSE )
                _managers_eventmanager__WEBPACK_IMPORTED_MODULE_10__.eventManager.dispatchEvent( _gui_menudefs__WEBPACK_IMPORTED_MODULE_14__.EGE_MENU_TOGGLE_ACTION );

            else if( this.actionType === _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECAT_GAME_STATE_CHANGE )
                _managers_eventmanager__WEBPACK_IMPORTED_MODULE_10__.eventManager.dispatchEvent( _gui_menudefs__WEBPACK_IMPORTED_MODULE_14__.EGE_MENU_GAME_STATE_CHANGE, _gui_menudefs__WEBPACK_IMPORTED_MODULE_14__.ETC_BEGIN, this.executionAction );

            else if( this.actionType === _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECAT_ACTION_EVENT )
                _managers_eventmanager__WEBPACK_IMPORTED_MODULE_10__.eventManager.dispatchEvent( _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECAT_ACTION_EVENT, this.executionAction, this );

            else if( this.actionType === _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECAT_SCRIPT_EXECUTE )
                this.scriptComponent.prepare( this.executionAction, this );

            // Prepare script function associated with handling this game event
            this.prepareControlScript( _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_EXECUTE );
        }
    }

    // 
    //  DESC: Handle OnSetActiveControl message
    //
    onSetActiveControl( event )
    {
        // Set the last active control to be active again
        if( (event.arg[0] === _gui_menudefs__WEBPACK_IMPORTED_MODULE_14__.EAC_LAST_ACTIVE_CONTROL) &&
            (this.lastState > _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_INACTIVE))
        {
            this.lastState = this.state = _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_ACTIVE;

            // Don't animate the control if the mouse was used
            if( !_managers_actionmanager__WEBPACK_IMPORTED_MODULE_11__.actionManager.wasLastDeviceMouse() )
            {
                this.resetSpriteScript();
                this.setDisplayState();
            }
        }
    }

    // 
    //  DESC: Handle OnReactivate message
    //
    onReactivate( /*event*/ )
    {
        // Set the last active control to be active again
        if( this.state > _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_INACTIVE )
        {
            this.lastState = this.state = _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_ACTIVE;

            // Don't animate the control if the mouse was used
            if( !_managers_actionmanager__WEBPACK_IMPORTED_MODULE_11__.actionManager.wasLastDeviceMouse() ||
                this.isPointInControl( _managers_eventmanager__WEBPACK_IMPORTED_MODULE_10__.eventManager.mouseAbsolutePos.x, _managers_eventmanager__WEBPACK_IMPORTED_MODULE_10__.eventManager.mouseAbsolutePos.y ) )
            {
                this.resetSpriteScript();
                this.setDisplayState();
            }
        }
    }

    // 
    //  DESC: Handle the mouse move
    //
    onMouseMove( event )
    {
        let result = false;

        if( !this.isDisabled() && this.isPointInControl( event.gameAdjustedMouseX, event.gameAdjustedMouseY ) )
        {
            result = true;

            // Only send the message if it's not already active
            if( !this.isActive() )
            {
                _managers_eventmanager__WEBPACK_IMPORTED_MODULE_10__.eventManager.dispatchEvent(
                    _gui_menudefs__WEBPACK_IMPORTED_MODULE_14__.EGE_MENU_CONTROL_STATE_CHANGE,
                    _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_ACTIVE,
                    this );
            }
        }

        return result;
    }

    // 
    //  DESC: Change the control state
    //
    changeState( state )
    {
        if( this.state !== state )
        {
            this.state = state;

            // Prepare any script functions associated with the state change
            this.prepareControlScript( this.state );

            this.resetSpriteScript();
            this.setDisplayState();

            this.lastState = this.state;
        }
    }

    // 
    //  DESC: Activate the control
    //
    activateControl()
    {
        // The focus has switched to this control
        if( !this.isDisabled() )
        {
            this.lastState = this.state = _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_ACTIVE;

            this.resetSpriteScript();
            this.setDisplayState();

            return true;
        }

        return false;
    }

    // 
    //  DESC: Deactivate the control
    //
    deactivateControl()
    {
        // The focus has switched away from this control
        if( (this.lastState === _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_NULL) ||
            (this.lastState > _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_INACTIVE) )
        {
            // Reset the control
            this.reset();

            this.resetSpriteScript();
            this.setDisplayState();

            this.lastState = this.state;
        }
    }

    // 
    //  DESC: Disable the control
    //
    disableControl()
    {
        if( (this.lastState === _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_NULL) ||
            (this.lastState > _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_DISABLE) )
        {
            this.lastState = this.state = _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_DISABLE;

            this.resetSpriteScript();
            this.setDisplayState();
        }
    }

    // 
    //  DESC: Enable the control to the inactive state
    //
    enableControl()
    {
        if( this.lastState <= _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_DISABLE )
        {
            this.lastState = this.state = _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_INACTIVE;

            this.resetSpriteScript();
            this.setDisplayState();
        }
    }

    // 
    //  DESC: Set the sprite's display based on it's current state
    //
    setDisplayState()
    {
        // Set the script function
        this.prepareSpriteScriptFactoryFunction( this.state );
    }

    // 
    //  DESC: Set the sprite's display based on it's current state
    //
    init()
    {
        // Create any font strings
        // This allows for delayed VBO create so that the fonts can be allocated during a load screen
        for( let i = 0; i < this.spriteAry.length; ++i )
            this.spriteAry[i].init();

        // Prepare any script functions that are flagged to prepareOnInit
        this.scriptComponent.prepareOnInit( this );
    }

    // 
    //  DESC: Do some cleanup
    //
    cleanUp()
    {
        // Free the font VBO
        // This allows for early VBO delete so that the menu manager can be freed from a thread
        for( let i = 0; i < this.spriteAry.length; ++i )
            this.spriteAry[i].cleanUp();
    }

    // 
    //  DESC: Prepare the sprite script factory function
    //
    prepareSpriteScriptFactoryFunction( controlState )
    {
        let scriptId = "null";

        switch( controlState )
        {
            case _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_DISABLE:
                scriptId = "disable";
            break;

            case _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_INACTIVE:
                scriptId = "inactive";
            break;

            case _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_ACTIVE:
                scriptId = "active";
            break;

            case _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_SELECT:
                scriptId = "select";
            break;
        }

        this.prepareSpriteScript( scriptId );
    }

    // 
    //  DESC: Call a script function map key for sprite
    //
    prepareSpriteScript( scriptId )
    {    
        for( let i = 0; i < this.spriteAry.length; ++i )
            this.spriteAry[i].scriptComponent.prepare( scriptId, this.spriteAry[i] );
    }

    // 
    //  DESC: Prepare the script function to run
    //
    prepareControlScript( controlState, event )
    {
        let scriptId = "null";

        switch( controlState )
        {
            case _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_TRANS_IN:
                scriptId = "transIn";
            break;

            case _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_TRANS_OUT:
                scriptId = "transOut";
            break;

            case _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_DISABLE:
                scriptId = "disable";
            break;

            case _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_INACTIVE:
                scriptId = "inactive";
            break;

            case _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_ACTIVE:
                scriptId = "active";
            break;

            case _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_SELECT:
                scriptId = "select";
            break;

            case _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_CHANGE:
                scriptId = "change";
            break;

            case _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_EXECUTE:
                scriptId = "execute";
            break;

            case _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_EVENT:
                scriptId = "event";
            break;
        }

        if( controlState == _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_EVENT )
            this.scriptComponent.prepare( scriptId, this, event );
        else
            this.scriptComponent.prepare( scriptId, this );
    }

    // 
    //  DESC: Reset and recycle the contexts
    //
    reset( complete = false )
    {
        if( this.state > _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_INACTIVE )
            this.state = _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_INACTIVE;

        if( complete )
            this.lastState = this.state;
    }

    // 
    //  DESC: Reset the sprite script
    //
    resetSpriteScript()
    {
        for( let i = 0; i < this.spriteAry.length; ++i )
            this.spriteAry[i].scriptComponent.reset();
    }

    // 
    //  DESC: Set the default state of this control
    //
    setDefaultState( value )
    {
        if( value === 'inactive' )
            this.defaultState = _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_INACTIVE;

        else if( value === 'active' )
            this.defaultState = _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_ACTIVE;

        else if( value === 'disabled' )
            this.defaultState = _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_DISABLE;

        else if( value === 'selected' )
            this.defaultState = _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_SELECT;
    }

    // 
    //  DESC: Set the control to their default behavior
    //
    revertToDefaultState()
    {
        this.state = this.defaultState;
    }

    // 
    //  DESC: Set the state of this control
    //
    setState( state, setLastState )
    {
        this.state = state;

        if( setLastState )
            this.lastState = state;
    }

    // 
    //  DESC: Set the control's action type
    //
    setActionType( value )
    {
        if( value === 'to_idle' )
            this.actionType = _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECAT_IDLE;

        else if( value === 'to_tree' )
            this.actionType = _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECAT_TO_TREE;

        else if( value === 'to_menu' )
            this.actionType = _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECAT_TO_MENU;

        else if( value === 'back' )
            this.actionType = _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECAT_BACK;

        else if( value === 'close' )
            this.actionType = _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECAT_CLOSE;

        else if( value === 'change_focus' )
            this.actionType = _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECAT_CHANGE_FOCUS;

        else if( value === 'game_state_change' )
            this.actionType = _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECAT_GAME_STATE_CHANGE;

        else if( value === 'quit_game' )
            this.actionType = _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECAT_QUIT_GAME;
        
        else if( value === 'action_event' )
            this.actionType = _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECAT_ACTION_EVENT;
    }

    // 
    //  DESC: Create the font string
    //
    createFontString( fontStringOrIndex, spriteIndex = 0 )
    {
        let fontString = fontStringOrIndex;
        if( typeof fontStringOrIndex !== 'string' )
            fontString = this.stringAry[fontStringOrIndex]

        let fontSpriteCounter = 0;

        for( let i = 0; i < this.spriteAry.length; ++i )
        {
            if( this.spriteAry[i].visualComponent.isFontSprite() )
            {
                if( fontSpriteCounter === spriteIndex )
                {
                    this.spriteAry[i].visualComponent.createFontString( fontString );
                    break;
                }

                ++fontSpriteCounter;
            }
        }
    }

    // 
    //  DESC: Set the font string
    //
    setFontString( fontString, spriteIndex = 0 )
    {
        let fontSpriteCounter = 0;

        for( let i = 0; i < this.spriteAry.length; ++i )
        {
            if( this.spriteAry[i].visualComponent.isFontSprite() )
            {
                if( fontSpriteCounter === spriteIndex )
                {
                    this.spriteAry[i].visualComponent.setFontString( fontString );
                    break;
                }

                ++fontSpriteCounter;
            }
        }
    }

    // 
    //  DESC: Handle the select action
    //  NOTE: Only process this message if it's keyboard/gamepad down or mouse up
    //
    handleSelectAction( event )
    {
        if( (this.isSelectable() &&
            (event.arg[_common_defs__WEBPACK_IMPORTED_MODULE_15__.ESMA_DEVICE_TYPE] === _common_defs__WEBPACK_IMPORTED_MODULE_15__.MOUSE) &&
            (event.arg[_common_defs__WEBPACK_IMPORTED_MODULE_15__.ESMA_PRESS_TYPE] === this.mouseSelectType) &&
            this.isPointInControl( event.arg[_common_defs__WEBPACK_IMPORTED_MODULE_15__.ESMA_MOUSE_X], event.arg[_common_defs__WEBPACK_IMPORTED_MODULE_15__.ESMA_MOUSE_Y] ) ) ||

            (this.isActive() && (event.arg[_common_defs__WEBPACK_IMPORTED_MODULE_15__.ESMA_DEVICE_TYPE] !== _common_defs__WEBPACK_IMPORTED_MODULE_15__.MOUSE) && (event.arg[_common_defs__WEBPACK_IMPORTED_MODULE_15__.ESMA_PRESS_TYPE] === _common_defs__WEBPACK_IMPORTED_MODULE_15__.EAP_DOWN)) )
        {
            _managers_eventmanager__WEBPACK_IMPORTED_MODULE_10__.eventManager.dispatchEvent(
                _gui_menudefs__WEBPACK_IMPORTED_MODULE_14__.EGE_MENU_CONTROL_STATE_CHANGE,
                _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_SELECT,
                this );

            return true;
        }

        return false;
    }

    // 
    //  DESC: Set the first inactive control to be active
    //  NOTE: This is mainly here to be virtual for sub controls
    //
    activateFirstInactiveControl()
    {
        // If a mouse was used, set the control as active but don't animate it.
        // This allows us to use the keys to scroll when pressed
        if( _managers_actionmanager__WEBPACK_IMPORTED_MODULE_11__.actionManager.wasLastDeviceMouse() )
        {
            if( !this.isDisabled() )
            {
                this.lastState = this.state = _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_ACTIVE;

                return true;
            }

            return false;
        }

        return this.activateControl();
    }

    // 
    //  DESC: Is the point in the control
    //
    isPointInControl( x, y )
    {
        return this.collisionQuad.isPointInQuad( x, y );
    }

    // 
    //  DESC: Get the pointer to the control if found
    //  NOTE: These function is mainly for sub controls
    //
    findControlByName( name )
    {
        if( this.name === name )
            return this;

        return null;
    }

    findControlByRef( ctrl )
    {
        if( ctrl === this )
            return this;

        return null;
    }

    // 
    //  DESC: Set the string to vector
    //
    setStringToList( str )
    {
        this.stringAry.push( str );
    }

    // 
    //  DESC: Is this control disabled/active/selected
    //
    isDisabled()
    {
        return this.state === _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_DISABLE;
    }

    isInactive()
    {
        return this.state === _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_INACTIVE;
    }

    isActive()
    {
        return (this.state === _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_ACTIVE);
    }

    isSelected()
    {
        return (this.state === _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_SELECT);
    }

    isSelectable()
    {
        return ((this.state === _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_INACTIVE) || (this.state === _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_13__.ECS_ACTIVE));
    }

    // 
    //  DESC: Check if control is a sub control
    //
    isSubControl()
    {
        return false;
    }
    
    // 
    //  DESC: Get the pointer to the active control
    //  NOTE: This is mostly needed for sub controls
    //
    getActiveControl()
    {
        return this;
    }

    // 
    //  DESC: Set the alpha value of this control
    //
    setAlpha( alpha )
    {
        for( let i = 0; i < this.spriteAry.length; ++i )
            this.spriteAry[i].setAlpha( alpha );
    }
    
    // 
    //  DESC: Check if this control can scroll
    //
    canScroll( msg )
    {
        if( this.isActive() && this.scrollParam && this.scrollParam.canScroll(msg) )
            return true;
        
        return false;
    }

    // 
    //  DESC: Get the number of controls in this subcontrol
    //
    get length()
    {
        return 1;
    }
}


/***/ }),
/* 130 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ControlBase": () => (/* binding */ ControlBase)
/* harmony export */ });
/* harmony import */ var _common_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);
/* harmony import */ var _utilities_settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _utilities_assetholder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(33);
/* harmony import */ var _utilities_xmlparsehelper__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(19);

// 
//  FILE NAME: controlbase.js
//  DESC:      Control base class
//








class ControlBase extends _common_object__WEBPACK_IMPORTED_MODULE_0__.Object
{
    constructor( group )
    {
        super();
        
        // Object data group name
        this.group = group;

        // Unique string id
        this.name = null;

        // The type of control
        this.type = null;

        // Control string list
        this.stringAry = [];

        // A name that is applied to similar controls.
        // Provides a way to check for many controls without having to use unique names
        this.faction = null;

        // Dynamic offset
        this.dynamicOffset = null;
    }
    
    // 
    //  DESC: Load the control info from XML node
    //
    loadFromNode( xmlNode )
    {
        // Set the controls name
        let attr = xmlNode.getAttribute( 'name' );
        if( attr )
            this.name = attr;

        // Set the faction name
        attr = xmlNode.getAttribute( 'faction' );
        if( attr )
            this.faction = attr;

        // Load the transform data
        this.loadTransFromNode( xmlNode );

        // Load the dynamic offset from node
        this.loadDynamicOffsetFromNode( xmlNode );

        // See if we have a list of strings
        let stringLstNode = xmlNode.getElementsByTagName( 'fontStringList' );
        if( stringLstNode.length )
        {
            let stringNode = stringLstNode[0].getElementsByTagName( 'string' );
            
            for( let i = 0; i < stringNode.length; ++i )
                this.stringAry.push( stringNode[i].getAttribute( 'text' ) );
        }

        // Load the control specific xml file
        // Get the file path node to the control specific xml code
        let filePathNode = xmlNode.getElementsByTagName( 'filePath' );
        if( filePathNode.length )
        {
            // Get the control's file path
            let controlFilePath = filePathNode[0].getAttribute( 'file' );

            // Load xml specific control code
            // Use the preloaded since many controls reuse xml files
            this.loadControlFromNode( _utilities_assetholder__WEBPACK_IMPORTED_MODULE_2__.assetHolder.get( this.group, controlFilePath ) );
        }
        // Load from the node if we have a sprite list
        else if( xmlNode.getElementsByTagName( 'spriteLst' ).length )
        {
            this.loadControlFromNode( xmlNode );
        }
    }
    
    // 
    //  DESC: Load the control specific info from XML node
    //
    loadControlFromNode( /*xmlNode*/ )
    {
        // Empty function to be overwritten
    }

    // 
    //  DESC: Load the dynamic offset data from node
    //
    loadDynamicOffsetFromNode( xmlNode )
    {
        // Load the dynamic offset
        this.dynamicOffset = _utilities_xmlparsehelper__WEBPACK_IMPORTED_MODULE_3__.loadDynamicOffset( xmlNode );

        // Set the dynamic position
        this.setDynamicPos();
    }

    // 
    //  DESC: Set the dynamic position
    //
    setDynamicPos()
    {
        // Position the menu based on the dynamic offset
        // Don't have it exceed the boundries of the art
        if( this.dynamicOffset )
        {
            let size = _utilities_settings__WEBPACK_IMPORTED_MODULE_1__.settings.defaultSize_half;
            if( _utilities_settings__WEBPACK_IMPORTED_MODULE_1__.settings.defaultSize_half > _utilities_settings__WEBPACK_IMPORTED_MODULE_1__.settings.nativeSize_half )
                size = _utilities_settings__WEBPACK_IMPORTED_MODULE_1__.settings.nativeSize_half;

            this.setPos( this.dynamicOffset.getPos( size ) );
        }
    }

    // 
    //  DESC: Handle the wheel events. Most controls don't deal with wheen events so it's a catchall here
    //
    onWheel( /*event*/ )
    {
    }
}

/***/ }),
/* 131 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Quad": () => (/* binding */ Quad)
/* harmony export */ });
/* harmony import */ var _common_point__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14);

// 
//  FILE NAME:  quad.js
//  DESC:       quad class
//




class Quad
{
    constructor()
    {
        this.point = [new _common_point__WEBPACK_IMPORTED_MODULE_0__.Point, new _common_point__WEBPACK_IMPORTED_MODULE_0__.Point, new _common_point__WEBPACK_IMPORTED_MODULE_0__.Point, new _common_point__WEBPACK_IMPORTED_MODULE_0__.Point];
    }
    
    // 
    //  DESC: Is the point in the Quad
    //  Note: Fast but does not work when quad is rotated
    //
    isPointInQuad( x, y )
    {
        let result = false;
        
        //console.log( `isPointInQuad - X: ${x}, Y: ${y}` );
        
        for( let i = 0, j = 3; i < 4; j = i++ )
        {
            if( ((this.point[i].y > y) != (this.point[j].y > y)) && 
                (x < (this.point[j].x - this.point[i].x) * (y - this.point[i].y) / (this.point[j].y - this.point[i].y) + this.point[i].x) )
            {
                result = !result;
            }
        }

        return result;
    }
}


/***/ }),
/* 132 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BTN_DEC": () => (/* binding */ BTN_DEC),
/* harmony export */   "BTN_INC": () => (/* binding */ BTN_INC),
/* harmony export */   "ECT_NULL": () => (/* binding */ ECT_NULL),
/* harmony export */   "ECT_LABEL": () => (/* binding */ ECT_LABEL),
/* harmony export */   "ECT_BUTTON": () => (/* binding */ ECT_BUTTON),
/* harmony export */   "ECT_BUTTON_LIST": () => (/* binding */ ECT_BUTTON_LIST),
/* harmony export */   "ECT_CHECK_BOX": () => (/* binding */ ECT_CHECK_BOX),
/* harmony export */   "ECT_SLIDER": () => (/* binding */ ECT_SLIDER),
/* harmony export */   "ECT_SCROLL_BOX": () => (/* binding */ ECT_SCROLL_BOX),
/* harmony export */   "ECT_SUB_CONTROL": () => (/* binding */ ECT_SUB_CONTROL),
/* harmony export */   "ECT_METER": () => (/* binding */ ECT_METER),
/* harmony export */   "ECT_TAB_CONTROL": () => (/* binding */ ECT_TAB_CONTROL),
/* harmony export */   "ECT_PROGRESS_BAR": () => (/* binding */ ECT_PROGRESS_BAR),
/* harmony export */   "ECT_AMOUNT_BUTTON": () => (/* binding */ ECT_AMOUNT_BUTTON),
/* harmony export */   "ECS_NULL": () => (/* binding */ ECS_NULL),
/* harmony export */   "ECS_TRANS_IN": () => (/* binding */ ECS_TRANS_IN),
/* harmony export */   "ECS_TRANS_OUT": () => (/* binding */ ECS_TRANS_OUT),
/* harmony export */   "ECS_DISABLE": () => (/* binding */ ECS_DISABLE),
/* harmony export */   "ECS_INACTIVE": () => (/* binding */ ECS_INACTIVE),
/* harmony export */   "ECS_ACTIVE": () => (/* binding */ ECS_ACTIVE),
/* harmony export */   "ECS_SELECT": () => (/* binding */ ECS_SELECT),
/* harmony export */   "ECS_CHANGE": () => (/* binding */ ECS_CHANGE),
/* harmony export */   "ECS_EXECUTE": () => (/* binding */ ECS_EXECUTE),
/* harmony export */   "ECS_EVENT": () => (/* binding */ ECS_EVENT),
/* harmony export */   "ECAT_IDLE": () => (/* binding */ ECAT_IDLE),
/* harmony export */   "ECAT_NULL": () => (/* binding */ ECAT_NULL),
/* harmony export */   "ECAT_ACTION": () => (/* binding */ ECAT_ACTION),
/* harmony export */   "ECAT_TO_TREE": () => (/* binding */ ECAT_TO_TREE),
/* harmony export */   "ECAT_TO_MENU": () => (/* binding */ ECAT_TO_MENU),
/* harmony export */   "ECAT_BACK": () => (/* binding */ ECAT_BACK),
/* harmony export */   "ECAT_CLOSE": () => (/* binding */ ECAT_CLOSE),
/* harmony export */   "ECAT_CHANGE_FOCUS": () => (/* binding */ ECAT_CHANGE_FOCUS),
/* harmony export */   "ECAT_GAME_STATE_CHANGE": () => (/* binding */ ECAT_GAME_STATE_CHANGE),
/* harmony export */   "ECAT_QUIT_GAME": () => (/* binding */ ECAT_QUIT_GAME),
/* harmony export */   "ECAT_ACTION_EVENT": () => (/* binding */ ECAT_ACTION_EVENT),
/* harmony export */   "ECAT_SCRIPT_EXECUTE": () => (/* binding */ ECAT_SCRIPT_EXECUTE),
/* harmony export */   "EAR_UP": () => (/* binding */ EAR_UP),
/* harmony export */   "EAR_DOWN": () => (/* binding */ EAR_DOWN),
/* harmony export */   "EAR_LEFT": () => (/* binding */ EAR_LEFT),
/* harmony export */   "EAR_RIGHT": () => (/* binding */ EAR_RIGHT)
/* harmony export */ });
// 
//  FILE NAME: uicontroldefs.js
//  DESC:      misc defines
//



// Increment/Decement constants
const BTN_DEC = 0,
             BTN_INC = 1;

// EControlType
const ECT_NULL          = 0,
             ECT_LABEL         = 1,
             ECT_BUTTON        = 2,
             ECT_BUTTON_LIST   = 3,
             ECT_CHECK_BOX     = 4,
             ECT_SLIDER        = 5,
             ECT_SCROLL_BOX    = 6,
             ECT_SUB_CONTROL   = 7,
             ECT_METER         = 8,
             ECT_TAB_CONTROL   = 9,
             ECT_PROGRESS_BAR  = 10,
             ECT_AMOUNT_BUTTON = 11;

// EControlState
const ECS_NULL      = 0,
             ECS_TRANS_IN  = 1,
             ECS_TRANS_OUT = 2,
             ECS_DISABLE   = 3,
             ECS_INACTIVE  = 4,
             ECS_ACTIVE    = 5,
             ECS_SELECT    = 6,
             ECS_CHANGE    = 7,
             ECS_EXECUTE   = 8,
             ECS_EVENT     = 9;

// EControlActionType
const ECAT_IDLE              = -1,
             ECAT_NULL              = 0,
             ECAT_ACTION            = 1,
             ECAT_TO_TREE           = 2,
             ECAT_TO_MENU           = 3,
             ECAT_BACK              = 4,
             ECAT_CLOSE             = 5,
             ECAT_CHANGE_FOCUS      = 6,
             ECAT_GAME_STATE_CHANGE = 7,
             ECAT_QUIT_GAME         = 8,
             ECAT_ACTION_EVENT      = 9,
             ECAT_SCRIPT_EXECUTE    = 10;

// EActionResponse
const EAR_UP    = 1,
             EAR_DOWN  = 2,
             EAR_LEFT  = 4,
             EAR_RIGHT = 8;


/***/ }),
/* 133 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UIButton": () => (/* binding */ UIButton)
/* harmony export */ });
/* harmony import */ var _uicontrol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(129);
/* harmony import */ var _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(132);

// 
//  FILE NAME: uibutton.js
//  DESC:      Class for user interface buttons
//





class UIButton extends _uicontrol__WEBPACK_IMPORTED_MODULE_0__.UIControl
{
    constructor( group )
    {
        super( group );
        
        this.type = _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_1__.ECT_BUTTON;
    }
}


/***/ }),
/* 134 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UISubControl": () => (/* binding */ UISubControl)
/* harmony export */ });
/* harmony import */ var _uicontrol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(129);
/* harmony import */ var _gui_uicontrolnavnode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(111);
/* harmony import */ var _managers_eventmanager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30);
/* harmony import */ var _common_genericevent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(31);
/* harmony import */ var _uicontrolfactory__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(127);
/* harmony import */ var _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(132);
/* harmony import */ var _gui_menudefs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(36);
/* harmony import */ var _common_defs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(6);

// 
//  FILE NAME: uisubcontrol.js
//  DESC:      Class for user interface controls with sub-controls
//











class UISubControl extends _uicontrol__WEBPACK_IMPORTED_MODULE_0__.UIControl
{
    constructor( group )
    {
        super( group );
        
        this.type = _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_5__.ECT_SUB_CONTROL;
        
        // Arry of sub-controls
        this.subControlAry = [];

        // Array list of navigation nodes
        this.controlNodeAry = [];

        // Current active node
        // NOTE: This variable does not own it's pointers.
        this.activeNode = null;

        // A sub control is a container for other controls so normally
        // it doesn't respont to select messages. There can be a case
        // where this control needs to respond.
        this.respondsToSelectMsg = false;
    }
    
    // 
    //  DESC: Load the control specific info from XML node
    //
    loadControlFromNode( node )
    {
        // Have the parent load it's stuff
        super.loadControlFromNode( node );

        // Get the sub-control settings
        let subControlSettingsNode = node.getElementsByTagName( 'subControlSettings' );
        if( subControlSettingsNode.length )
        {
            // Does this sub control respond to select? The default is false.
            let attr = subControlSettingsNode[0].getAttribute( 'respondsToSelectMsg' );
            if( attr === 'true' )
                this.respondsToSelectMsg = true;
        }

        // Get the menu controls node
        let controlListNode = node.getElementsByTagName( 'subControlList' );
        if( controlListNode.length )
        {
            // map to help setup the node pointers
            let navNodeMap = new Map;
            
            let controlNode = controlListNode[0].getElementsByTagName( 'control' );

            for( let i = 0; i < controlNode.length; ++i )
            {
                // The reference is placed within an array for all controls
                let control = _uicontrolfactory__WEBPACK_IMPORTED_MODULE_4__.create( controlNode[i], this.group );
                
                this.subControlAry.push( control );

                // Does this control have a name then create a node and add it to the map
                if( control.name )
                {
                    // Add a node to the vector with it's control
                    let navNode = new _gui_uicontrolnavnode__WEBPACK_IMPORTED_MODULE_1__.UIControlNavNode( control );
                    this.controlNodeAry.push( navNode );

                    // Map of menu control nodes
                    navNodeMap.set( control.name, navNode );
                }
            }

            // Find the reference nodes
            if( navNodeMap.size > 0 )
            {
                for( let i = 0; i < controlNode.length; ++i )
                    this.findNodes( controlNode[i], i, navNodeMap );
            }
        }
    }

    // 
    //  DESC: Init the control
    //
    init()
    {
        super.init();

        // Init all controls
        for( let i = 0; i < this.subControlAry.length; ++i )
            this.subControlAry[i].init();
    }

    // 
    //  DESC: Do some cleanup
    //
    cleanUp()
    {
        super.cleanUp();

        // Init all controls
        for( let i = 0; i < this.subControlAry.length; ++i )
            this.subControlAry[i].cleanUp();
    }

    // 
    //  DESC: Find the reference nodes
    //
    findNodes( node, nodeIndex, navNodeMap )
    {
        let navNode = node.getElementsByTagName( 'navigate' );
        if( navNode.length )
        {
            this.setNodes( navNode, nodeIndex, 'up',    _common_defs__WEBPACK_IMPORTED_MODULE_7__.ENAV_NODE_UP,    navNodeMap );
            this.setNodes( navNode, nodeIndex, 'down',  _common_defs__WEBPACK_IMPORTED_MODULE_7__.ENAV_NODE_DOWN,  navNodeMap );
            this.setNodes( navNode, nodeIndex, 'left',  _common_defs__WEBPACK_IMPORTED_MODULE_7__.ENAV_NODE_LEFT,  navNodeMap );
            this.setNodes( navNode, nodeIndex, 'right', _common_defs__WEBPACK_IMPORTED_MODULE_7__.ENAV_NODE_RIGHT, navNodeMap );
        }
    }

    // 
    //  DESC: Find the reference nodes
    //
    setNodes( node, nodeIndex, attrStr, navId, navNodeMap )
    {
        let attr = node[0].getAttribute( attrStr );
        if( attr )
        {
            let ctrlNode = navNodeMap.get( attr );
            if( ctrlNode !== undefined )
                this.controlNodeAry[nodeIndex].setNode( navId, ctrlNode );
            else
                throw new Error( `Control node doesn't exist! (${name})` );
        }
    }

    // 
    //  DESC: Update the control
    //
    update()
    {
        // Call the parent
        super.update();

        // Update all controls
        for( let i = 0; i < this.subControlAry.length; ++i )
            this.subControlAry[i].update();
    }

    // 
    //  DESC: Transform the control
    //
    transform( object )
    {
        // Call the parent
        super.transform( object );

        // Update all controls
        for( let i = 0; i < this.subControlAry.length; ++i )
            this.subControlAry[i].transform( this );
    }

    // 
    //  DESC: Render the sub control
    //
    render( camera )
    {
        // Call the parent
        super.render( camera );

        for( let i = 0; i < this.subControlAry.length; ++i )
            this.subControlAry[i].render( camera );
    }

    // 
    //  DESC: Handle events
    //
    handleEvent( event )
    {
        // Call the parent
        super.handleEvent( event );

        for( let i = 0; i < this.subControlAry.length; ++i )
            this.subControlAry[i].handleEvent( event );

        if( this.isActive() && (event instanceof _common_genericevent__WEBPACK_IMPORTED_MODULE_3__.GenericEvent) )
        {
            if( (event.type >= _gui_menudefs__WEBPACK_IMPORTED_MODULE_6__.EGE_MENU_UP_ACTION) &&
                (event.type <= _gui_menudefs__WEBPACK_IMPORTED_MODULE_6__.EGE_MENU_RIGHT_ACTION) )
            {
                if( event.type === _gui_menudefs__WEBPACK_IMPORTED_MODULE_6__.EGE_MENU_UP_ACTION )
                {
                    this.onUpAction( event );
                }
                else if( event.type === _gui_menudefs__WEBPACK_IMPORTED_MODULE_6__.EGE_MENU_DOWN_ACTION )
                {
                    this.onDownAction( event );
                }
                if( event.type === _gui_menudefs__WEBPACK_IMPORTED_MODULE_6__.EGE_MENU_LEFT_ACTION )
                {
                    this.onLeftAction( event );
                }
                else if( event.type === _gui_menudefs__WEBPACK_IMPORTED_MODULE_6__.EGE_MENU_RIGHT_ACTION )
                {
                    this.onRightAction( event );
                }
            }
            else if( (event.type >= _gui_menudefs__WEBPACK_IMPORTED_MODULE_6__.EGE_MENU_SCROLL_UP) &&
                     (event.type <= _gui_menudefs__WEBPACK_IMPORTED_MODULE_6__.EGE_MENU_SCROLL_RIGHT) )
            {
                if( event.type === _gui_menudefs__WEBPACK_IMPORTED_MODULE_6__.EGE_MENU_SCROLL_UP )
                {
                    this.onUpScroll( event );
                }
                else if( event.type === _gui_menudefs__WEBPACK_IMPORTED_MODULE_6__.EGE_MENU_SCROLL_DOWN )
                {
                    this.onDownScroll( event );
                }
                else if( event.type === _gui_menudefs__WEBPACK_IMPORTED_MODULE_6__.EGE_MENU_SCROLL_LEFT )
                {
                    this.onLeftScroll( event );
                }
                else if( event.type === _gui_menudefs__WEBPACK_IMPORTED_MODULE_6__.EGE_MENU_SCROLL_RIGHT )
                {
                    this.onRightScroll( event );
                }
            }
            else if( event.type === _gui_menudefs__WEBPACK_IMPORTED_MODULE_6__.EGE_MENU_TAB_LEFT )
            {
                this.onTabLeft( event );
            }
            else if( event.type === _gui_menudefs__WEBPACK_IMPORTED_MODULE_6__.EGE_MENU_TAB_RIGHT )
            {
                this.onTabRight( event );
            }
        }
    }

    // 
    //  DESC: Handle OnUpAction message
    //
    onUpAction( /*event*/ )
    {
        this.navigateMenu( _common_defs__WEBPACK_IMPORTED_MODULE_7__.ENAV_NODE_UP );
    }

    // 
    //  DESC: Handle OnMenuDown message
    //
    onDownAction( /*event*/ )
    {
        this.navigateMenu( _common_defs__WEBPACK_IMPORTED_MODULE_7__.ENAV_NODE_DOWN );
    }

    // 
    //  DESC: Handle OnMenuLeft message
    //
    onLeftAction( /*event*/ )
    {
        this.navigateMenu( _common_defs__WEBPACK_IMPORTED_MODULE_7__.ENAV_NODE_LEFT );
    }

    // 
    //  DESC: Handle OnRightAction message
    //
    onRightAction( /*event*/ )
    {
        this.navigateMenu( _common_defs__WEBPACK_IMPORTED_MODULE_7__.ENAV_NODE_RIGHT );
    }

    // 
    //  DESC: Handle OnUpScroll message
    //
    onUpScroll( /*event*/ )
    {
        this.navigateMenu( _common_defs__WEBPACK_IMPORTED_MODULE_7__.ENAV_NODE_UP );
    }

    // 
    //  DESC: Handle OnUpScroll message
    //
    onDownScroll( /*event*/ )
    {
        this.navigateMenu( _common_defs__WEBPACK_IMPORTED_MODULE_7__.ENAV_NODE_DOWN );
    }

    // 
    //  DESC: Handle OnRightScroll message
    //
    onLeftScroll( /*event*/ )
    {
        this.navigateMenu( _common_defs__WEBPACK_IMPORTED_MODULE_7__.ENAV_NODE_LEFT );
    }

    // 
    //  DESC: Handle OnRightScroll message
    //
    onRightScroll( /*event*/ )
    {
        this.navigateMenu( _common_defs__WEBPACK_IMPORTED_MODULE_7__.ENAV_NODE_RIGHT );
    }

    // 
    //  DESC: Handle OnTabLeft message
    //
    onTabLeft( /*event*/ )
    {
        // Do nothing
    }

    // 
    //  DESC: Handle OnTabRight message
    //
    onTabRight( /*event*/ )
    {
        // Do nothing
    }

    // 
    //  DESC: Navigate the menu. Find the next control node that isn't
    //        disabled and make it the active control node
    //
    navigateMenu( /*navNode*/ )
    {
        if( this.activeNode !== null )
        {
            let navNode = this.activeNode;

            do
            {
                navNode = navNode.getNode( navNode );
                
                if( navNode === null )
                {
                    break;
                }
                else if( !navNode.uiControl.isDisabled() )
                {
                    this.activeNode = navNode;

                    _managers_eventmanager__WEBPACK_IMPORTED_MODULE_2__.eventManager.dispatchEvent(
                        _gui_menudefs__WEBPACK_IMPORTED_MODULE_6__.EGE_MENU_CONTROL_STATE_CHANGE,
                        _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_5__.ECS_ACTIVE,
                        navNode.uiControl );

                    break;
                }
            }
            while( navNode );
        }
    }

    // 
    //  DESC: Handle OnStateChange message
    //
    onStateChange( event )
    {
        if( this.respondsToSelectMsg )
        {
            super.onStateChange( event );
        }
        else
        {
            let state = event.arg[_common_defs__WEBPACK_IMPORTED_MODULE_7__.EMSC_STATE];

            let ctrl = this.findSubControlByRef( event.arg[_common_defs__WEBPACK_IMPORTED_MODULE_7__.EMSC_CONTROL] );

            // Restart the active state of the sub control if something
            // changed in the child controls or their children controls
            if( (state === _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_5__.ECS_ACTIVE) && (ctrl !== null) )
            {
                if( ctrl.state != state )
                {
                    this.setState(state, true);

                    this.resetSpriteScript();

                    this.setDisplayState();
                }
            }
            // The sub control doesn't respond to selected message
            else if( state < _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_5__.ECS_SELECT )
                super.onStateChange( event );
        }
    }

    // 
    //  DESC: Reset and recycle the contexts
    //
    reset( complete )
    {
        super.reset( complete );
        
        for( let i = 0; i < this.subControlAry.length; ++i )
            this.subControlAry[i].reset( complete );
    }

    // 
    //  DESC: Handle the mouse move
    //
    onMouseMove( event )
    {
        let result = super.onMouseMove( event );

        let found = this.onSubControlMouseMove( event );

        // If the sub control is not found, deactivate them
        if( result && !found )
            this.deactivateSubControl();

        return result || found;
    }

    // 
    //  DESC: Handle the sub control mouse move
    //
    onSubControlMouseMove( event )
    {
        let result = false;

        for( let i = 0; i < this.subControlAry.length && !result; ++i )
            result = this.subControlAry[i].onMouseMove( event );

        return result;
    }

    // 
    //  DESC: Handle the select action
    //
    handleSelectAction( event )
    {
        if( this.respondsToSelectMsg )
        {
            return super.handleSelectAction( event );
        }
        else
        {
            for( let i = 0; i < this.subControlAry.length; ++i )
                if( this.subControlAry[i].handleSelectAction( event ) )
                    return true;
        }

        return false;
    }

    // 
    //  DESC: Get the reference to the control if found
    //
    findControlByName( name )
    {
        let ctrl = super.findControlByName( name );

        if( ctrl === null )
            ctrl = this.findSubControlByName( name );

        return ctrl;
    }

    findControlByRef( control )
    {
        let ctrl = super.findControlByRef( control );

        if( ctrl === null )
            ctrl = this.findSubControlByRef( control );

        return ctrl;
    }

    // 
    //  DESC: Get the pointer to the subcontrol if found
    //
    findSubControlByName( name )
    {
        let ctrl = null;

        for( let i = 0; i < this.subControlAry.length && !ctrl; ++i )
            ctrl = this.subControlAry[i].findControlByName( name );

        return ctrl;
    }

    findSubControlByRef( control )
    {
        let ctrl = null;

        for( let i = 0; i < this.subControlAry.length && !ctrl; ++i )
            ctrl = this.subControlAry[i].findControlByRef( control );

        return ctrl;
    }

    // 
    //  DESC: Set the first inactive control to be active
    //  NOTE: This is mainly here to be virtual for sub controls
    //
    activateFirstInactiveControl()
    {
        if( super.activateFirstInactiveControl() )
        {
            let found = false;

            for( let i = 0; i < this.controlNodeAry.length; ++i )
            {
                if( !found && this.controlNodeAry[i].uiControl.activateFirstInactiveControl() )
                {
                    this.activeNode = this.controlNodeAry[i];

                    found = true;
                }
                else
                {
                    this.controlNodeAry[i].uiControl.deactivateControl();
                }
            }

            return true;
        }

        return false;
    }
    
    baseActivateFirstInactiveControl()
    {
        return super.activateFirstInactiveControl();
    }

    // 
    //  DESC: Deactivate the control
    //
    deactivateControl()
    {
        super.deactivateControl();

        this.deactivateSubControl();
    }

    // 
    //  DESC: Deactivate the sub control
    //
    deactivateSubControl()
    {
        for( let i = 0; i < this.subControlAry.length; ++i )
            this.subControlAry[i].deactivateControl();
    }

    // 
    //  DESC: Check if control is a sub control
    //
    isSubControl()
    {
        return true;
    }

    // 
    //  DESC: Disable the control
    //
    disableControl()
    {
        super.disableControl();

        for( let i = 0; i < this.subControlAry.length; ++i )
            this.subControlAry[i].disableControl();
    }

    // 
    //  DESC: Enable the control to the inactive state
    //
    enableControl()
    {
        super.enableControl();

        for( let i = 0; i < this.subControlAry.length; ++i )
            this.subControlAry[i].enableControl();
    }

    // 
    //  DESC: Set the alpha value of this control
    //
    setAlpha( alpha )
    {
        super.setAlpha( alpha );

        for( let i = 0; i < this.subControlAry.length; ++i )
            this.subControlAry[i].setAlpha( alpha );
    }

    // 
    //  DESC: Get the pointer to the active control
    //  NOTE: This is mostly needed for sub controls
    //
    getActiveControl()
    {
        let result = null;

        if( this.respondsToSelectMsg )
            result = this;

        for( let i = 0; i < this.subControlAry.length; ++i )
        {
            if( this.subControlAry[i].state > _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_5__.ECS_INACTIVE )
            {
                result = this.subControlAry[i].getActiveControl();
                break;
            }
        }
        
        return result;
    }
}


/***/ }),
/* 135 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UIButtonList": () => (/* binding */ UIButtonList)
/* harmony export */ });
/* harmony import */ var _uisubcontrol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(134);
/* harmony import */ var _utilities_bitmask__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15);
/* harmony import */ var _managers_eventmanager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(30);
/* harmony import */ var _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(132);
/* harmony import */ var _gui_menudefs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(36);
/* harmony import */ var _common_defs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(6);

// 
//  FILE NAME: uibuttonlist.js
//  DESC:      Class for user interface buttons
//









class UIButtonList extends _uisubcontrol__WEBPACK_IMPORTED_MODULE_0__.UISubControl
{
    constructor( group )
    {
        super( group );
        
        this.type = _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_3__.ECT_BUTTON_LIST;
        
        // Active index into the list
        this.activeIndex = 0;

        // Index of the image list
        this.imageLstIndex = -1;
        
        // Last font index used for the font list
        this.lastFontSpriteIndex = 0;

        // Indicates if the control responds to up, down, left or right
        this.actionMask = new _utilities_bitmask__WEBPACK_IMPORTED_MODULE_1__.BitMask;
    }
    
    // 
    //  DESC: Load the control info from XML node
    //
    loadFromNode( node )
    {
        // Call the parent
        super.loadFromNode( node );

        // See what the control will respond to
        let actionResponseNode = node.getElementsByTagName( 'actionResponse' );
        let attr = actionResponseNode[0].getAttribute('up');
        if( attr && (attr === 'true') )
        {
            this.actionMask.add( _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_3__.EAR_UP );
        }

        attr = actionResponseNode[0].getAttribute('down');
        if( attr && (attr === 'true') )
        {
            this.actionMask.add( _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_3__.EAR_DOWN );
        }

        attr = actionResponseNode[0].getAttribute('left');
        if( attr && (attr === 'true') )
        {
            this.actionMask.add( _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_3__.EAR_LEFT );
        }

        attr = actionResponseNode[0].getAttribute('right');
        if( attr && (attr === 'true') )
        {
            this.actionMask.add( _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_3__.EAR_RIGHT );
        }
    }

    // 
    //  DESC: Load the control specific info from XML node
    //
    loadControlFromNode( node )
    {
        // Call the parent
        super.loadControlFromNode( node );

        // See if there is an image list
        for( let i = 0; i < this.spriteAry.length; ++i )
        {
            if( this.spriteAry[i].objData.visualData.getFrameCount() > 1 )
            {
                this.imageLstIndex = i;
                break;
            }
        }
        
        // Find the last font sprite in the list
        let fontSpriteCounter = 0;
        for( let i = 0; i < this.spriteAry.length; ++i )
        {
            if( this.spriteAry[i].visualComponent.isFontSprite() )
            {
                this.lastFontSpriteIndex = fontSpriteCounter;
                ++fontSpriteCounter;
            }
        }
    }

    // 
    //  DESC: Inc/Dec control
    //
    inc()
    {
        _managers_eventmanager__WEBPACK_IMPORTED_MODULE_2__.eventManager.dispatchEvent(
            _gui_menudefs__WEBPACK_IMPORTED_MODULE_4__.EGE_MENU_CONTROL_STATE_CHANGE,
            _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_3__.ECS_SELECT,
            this.subControlAry[_gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_3__.BTN_INC] );
    }

    dec()
    {
        _managers_eventmanager__WEBPACK_IMPORTED_MODULE_2__.eventManager.dispatchEvent(
            _gui_menudefs__WEBPACK_IMPORTED_MODULE_4__.EGE_MENU_CONTROL_STATE_CHANGE,
            _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_3__.ECS_SELECT,
            this.subControlAry[_gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_3__.BTN_DEC] );
    }

    // 
    //  DESC: Handle Onmessage
    //
    onDownAction( event )
    {
        if( (event.arg[0] === _common_defs__WEBPACK_IMPORTED_MODULE_5__.EAP_DOWN) && this.actionMask.isSet( _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_3__.EAR_DOWN ) )
            this.dec();
    }

    onUpAction( event )
    {
        if( (event.arg[0] === _common_defs__WEBPACK_IMPORTED_MODULE_5__.EAP_DOWN) && this.actionMask.isSet( _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_3__.EAR_UP ) )
            this.inc();
    }

    onLeftAction( event )
    {
        if( (event.arg[0] === _common_defs__WEBPACK_IMPORTED_MODULE_5__.EAP_DOWN) && this.actionMask.isSet( _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_3__.EAR_LEFT ) )
            this.dec();

    }

    onRightAction( event )
    {
        if( (event.arg[0] === _common_defs__WEBPACK_IMPORTED_MODULE_5__.EAP_DOWN) && this.actionMask.isSet( _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_3__.EAR_RIGHT ) )
            this.inc();
    }

    // 
    //  DESC: Handle OnLeftScroll message
    //
    onDownScroll( /*event*/ )
    {
        if( this.actionMask.isSet( _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_3__.EAR_DOWN ) )
            this.dec();
    }

    onUpScroll( /*event*/ )
    {
        if( this.actionMask.isSet( _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_3__.EAR_UP ) )
            this.inc();
    }

    onLeftScroll( /*event*/ )
    {
        if( this.actionMask.isSet( _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_3__.EAR_LEFT ) )
            this.dec();
    }

    onRightScroll( /*event*/ )
    {
        if( this.actionMask.isSet( _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_3__.EAR_RIGHT ) )
            this.inc();
    }

    // 
    //  DESC: Handle OnStateChange message
    //
    onStateChange( event )
    {
        super.onStateChange( event );

        let state = event.arg[0];

        if( state === _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_3__.ECS_SELECT )
        {
            if( this.subControlAry[_gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_3__.BTN_DEC] == event.arg[1] )
            {
                // Dec the list
                this.decList();

                // Update the display
                this.updateDisplay( this.activeIndex );
            }
            else if( this.subControlAry[_gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_3__.BTN_INC] == event.arg[1] )
            {
                // Inc the list
                this.incList();

                // Update the display
                this.updateDisplay( this.activeIndex );
            }
        }
    }

    // 
    //  DESC: Inc the list
    //
    incList()
    {
        if( this.stringAry.length )
            this.activeIndex = (this.activeIndex + 1) % this.stringAry.length;
    }

    decList()
    {
        if( this.stringAry.length )
        {
            if( this.activeIndex > 0 )
                this.activeIndex = (this.activeIndex - 1) % this.stringAry.length;
            else
                this.activeIndex = this.stringAry.length - 1;
        }
    }

    // 
    //  DESC: Update the display
    //
    updateDisplay( index )
    {
        this.activeIndex = index;

        this.createFontString( this.activeIndex, this.lastFontSpriteIndex );

        if( this.imageLstIndex > -1 )
            this.spriteAry[this.imageLstIndex].visualComponent.setFrame( this.activeIndex );
    }
    
    // 
    //  DESC: Get the active index
    //
    getIndex()
    {
        return this.activeIndex;
    }
}


/***/ }),
/* 136 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UICheckBox": () => (/* binding */ UICheckBox)
/* harmony export */ });
/* harmony import */ var _uicontrol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(129);
/* harmony import */ var _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(132);
/* harmony import */ var _common_defs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6);

// 
//  FILE NAME: uicheckbox.js
//  DESC:      Class for user interface check box buttons
//






class UICheckBox extends _uicontrol__WEBPACK_IMPORTED_MODULE_0__.UIControl
{
    constructor( group )
    {
        super( group );
        
        this.type = _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_1__.ECT_CHECK_BOX;
        
        // Select state
        this.toggleState = false;
    }
    
    // 
    //  DESC: Handle OnSelectExecute message
    //
    onSelectExecute( event )
    {
        if( this.state === _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_1__.ECS_SELECT )
            this.toggleState = !this.toggleState;

        super.onSelectExecute( event );
    }

    // 
    //  DESC: Render the control
    //
    render( matrix )
    {
        for( let i = 0; i < this.spriteAry.length-1; ++i )
            this.spriteAry[i].render( matrix );

        if( this.toggleState === _common_defs__WEBPACK_IMPORTED_MODULE_2__.TOGGLE_STATE_ON )
            this.spriteAry[this.spriteAry.length-1].render( matrix );
    }
}




/***/ }),
/* 137 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UISlider": () => (/* binding */ UISlider)
/* harmony export */ });
/* harmony import */ var _uisubcontrol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(134);
/* harmony import */ var _common_point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14);
/* harmony import */ var _utilities_settings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
/* harmony import */ var _managers_eventmanager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(30);
/* harmony import */ var _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(132);
/* harmony import */ var _gui_menudefs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(36);
/* harmony import */ var _common_defs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6);

// 
//  FILE NAME: uislider.js
//  DESC:      Class for user interface slider
//










class UISlider extends _uisubcontrol__WEBPACK_IMPORTED_MODULE_0__.UISubControl
{
    constructor( group )
    {
        super( group );
        
        this.type = _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_4__.ECT_SLIDER;
        
        // Slider travel distance in pixels
        this.travelDistPixels = 0;

        // Slider Orientation
        this.orientation = _common_defs__WEBPACK_IMPORTED_MODULE_6__.EO_HORIZONTAL;

        // Min value
        this.minValue = 0;

        // Max value
        this.maxValue = 0;

        // Current value
        this.curValue = 0;

        // inc value
        this.incValue = 0;

        // Flag to indicate to display the value as an int
        this.displayValueAsInt = false;

        // Amount of decimal places
        this.displayValueDecimalPlaces = 2;

        // Default position of the slider button
        this.defaultPos = new _common_point__WEBPACK_IMPORTED_MODULE_1__.Point;

        // slider button hold flag
        this.sliderBtnHold = false;

        // The current press type
        this.pressType = _common_defs__WEBPACK_IMPORTED_MODULE_6__.EAP_IDLE;
    }
    
    // 
    //  DESC: Load the control info from XML node
    //
    loadFromNode( node )
    {
        super.loadFromNode( node );

        // Get the slider specific settings
        let settingsNode = node.getElementsByTagName( 'settings' );
        if( settingsNode.length )
        {
            let attr = settingsNode[0].getAttribute( 'orientation' );
            if( attr && (attr === 'VERT') )
                this.orientation = _common_defs__WEBPACK_IMPORTED_MODULE_6__.EO_VERTICAL;

            attr = settingsNode[0].getAttribute( 'minValue' );
            if( attr )
                this.minValue = Number(attr);

            attr = settingsNode[0].getAttribute( 'maxValue' );
            if( attr )
                this.maxValue = Number(attr);

            attr = settingsNode[0].getAttribute( 'incValue' );
            if( attr )
                this.incValue = Number(attr);

            attr = settingsNode[0].getAttribute( 'defValue' );
            if( attr )
                this.curValue = Number(attr);

            attr = settingsNode[0].getAttribute( 'displayValueAsInt' );
            if( attr && (attr === 'true') )
                this.displayValueAsInt = true;

            attr = settingsNode[0].getAttribute( 'displayValueDecimalPlaces' );
            if( attr )
                this.displayValueDecimalPlaces = Number(attr);
        }
    }

    // 
    //  DESC: Load the control specific info from XML node
    //
    loadControlFromNode( node )
    {
        // Have the parent load it's stuff
        super.loadControlFromNode( node );

        // Get the position of the slider button as the default position
        this.defaultPos.copy( this.subControlAry[0].pos );

        // Get the slider specific settings
        let settingsNode = node.getElementsByTagName( 'settings' );
        if( settingsNode.length )
        {
            let attr = settingsNode[0].getAttribute( 'maxTravelDistPixels' );
            if( attr )
                this.travelDistPixels = Number(attr);
        }
    }

    // 
    //  DESC: Init the control
    //
    init()
    {
        super.init();

        this.updateSlider();
    }

    // 
    //  DESC: Handle OnUpAction message
    //
    onUpAction( event )
    {
        if( this.orientation == _common_defs__WEBPACK_IMPORTED_MODULE_6__.EO_VERTICAL )
        {
            // Handle the slider change
            if( event.arg[0] === _common_defs__WEBPACK_IMPORTED_MODULE_6__.EAP_DOWN )
                this.handleSliderChange( -this.incValue, true );
                
            else if( event.arg[0] === _common_defs__WEBPACK_IMPORTED_MODULE_6__.EAP_UP )
                // Prepare script function associated with handling this game event
                this.prepareControlScript( _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_4__.ECS_EXECUTE );
        }
    }

    // 
    //  DESC: Handle OnDownAction message
    //
    onDownAction( event )
    {
        if( this.orientation == _common_defs__WEBPACK_IMPORTED_MODULE_6__.EO_VERTICAL )
        {
            // Handle the slider change
            if( event.arg[0] === _common_defs__WEBPACK_IMPORTED_MODULE_6__.EAP_DOWN )
                this.handleSliderChange( this.incValue, true );

            else if( event.arg[0] === _common_defs__WEBPACK_IMPORTED_MODULE_6__.EAP_UP )
                // Prepare script function associated with handling this game event
                this.prepareControlScript( _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_4__.ECS_EXECUTE );
        }
    }

    // 
    //  DESC: Handle OnLeftAction message
    //
    onLeftAction( event )
    {
        if( this.orientation == _common_defs__WEBPACK_IMPORTED_MODULE_6__.EO_HORIZONTAL )
        {
            // Handle the slider change
            if( event.arg[0] === _common_defs__WEBPACK_IMPORTED_MODULE_6__.EAP_DOWN )
                this.handleSliderChange( -this.incValue, true );

            else if( event.arg[0] === _common_defs__WEBPACK_IMPORTED_MODULE_6__.EAP_UP )
                // Prepare script function associated with handling this game event
                this.prepareControlScript( _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_4__.ECS_EXECUTE );
        }
    }

    // 
    //  DESC: Handle OnRightAction message
    //
    onRightAction( event )
    {
        if( this.orientation == _common_defs__WEBPACK_IMPORTED_MODULE_6__.EO_HORIZONTAL )
        {
            // Handle the slider change
            if( event.arg[0] === _common_defs__WEBPACK_IMPORTED_MODULE_6__.EAP_DOWN )
                this.handleSliderChange( this.incValue, true );

            else if( event.arg[0] === _common_defs__WEBPACK_IMPORTED_MODULE_6__.EAP_UP )
                // Prepare script function associated with handling this game event
                this.prepareControlScript( _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_4__.ECS_EXECUTE );
        }
    }

    // 
    //  DESC: Handle OnUpScroll message
    //
    onUpScroll( /*event*/ )
    {
        this.handleSliderChange( -this.incValue );
    }

    // 
    //  DESC: Handle OnDownScroll message
    //
    onDownScroll( /*event*/ )
    {
        this.handleSliderChange( this.incValue );
    }

    // 
    //  DESC: Handle OnRightScroll message
    //
    onLeftScroll( /*event*/ )
    {
        this.handleSliderChange( -this.incValue );
    }

    // 
    //  DESC: Handle OnRightScroll message
    //
    onRightScroll( /*event*/ )
    {
        this.handleSliderChange( this.incValue );
    }

    // 
    //  DESC: Handle OnMouseMove message
    //
    onMouseMove( event )
    {
        let result = super.onMouseMove( event );

        if( this.isActive() && (this.pressType === _common_defs__WEBPACK_IMPORTED_MODULE_6__.EAP_DOWN) )
        {
            let oneOverAspectRatio = 1.0 / _utilities_settings__WEBPACK_IMPORTED_MODULE_2__.settings.orthoAspectRatio.h;

            if( this.orientation === _common_defs__WEBPACK_IMPORTED_MODULE_6__.EO_HORIZONTAL )
                this.incSliderMovePos( event.movementX * oneOverAspectRatio * (1 / event.gameAdjustedPixelRatio) );
            else
                this.incSliderMovePos( event.movementY * oneOverAspectRatio * (1 / event.gameAdjustedPixelRatio) );
        }

        return result;
    }

    // 
    //  DESC: Handle the select action
    //
    handleSelectAction( event )
    {
        let result = this.isActive() &&
                     (event.arg[_common_defs__WEBPACK_IMPORTED_MODULE_6__.ESMA_DEVICE_TYPE] === _common_defs__WEBPACK_IMPORTED_MODULE_6__.MOUSE) &&
                     this.isPointInControl( event.arg[_common_defs__WEBPACK_IMPORTED_MODULE_6__.ESMA_MOUSE_X], event.arg[_common_defs__WEBPACK_IMPORTED_MODULE_6__.ESMA_MOUSE_Y] );
             
        if( result && (event.arg[_common_defs__WEBPACK_IMPORTED_MODULE_6__.ESMA_PRESS_TYPE] === this.mouseSelectType) )
        {
            // Get the press type to know if we need to move the slider 
            // along with the mouse move
            this.pressType = this.mouseSelectType;

            if( event.arg[_common_defs__WEBPACK_IMPORTED_MODULE_6__.ESMA_PRESS_TYPE] === _common_defs__WEBPACK_IMPORTED_MODULE_6__.EAP_DOWN )
            {
                this.prepareControlScript( _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_4__.ECS_SELECT );

                let ratio = 1.0 / _utilities_settings__WEBPACK_IMPORTED_MODULE_2__.settings.orthoAspectRatio.h;

                if( this.orientation === _common_defs__WEBPACK_IMPORTED_MODULE_6__.EO_HORIZONTAL )
                    this.incSliderMovePos( (event.arg[_common_defs__WEBPACK_IMPORTED_MODULE_6__.ESMA_MOUSE_X] - this.subControlAry[0].collisionCenter.x) * ratio );
                else
                    this.incSliderMovePos( (event.arg[_common_defs__WEBPACK_IMPORTED_MODULE_6__.ESMA_MOUSE_Y] - this.subControlAry[0].collisionCenter.y) * ratio );
            }
        }
        else if( event.arg[_common_defs__WEBPACK_IMPORTED_MODULE_6__.ESMA_PRESS_TYPE] !== this.mouseSelectType )
        {
            // Prepare script function associated with handling this game event
            this.prepareControlScript( _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_4__.ECS_EXECUTE );
            
            this.pressType = _common_defs__WEBPACK_IMPORTED_MODULE_6__.EAP_IDLE;
        }

        return result;
    }

    // 
    //  DESC: Deactivate the control
    //
    deactivateControl()
    {
        super.deactivateControl();

        this.pressType = _common_defs__WEBPACK_IMPORTED_MODULE_6__.EAP_IDLE;
    }

    // 
    //  DESC: Handle the slider change
    //
    handleSliderChange( value, prepareOnSelect = false )
    {
        if( this.isActive() )
        {
            if( prepareOnSelect )
                this.prepareControlScript( _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_4__.ECS_SELECT );

            // Send a message to blink the button
            _managers_eventmanager__WEBPACK_IMPORTED_MODULE_3__.eventManager.dispatchEvent( 
                _gui_menudefs__WEBPACK_IMPORTED_MODULE_5__.EGE_MENU_CONTROL_STATE_CHANGE,
                _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_4__.ECS_SELECT,
                this.subControlAry[0] );

            this.incSlider( value );
        }
    }

    // 
    //  DESC: Set the slider inc value
    //
    setSlider( value = 0 )
    {
        this.curValue = value;

        // Update the slider
        this.updateSlider();
    }

    // 
    //  DESC: Set the slider inc value
    //
    incSlider( value = 0 )
    {
        this.curValue += value;

        // Update the slider
        this.updateSlider();
    }

    // 
    //  DESC: Inc the slider based on mouse movement
    //
    incSliderMovePos( value )
    {
        this.curValue += value * ((this.maxValue - this.minValue) / this.travelDistPixels);

        // Update the slider
        this.updateSlider();
    }

    // 
    //  DESC: Update the slider
    //
    updateSlider()
    {
        // Cap current value to it's range
        this.capSliderValue();

        // Set the position of the slider
        this.setSliderPos();

        // Set the slider label if there is one
        if( this.stringAry.length )
        {
            // Format for display
            let valueStr;

            if( this.displayValueAsInt )
                valueStr = this.stringAry[this.stringAry.length-1].replace(/%d/i, Math.trunc(this.curValue));
            else
                valueStr = this.stringAry[this.stringAry.length-1].replace(/%d/i, this.curValue.toFixed(this.displayValueDecimalPlaces));

            this.createFontString( valueStr );
        }
    }

    // 
    //  DESC: Cap the slider value
    //
    capSliderValue()
    {
        // Cap current value to range
        if( this.curValue < this.minValue )
            this.curValue = this.minValue;

        else if( this.curValue > this.maxValue )
            this.curValue = this.maxValue;
    }

    // 
    //  DESC: Set the position of the slider
    //
    setSliderPos()
    {
        if( Math.abs(this.maxValue) > 0.001 )
        {
            let startPos = -(this.travelDistPixels / 2);
            let pixelsPerValue = this.travelDistPixels / (this.maxValue - this.minValue);
            let pos = startPos + (pixelsPerValue * (this.curValue - this.minValue));

            if( this.orientation === _common_defs__WEBPACK_IMPORTED_MODULE_6__.EO_HORIZONTAL )
                this.subControlAry[0].setPosXYZ( this.defaultPos.x + pos, this.defaultPos.y );
            else
                this.subControlAry[0].setPosXYZ( this.defaultPos.x, this.defaultPos.y + -pos );
        }
    }

    // 
    //  DESC: Is the mouse down
    //
    isMouseDown()
    {
        return (this.pressType === _common_defs__WEBPACK_IMPORTED_MODULE_6__.EAP_DOWN);
    }
}


/***/ }),
/* 138 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UIScrollBox": () => (/* binding */ UIScrollBox)
/* harmony export */ });
/* harmony import */ var _uisubcontrol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(134);
/* harmony import */ var _common_point__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14);
/* harmony import */ var _sprite_sprite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);
/* harmony import */ var _objectdatamanager_objectdatamanager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(112);
/* harmony import */ var _managers_eventmanager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(30);
/* harmony import */ var _utilities_highresolutiontimer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(56);
/* harmony import */ var _system_device__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(9);
/* harmony import */ var _utilities_xmlparsehelper__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(19);
/* harmony import */ var _uicontrolfactory__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(127);
/* harmony import */ var _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(132);
/* harmony import */ var _gui_menudefs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(36);
/* harmony import */ var _common_defs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(6);

// 
//  FILE NAME: uiscrollbox.js
//  DESC:      Class for user interface scroll boxes
//















const IN_VIEWABLE_AREA = 1;
const NEW_ACTIVE_CTRL = 2;

class UIScrollBox extends _uisubcontrol__WEBPACK_IMPORTED_MODULE_0__.UISubControl
{
    constructor( group )
    {
        super( group );
        
        this.type = _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_9__.ECT_SCROLL_BOX;

        // Array list of controls in scroll box
        this.scrollControlAry = [];

        // Initial scroll box control offset
        this.initialOffset = new _common_point__WEBPACK_IMPORTED_MODULE_1__.Point;

        // Height to cull
        this.cullHeight = 0;

        // height of control
        this.controlHeight = 0;

        // Scroll move counter
        this.scrollCurPos = 0;

        // Number of controls visible in scroll box
        this.visibleCount = 0;

        // Visible start pos
        this.visStartPos = 0;
        this.visEndPos = 0;

        // Max scroll amount
        this.maxMoveAmount = 0;

        // stencil mask sprite
        this.stencilMaskSprite;

        // Active scroll control index in this control
        this.activeScrollCtrl = _common_defs__WEBPACK_IMPORTED_MODULE_11__.NO_ACTIVE_CONTROL;

        // index of first control in scroll box
        this.firstScrollCtrlIndex = 0;

        // Default offsets
        this.defaultOffsetAry = [];

        // speed members
        this.scrollSpeed = 0.05;
        this.pageSpeed = 0.05;

        // Scroll vector to indicate the control is scrolling
        this.scrollVector = 0;

        // Flag to indicate the control is paging
        this.paging = 0;

        // Scroll counter
        this.scrollCounter = 0;

        // Scroll distance
        this.scrollDistance = 0;

        // Flag to indicate scrolling needs to stop
        // but allows the scrolling to finish
        this.endScroll = false;

        // Flag to indicate that the scroll message has been sent
        this.scrollMsg = false;

        // Flag to allow for end scroll selection
        this.endScrollSelection = false;
    }
    
    // 
    //  DESC: Load the control info from XML node
    //
    loadFromNode( node )
    {
        super.loadFromNode( node );

        // Init the slider
        this.subControlAry[0].maxValue = this.maxMoveAmount;
        this.subControlAry[0].setSlider();

        // Get the scrolling info
        let scrollNode = node.getElementsByTagName( 'scroll' );
        if( scrollNode.length )
        {
            let attr = scrollNode[0].getAttribute( 'scrollSpeed' );
            if( attr )
                this.scrollSpeed = Number( attr );

            attr = scrollNode[0].getAttribute( 'pageSpeed' );
            if( attr )
                this.pageSpeed = Number( attr );
        }

        // Calc the start and end positions of what should
        // be viewable in the scroll box
        this.setStartEndPos();
    }

    // 
    //  DESC: Load the control specific info from XML node
    //
    loadControlFromNode( node )
    {
        super.loadControlFromNode( node );

        // Get the menu controls node
        let menuControlsNode = node.getElementsByTagName( "scrollBoxControlList" );
        if( menuControlsNode.length )
        {
            // Get the initial offset of the first control in the scroll box
            this.initialOffset = _utilities_xmlparsehelper__WEBPACK_IMPORTED_MODULE_7__.loadPosition( menuControlsNode[0] );

            // Get the scroll boc info node
            let controlInfoNode = menuControlsNode[0].getElementsByTagName( "controlInfo" );
            this.controlHeight = Number( controlInfoNode[0].getAttribute( "height" ) );
            this.visibleCount = Number( controlInfoNode[0].getAttribute( "visibleInScrollBox" ) );

            // Get the number of controls in this scroll box
            let scrollControlNode = menuControlsNode[0].getElementsByTagName( "control" );

            // Add the scroll control from node
            for( let i = 0; i < scrollControlNode.length; ++i )
                this.addScrollControlFromNode( scrollControlNode[i] );
        }

        // Get the stencil mask node
        let stencilMaskNode = node.getElementsByTagName( "stencilMask" );
        if( stencilMaskNode.length )
        {
            let objectName = stencilMaskNode[0].getAttribute( "objectName" );

            this.stencilMaskSprite = new _sprite_sprite__WEBPACK_IMPORTED_MODULE_2__.Sprite( _objectdatamanager_objectdatamanager__WEBPACK_IMPORTED_MODULE_3__.objectDataManager.getData( this.group, objectName ) );

            // Get the cull height
            this.cullHeight = (this.stencilMaskSprite.objData.size.w + this.controlHeight) / 2;

            // Load the transform data
            this.stencilMaskSprite.load( stencilMaskNode[0] );
        }
    }

    // 
    //  DESC: Add the scroll control from node
    //  NOTE: This function recalculates the scroll box members because
    //        it is also used for run-time dynamic scroll boxes
    //
    addScrollControlFromNode( node )
    {
        // The reference is placed within a array for all controls
        let ctrl = _uicontrolfactory__WEBPACK_IMPORTED_MODULE_8__.create( node, this.group );
        this.scrollControlAry.push( ctrl );

        // Get the position for this control
        let posY = this.initialOffset.y - (this.controlHeight * (this.scrollControlAry.length-1));

        // Record the default y offset
        this.defaultOffsetAry.push( posY );

        // Set the position
        ctrl.setPosXYZ( this.initialOffset.x, posY, this.initialOffset.z );

        // Init the control visual state
        ctrl.deactivateControl();

        // Calculate the maximum scroll amount in pixels
        if( this.scrollControlAry.length > this.visibleCount )
            this.maxMoveAmount = (this.scrollControlAry.length - this.visibleCount) * this.controlHeight;

        return ctrl;
    }

    // 
    //  DESC: Init the control
    //
    init()
    {
        super.init();

        // Init all controls
        for( let i = 0; i < this.scrollControlAry.length; ++i )
            this.scrollControlAry[i].init();
    }

    // 
    //  DESC: Do some cleanup
    //
    cleanUp()
    {
        super.cleanUp();

        // Init all controls
        for( let i = 0; i < this.scrollControlAry.length; ++i )
            this.scrollControlAry[i].cleanUp();
    }

    // 
    //  DESC: Handle events
    //
    handleEvent( event )
    {
        super.handleEvent( event );

        for( let i = this.visStartPos; i < this.visEndPos; ++i )
            this.scrollControlAry[i].handleEvent( event );
    }

    // 
    //  DESC: Handle OnUpAction message
    //
    onUpAction( event )
    {
        if( event.arg[0] === _common_defs__WEBPACK_IMPORTED_MODULE_11__.EAP_DOWN )
            this.handleKeyboardGamepadScroll( -1 );

        else if( event.arg[0] === _common_defs__WEBPACK_IMPORTED_MODULE_11__.EAP_UP )
            this.endScroll = true;
    }

    // 
    //  DESC: Handle OnDownAction message
    //
    onDownAction( event )
    {
        if( event.arg[0] === _common_defs__WEBPACK_IMPORTED_MODULE_11__.EAP_DOWN )
            this.handleKeyboardGamepadScroll( 1 );

        else if( event.arg[0] === _common_defs__WEBPACK_IMPORTED_MODULE_11__.EAP_UP )
            this.endScroll = true;
    }

    // 
    //  DESC: Handle OnUpScroll message
    //
    onUpScroll( event )
    {
        this.handleKeyboardGamepadScroll( -1 );
        this.scrollMsg = true;
    }

    // 
    //  DESC: Handle OnDownScroll message
    //
    onDownScroll( event )
    {
        this.handleKeyboardGamepadScroll( 1 );
        this.scrollMsg = true;

    }   // OnDownScroll

    // 
    //  DESC: Handle OnTabLeft message
    //
    onTabLeft( event )
    {
        if( event.arg[0] === _common_defs__WEBPACK_IMPORTED_MODULE_11__.EAP_DOWN )
            this.handlePageScroll( -1 );
    }

    // 
    //  DESC: Handle OnTabRight message
    //
    onTabRight( event )
    {
        if( event.arg[0] === _common_defs__WEBPACK_IMPORTED_MODULE_11__.EAP_DOWN )
            this.handlePageScroll( 1 );
    }

    // 
    //  DESC: Handle the mouse move
    //
    onMouseMove( event )
    {
        let result = super.onMouseMove( event );

        // Invalidate the active control
        this.activeScrollCtrl = _common_defs__WEBPACK_IMPORTED_MODULE_11__.NO_ACTIVE_CONTROL;

        if( this.subControlAry[0].isMouseDown() )
        {
            // Get the current scroll position
            this.scrollCurPos = this.subControlAry[0].curValue;

            // Set the bounds
            this.setStartEndPos();

            // Reposition the scroll controlls
            this.repositionScrollControls();
        }

        return result;
    }

    // 
    //  DESC: Handle the wheel events. This control handles wheel events
    //
    onWheel( event )
    {
        let scrollCurPos = this.scrollCurPos + (event.deltaY * 0.5);

        // Handle bounds checking
        if( scrollCurPos < 0 )
            scrollCurPos = 0;

        else if( scrollCurPos > this.maxMoveAmount )
            scrollCurPos = this.maxMoveAmount;
        
        // Set the current scroll position
        this.scrollCurPos = scrollCurPos;

        // Move the slider
        this.subControlAry[0].setSlider(this.scrollCurPos);

        // Set the bounds
        this.setStartEndPos();

        // Reposition the scroll controlls
        this.repositionScrollControls();
    }

    // 
    //  DESC: Update the control
    //
    update()
    {
        super.update();

        // Update all controls
        for( let i = this.visStartPos; i < this.visEndPos; ++i )
            this.scrollControlAry[i].update();

        // Handle any scrolling
        this.handleScrollUpdate();
    }

    // 
    //  DESC: Transform the control
    //
    transform( object )
    {
        // Call the parent
        super.transform( object );

        // Transform all controls
        for( let i = this.visStartPos; i < this.visEndPos; ++i )
            this.scrollControlAry[i].transform( this );

        // Transform the mask
        this.stencilMaskSprite.transform( this );
    }

    // 
    //  DESC: Render the sub control
    //
    render( camera )
    {
        // Call the parent
        super.render( camera );


        let gl = _system_device__WEBPACK_IMPORTED_MODULE_6__.device.gl;

        // Disable rendering to the color buffer
        // NOTE: Using gl.FALSE or gl.TRUE causes a problem with this function call
        gl.colorMask( false, false, false, false );
        
        // Disable rendering to the depth mask
        gl.depthMask( false );

        // Start using the stencil
        gl.enable( gl.STENCIL_TEST );

        gl.stencilFunc( gl.ALWAYS, 0x1, 0x1 );
        gl.stencilOp( gl.REPLACE, gl.REPLACE, gl.REPLACE );


        this.stencilMaskSprite.render( camera );


        // Re-enable color
        // NOTE: Using gl.FALSE or gl.TRUE causes a problem with this function call
        gl.colorMask( true, true, true, true );

        // Where a 1 was not rendered
        gl.stencilFunc( gl.EQUAL, 0x1, 0x1 );

        // Keep the pixel
        gl.stencilOp( gl.KEEP, gl.KEEP, gl.KEEP );

        // Enable rendering to the depth mask
        gl.depthMask( true );


        for( let i = this.visStartPos; i < this.visEndPos; ++i )
            this.scrollControlAry[i].render( camera );


        // Finished using stencil
        gl.disable( gl.STENCIL_TEST );
    }

    // 
    //  DESC: Set the first inactive control to be active
    //  NOTE: Don't want this functuality for the scroll box buttons and slider
    //
    activateFirstInactiveControl()
    {
        if( super.baseActivateFirstInactiveControl() )
        {
            for( let i = 0; i < this.scrollControlAry.length; ++i )
            {
                if( this.scrollControlAry[i].activateFirstInactiveControl() )
                {
                    this.activeScrollCtrl = i;
                    break;
                }
            }
        }

        return this.activeScrollCtrl != _common_defs__WEBPACK_IMPORTED_MODULE_11__.NO_ACTIVE_CONTROL;
    }

    // 
    //  DESC: Handle the select action
    //
    handleSelectAction( event )
    {
        let result = super.handleSelectAction( event );

        // Let the scroll controls handle any selection
        for( let i = 0; i < this.scrollControlAry.length && !result; ++i )
        {
            result = this.scrollControlAry[i].handleSelectAction( event );
            if( result )
            {
                // Set the active scroll control to the one the mouse clicked
                if( event.arg[_common_defs__WEBPACK_IMPORTED_MODULE_11__.ESMA_DEVICE_TYPE] === _common_defs__WEBPACK_IMPORTED_MODULE_11__.MOUSE )
                    this.activeScrollCtrl = i;
                    
                break;
            }
        }

        if( result && (event.arg[_common_defs__WEBPACK_IMPORTED_MODULE_11__.ESMA_DEVICE_TYPE] === _common_defs__WEBPACK_IMPORTED_MODULE_11__.MOUSE) &&
            (event.arg[_common_defs__WEBPACK_IMPORTED_MODULE_11__.ESMA_PRESS_TYPE] === _common_defs__WEBPACK_IMPORTED_MODULE_11__.EAP_DOWN) )
        {
            // Get the current scroll position
            this.scrollCurPos = this.subControlAry[0].curValue;

            // Set the bounds
            this.setStartEndPos();

            // Reposition the scroll controlls
            this.repositionScrollControls();
        }

        return result;
    }

    // 
    //  DESC: Handle the page scrolling
    //
    handlePageScroll( scrollVector )
    {
        if( this.scrollVector == 0 )
        {
            // If there's no controls to select or reposition, do the scroll
            if( !this.selectAndRepositionCtrl( scrollVector ) )
            {
                const SCROLL_DOWN = (scrollVector > 0);
                const SCROLL_UP = (scrollVector < 0);

                // Make sure we have some place to page to
                if( (SCROLL_UP && (this.firstScrollCtrlIndex > 0)) ||
                    (SCROLL_DOWN && (this.firstScrollCtrlIndex + this.visibleCount < this.scrollControlAry.length)) )
                {
                    let visibleCount = this.visibleCount;

                    // Cap the scroll amount to what is capable
                    if( SCROLL_UP && (visibleCount > this.firstScrollCtrlIndex) )
                    {
                        visibleCount = this.firstScrollCtrlIndex;
                    }
                    else if( SCROLL_DOWN &&
                           ((visibleCount + this.firstScrollCtrlIndex + this.visibleCount - 1) >= this.scrollControlAry.length) )
                    {
                        visibleCount = this.scrollControlAry.length - this.firstScrollCtrlIndex - this.visibleCount;
                    }

                    // Init the scroll
                    this.initScrolling( scrollVector, this.controlHeight * visibleCount, true, true );

                    // Deactivate the last control if the scrolling has been activated
                    if( this.scrollVector )
                    {
                        if( this.activeScrollCtrl != _common_defs__WEBPACK_IMPORTED_MODULE_11__.NO_ACTIVE_CONTROL )
                            this.scrollControlAry[this.activeScrollCtrl].deactivateControl();
                    }
                }
                else
                {
                    this.activeScrollCtrl = this.firstScrollCtrlIndex;

                    if( SCROLL_DOWN )
                        this.activeScrollCtrl += this.visibleCount - 1;

                    // If the first control can't be selected, then find one that can
                    if( !this.activateScrollCtrl( this.activeScrollCtrl ) )
                        this.selectNextControl( -scrollVector );
                }
            }
        }
    }

    // 
    //  DESC: Handle the keyboard/Gamepad scrolling
    //
    handleKeyboardGamepadScroll( scrollVector )
    {
        // If there's no controls to select or reposition, do the scroll
        if( !this.selectAndRepositionCtrl( scrollVector ) )
        {
            // Try to select the next control
            let scrollResult = this.selectNextControl( scrollVector );

            // Scroll the contents of the scroll box if we need to activate a control
            // that's outside of the viewable area of the scroll box.
            if( !(scrollResult & IN_VIEWABLE_AREA) )
            {
                this.initScrolling( scrollVector, this.controlHeight );
            }
        }
    }

    // 
    //  DESC: Select the next control
    //
    selectNextControl( scrollVector )
    {
        // Set the active control to the viewable area
        this.setActiveCtrlToViewableArea( scrollVector );

        // Scroll to the next control in the viewable area
        let scrollResult = this.scrollToTheNextCtrlInViewableArea( scrollVector );

        // If we are still in the viewable area but have no active control,
        // try to activate the current control
        if( (scrollResult & IN_VIEWABLE_AREA) && !(scrollResult & NEW_ACTIVE_CTRL) )
        {
            _managers_eventmanager__WEBPACK_IMPORTED_MODULE_4__.eventManager.dispatchEvent(
                _gui_menudefs__WEBPACK_IMPORTED_MODULE_10__.EGE_MENU_CONTROL_STATE_CHANGE,
                _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_9__.ECS_ACTIVE,
                this.scrollControlAry[this.activeScrollCtrl] );
        }

        return scrollResult;
    }

    // 
    //  DESC: Do we need to select and reposition the control
    //
    selectAndRepositionCtrl( scrollVector )
    {
        // If there's no selected control, don't scroll
        // just select the first selectable control
        if( this.setActiveCtrlToViewableArea( scrollVector ) )
        {
            // If the first control can't be selected, then find one that can
            if( !this.activateScrollCtrl( this.activeScrollCtrl ) )
                this.selectNextControl( 1 );

            // Get the alignment to see if it needs to be adjusted
            let diff = this.getControlAlignment();
            if( diff > 0.1 )
            {
                let pos = this.scrollCurPos / this.controlHeight;

                let nextCtrl = (this.activeScrollCtrl - this.firstScrollCtrlIndex) * this.controlHeight;

                if( nextCtrl || (this.firstScrollCtrlIndex > pos) )
                    this.initScrolling( 1, this.controlHeight - diff, false );
                else
                    this.initScrolling( -1, diff, false );
            }

            return true;
        }

        return false;
    }

    // 
    //  DESC: Select the paged control
    //
    selectPagedControl( scrollVector )
    {
        this.activeScrollCtrl += scrollVector * this.visibleCount;

        // Cap the control index
        if( this.activeScrollCtrl <= 0 )
        {
            this.activeScrollCtrl = 0;
            scrollVector = 1;
        }
        else if( this.activeScrollCtrl >= this.scrollControlAry.length - 1 )
        {
            this.activeScrollCtrl = this.scrollControlAry.size() -1;
            scrollVector = -1;
        }

        // If the first control can't be selected, then find one that can
        if( !this.activateScrollCtrl( this.activeScrollCtrl ) )
            this.selectNextControl( scrollVector );
    }

    // 
    //  DESC: Set the active control to the viewable area
    //        This also deactivates the last known active control
    //
    setActiveCtrlToViewableArea( scrollVector )
    {
        // If the active control is not within the active area, make it so that it will be the first one selected
        if( (this.activeScrollCtrl < this.firstScrollCtrlIndex) || (this.activeScrollCtrl >= (this.firstScrollCtrlIndex + this.visibleCount)) )
        {
            if( this.activeScrollCtrl != _common_defs__WEBPACK_IMPORTED_MODULE_11__.NO_ACTIVE_CONTROL )
                this.scrollControlAry[this.activeScrollCtrl].deactivateControl();

            this.activeScrollCtrl = this.firstScrollCtrlIndex;

            return true;
        }

        return false;
    }

    // 
    //  DESC: Scroll to the next control in the viewable area
    //
    scrollToTheNextCtrlInViewableArea( scrollVector )
    {
        let newActiveCtrl = 0;
        let inView = this.inView( this.activeScrollCtrl, scrollVector );

        // Only scroll within the viewable area
        if( inView )
        {
            // Set a temp variable to the active scroll control
            let tmpScrollCtrl = this.activeScrollCtrl;

            // Loop until we hit a selectable control
            do
            {
                tmpScrollCtrl += scrollVector;

                if( this.activateScrollCtrl( tmpScrollCtrl ) )
                {
                    newActiveCtrl = NEW_ACTIVE_CTRL;

                    this.activeScrollCtrl = tmpScrollCtrl;
                    break;
                }

                inView = this.inView( tmpScrollCtrl, scrollVector );
            }
            while( inView );
        }

        let result = inView | newActiveCtrl;

        return result;
    }

    // 
    //  DESC: See if we can activate this scroll control
    //
    activateScrollCtrl( scrollControlIndex )
    {
        if( (scrollControlIndex != _common_defs__WEBPACK_IMPORTED_MODULE_11__.NO_ACTIVE_CONTROL) &&
            (scrollControlIndex < this.scrollControlAry.length) &&
            !this.scrollControlAry[scrollControlIndex].isDisabled() )
        {
            _managers_eventmanager__WEBPACK_IMPORTED_MODULE_4__.eventManager.dispatchEvent(
                _gui_menudefs__WEBPACK_IMPORTED_MODULE_10__.EGE_MENU_CONTROL_STATE_CHANGE,
                _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_9__.ECS_ACTIVE,
                this.scrollControlAry[scrollControlIndex] );

            return true;
        }

        return false;
    }

    // 
    //  DESC: Init the variables that scroll the contents of the scroll box
    //
    initScrolling( scrollVector, distance, endScrollSelection = true, paging = false )
    {
        if( this.scrollVector === 0 )
        {
            const SCROLL_DOWN = (scrollVector > 0);
            const SCROLL_UP = (scrollVector < 0);

            if( ((SCROLL_UP && (this.scrollCurPos > 0)) ||
                (SCROLL_DOWN && (this.scrollCurPos < this.maxMoveAmount))) )
            {
                this.scrollVector = scrollVector;
                this.scrollCounter = 0;
                this.endScroll = false;
                this.scrollMsg = false;
                this.paging = paging;
                this.endScrollSelection = endScrollSelection;
                this.scrollDistance = distance;
            }
        }
    }

    // 
    //  DESC: Handle the time based Scrolling of the contents of the scroll box
    //
    handleScrollUpdate()
    {
        if( this.scrollVector )
        {
            let dist = _utilities_highresolutiontimer__WEBPACK_IMPORTED_MODULE_5__.highResTimer.elapsedTime * this.scrollSpeed;

            if( this.paging )
                dist = _utilities_highresolutiontimer__WEBPACK_IMPORTED_MODULE_5__.highResTimer.elapsedTime * this.pageSpeed;

            if( this.scrollVector > 0 )
                this.scrollCurPos += dist;
            else
                this.scrollCurPos -= dist;

            this.subControlAry[0].setSlider(this.scrollCurPos);

            this.scrollCounter += dist;

            // Set the bounds
            this.setStartEndPos();

            if( this.scrollCounter >= this.scrollDistance )
            {
                if( this.endScroll || !this.scrollMsg || this.paging )
                {
                    this.alignScrollPostion();

                    if( this.endScrollSelection )
                    {
                        if( this.paging )
                            this.selectPagedControl( this.scrollVector );
                        else
                            this.selectNextControl( this.scrollVector );
                    }

                    // This has to be last
                    this.scrollVector = 0;
                }
                else
                {
                    this.scrollDistance += this.controlHeight;
                }
            }
            // Sanity check
            else if( (this.scrollCurPos < 0) || (this.scrollCurPos > this.maxMoveAmount) )
            {
                this.alignScrollPostion();
                this.scrollVector = 0;
            }

            // Reposition the scroll controls
            this.repositionScrollControls();
        }
    }

    // 
    //  DESC: Get the fractional amount the controls are off within the scroll box
    //
    getControlAlignment()
    {
        let pos = this.scrollCurPos / this.controlHeight;
        return this.controlHeight * Math.trunc(pos);
    }

    // 
    //  DESC: Is the scroll index in view
    //
    inView( scrollIndex, scrollVector )
    {
        return ((scrollVector < 0) && (scrollIndex > this.firstScrollCtrlIndex)) ||
               (((scrollVector > 0)) && (scrollIndex < (this.firstScrollCtrlIndex + this.visibleCount - 1)));
    }

    // 
    //  DESC: Get the reference to the subcontrol if found
    //
    findSubControlByName( name )
    {
        let ctrl = super.findSubControlByName( name );

        for( let i = this.visStartPos; i < this.visEndPos && (ctrl === null); ++i )
            ctrl = this.scrollControlAry[i].findControlByName( name );

        return ctrl;
    }

    // 
    //  DESC: Find the sub control via is pointer
    //
    findSubControlByRef( control )
    {
        let ctrl = super.findSubControlByRef( control );

        for( let i = this.visStartPos; i < this.visEndPos && (ctrl === null); ++i )
            if( this.scrollControlAry[i] === control )
                ctrl = this.scrollControlAry[i];

        return ctrl;
    }

    // 
    //  DESC: Handle the sub control mouse move
    //
    onSubControlMouseMove( event )
    {
        let result = super.onSubControlMouseMove( event );

        // We only care about the scroll controls if the point is within the scroll box
        if( !result && this.isPointInControl( event.gameAdjustedMouseX, event.gameAdjustedMouseY ) )
        {
            for( let i = this.visStartPos; i < this.visEndPos && !result; ++i )
            {
                result = this.scrollControlAry[i].onMouseMove( event );

                if( result )
                    this.activeScrollCtrl = i;
            }
        }

        return result;
    }

    // 
    //  DESC: Deactivate the sub control
    //
    deactivateSubControl()
    {
        super.deactivateSubControl();

        for( let i = this.visStartPos; i < this.visEndPos; ++i )
            this.scrollControlAry[i].deactivateControl();
    }

    // 
    //  DESC: Set the start and end positions
    //
    setStartEndPos()
    {
        let pos = this.scrollCurPos / this.controlHeight;

        // Push the ceiling so that the starting index is viewable
        this.firstScrollCtrlIndex = Math.trunc(pos + 0.7);

        this.visStartPos = Math.trunc(pos);
        this.visEndPos = this.visStartPos + this.visibleCount + 1;

        // Sanity checks
        if( this.visStartPos < 0 )
            this.visStartPos = 0;

        if( this.visEndPos > this.scrollControlAry.length )
            this.visEndPos = this.scrollControlAry.length;
    }

    // 
    //  DESC: Reposition the scroll controls
    //
    repositionScrollControls()
    {
        for( let i = this.visStartPos; i < this.visEndPos; ++i )
        {
            let pos = this.scrollControlAry[i].pos;
            let y = this.defaultOffsetAry[i] + this.scrollCurPos;
            this.scrollControlAry[i].setPosXYZ( pos.x, y, pos.z );
        }
    }

    // 
    //  DESC: Align the scroll box to it's proper stopping point
    //        to account for floating point movement
    //
    alignScrollPostion()
    {
        // Do bounds checking just for sanity reasons
        if( this.firstScrollCtrlIndex < 0 )
            this.firstScrollCtrlIndex = 0;

        else if( (this.firstScrollCtrlIndex + this.visibleCount) > this.scrollControlAry.length )
            this.firstScrollCtrlIndex = this.scrollControlAry.length - this.visibleCount;

        // Recalucate the scroll position which will wipe the fractional component
        this.scrollCurPos = this.firstScrollCtrlIndex * this.controlHeight;
    }

    // 
    //  DESC: Only deactivate sub controls
    //
    deactivateControl()
    {
        this.deactivateSubControl();
    }

    // 
    //  DESC: Set the alpha value of this control
    //
    setAlpha( alpha )
    {
        super.setAlpha( alpha );

        for( let i = this.visStartPos; i < this.visEndPos; ++i )
            this.scrollControlAry[i].setAlpha( alpha );
    }

    // 
    //  DESC: Get the pointer to the active control
    //
    getActiveControl()
    {
        let result = super.getActiveControl();

        if( result === null )
        {
            for( let i = 0; i < this.scrollControlAry.length; ++i )
            {
                if( this.scrollControlAry[i].state > _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_9__.ECS_INACTIVE )
                {
                    result = this.scrollControlAry[i].getActiveControl();
                    break;
                }
            }
        }

        return result;
    }
}


/***/ }),
/* 139 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UIMeter": () => (/* binding */ UIMeter)
/* harmony export */ });
/* harmony import */ var _utilities_timer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(140);
/* harmony import */ var _utilities_highresolutiontimer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(56);
/* harmony import */ var _common_size__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony import */ var _uicontrol__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(129);
/* harmony import */ var _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(132);
/* harmony import */ var _utilities_xmlparsehelper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(19);

// 
//  FILE NAME: uimeter.js
//  DESC:      Class for user interface meters
//










// EBangType
const EBT_RAMP_UP = 0,
      EBT_LINEAR  = 1,
      EBT_HYBRID  = 2;
    
// EScaleType
const EST_AXIS     = 0,
      EST_ACCURATE = 1;
      
class BangRange
{
    constructor( target, bangType, velocity, estimatedTime, slowStartTime )
    {
        this.target = target;
        this.bangType = bangType;
        this.velocity = velocity;
        this.estimatedTime = estimatedTime;
        this.slowStartTime = slowStartTime;
    }
}

class UIMeter extends _uicontrol__WEBPACK_IMPORTED_MODULE_3__.UIControl
{
    constructor( group )
    {
        super( group );
        
        this.type = _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_4__.ECT_METER;
        
        // Current value
        this.currentValue = 0;

        // Target value
        this.targetValue = 0;

        // Velocity value
        this.velocity = 0;

        // Terminal velocity value
        this.terminalVelocity = 0;

        // Acceleration value
        this.acceleration = 0;

        // Impulse value
        this.impulse = 0;

        // last value
        this.lastValue = 0;

        // fast bang time amount
        this.fastBangTime = 0;

        // bang up flag
        this.bangUp = false;

        // spin timer
        this.startUpTimer = new _utilities_timer__WEBPACK_IMPORTED_MODULE_0__.Timer;

        // Current bang range
        this.bangRange = new BangRange;

        // Sprite reference to font
        this.fontSprite = null;

        // Bang range value
        this.bangRangeAry = [];

        // Max Font string size for this meter
        this.maxFontStrSize = null;

        // The amount to scale the font by to fit within the meter
        this.bangScaleAdjustment = new _common_size__WEBPACK_IMPORTED_MODULE_2__.Size(1, 1);

        // Scale on axis or accurate
        this.scaleType = EST_AXIS;
    }
    
    //
    //  DESC: Load the control info from XML node
    //
    loadFromNode( node )
    {
        super.loadFromNode( node );

        // Get the bang range info
        let bangRangeNode = node.getElementsByTagName( 'bangRange' );
        if( bangRangeNode.length )
        {
            // Get the fast bang time
            this.fastBangTime = Number(bangRangeNode[0].getAttribute( 'fastBangTime' ));

            // Set the scale type - How the font is scaled to fit within the meter
            if( bangRangeNode[0].getAttribute('scaleType') === 'accurate' )
                this.scaleType = EST_ACCURATE;

            let rangeNode = bangRangeNode[0].getElementsByTagName( 'range' );
            
            for( let i = 0; i < rangeNode.length; ++i )
            {
                let attr = rangeNode[i].getAttribute( 'bangUpType' );
                let bangType = EBT_RAMP_UP;
                if( attr === 'linear' )
                    bangType = EBT_LINEAR;
                else if( attr === 'hybrid' )
                    bangType = EBT_HYBRID;

                this.bangRangeAry.push( new BangRange(
                    Number(rangeNode[i].getAttribute( 'target' )),
                    bangType,
                    Number(rangeNode[i].getAttribute( 'velocity' )),
                    Number(rangeNode[i].getAttribute( 'estimatedTime' )),
                    Number(rangeNode[i].getAttribute( 'slowStartTime' )) ) );
            }
        }

        // Get the max size of the font string to fit within this meter.
        // As the string get's bigger, it will be scaled to fit.
        this.maxFontStrSize = _utilities_xmlparsehelper__WEBPACK_IMPORTED_MODULE_5__.loadSize( node );
        
        // If no meter scripts are defined, display the current value
        if( node.getElementsByTagName( 'meterScript' ).length == 0 )
            this.displayValue();
    }

    //
    //  DESC: Load the control specific info from XML node
    //
    loadControlFromNode( controlNode )
    {
        // Call the parent
        super.loadControlFromNode( controlNode );

        // Find the sprite that renders the font
        this.findFontSprite();
    }
    
    //
    //  DESC: Find the sprite that renders the font
    //        NOTE: Should always be the last font sprite in the sprite list
    //
    findFontSprite()
    {
        for( let i = 0; i < this.spriteAry.length; ++i )
        {
            if( this.spriteAry[i].visualComponent.isFontSprite() )
                this.fontSprite = this.spriteAry[i];
        }

        if( this.fontSprite == null )
            throw new Error( `UI Meter doesn't have a sprite for rendering a font string (${this.name}).` );
    }

    //
    //  DESC: Set the amount to the meter without banging up
    //
    set( amount )
    {
        if( amount !== this.currentValue )
        {
            this.lastValue = this.currentValue;
            this.currentValue = this.targetValue = amount;

            // Display the value in the meter
            this.displayValue();
        }
    }

    //
    //  DESC: Start the bang range
    //
    startBangUp( amount )
    {
        if( amount !== this.currentValue )
        {
            this.targetValue = amount;
            this.bangUp = true;

            this.setBangRange();
        }
    }

    //
    //  DESC: Start the bang range
    //
    incBangUp( amount )
    {
        this.targetValue += amount;
        this.bangUp = true;

        this.setBangRange();
    }

    //
    //  DESC: Set the bang range
    //
    setBangRange()
    {
        let found = false;

        for( let i = 0; i < this.bangRangeAry.length; ++i )
        {
            if( (this.targetValue - this.currentValue) <= this.bangRangeAry[i].target )
            {
                found = true;
                this.initBangRange( this.bangRangeAry[i] );
                break;
            }
        }

        if( !found )
            this.initBangRange( this.bangRangeAry[this.bangRangeAry.length-1] );
    }

    //
    //  DESC: Init the bang range
    //
    initBangRange( bangRange )
    {
        this.bangRange = bangRange;
        this.terminalVelocity = 0.0;
        this.acceleration = 0.0;
        this.impulse = 0.0;
        this.bangScaleAdjustment.set(1,1);

        this.fontSprite.setScaleXYZ( 1, 1, 1 );

        this.velocity = bangRange.velocity / 1000.0;

        let range = this.targetValue - this.currentValue;

        // Ramp up from start to finish
        if( bangRange.bangType === EBT_RAMP_UP )
        {
            this.impulse = range / (bangRange.estimatedTime * bangRange.estimatedTime * 1000.0);
            this.acceleration = this.impulse;
        }
        // Linear bang up from the start
        else if( bangRange.bangType === EBT_LINEAR )
        {
            this.acceleration = range / (bangRange.estimatedTime * 1000.0);
        }
        // combination of ramp up and linear
        else if( bangRange.bangType === EBT_HYBRID )
        {
            this.terminalVelocity = range / (bangRange.estimatedTime * 1000.0);
            this.impulse = range / (bangRange.estimatedTime * bangRange.estimatedTime * 500.0);
            this.acceleration = this.impulse;
        }

        // Set the timer to allow the bang-up to start off slowly
        this.startUpTimer.set( bangRange.slowStartTime );

        // Prepare the start script function if one exists
        this.fontSprite.scriptComponent.prepare( 'start', this.fontSprite );
    }

    //
    //  DESC: Do a fast bang
    //
    fastBang()
    {
        if( this.bangUp )
        {
            let acceleration = (this.targetValue - this.currentValue) / this.fastBangTime;

            // use the fast bang acceleration if the current one is less
            if( this.acceleration < acceleration )
                this.acceleration = acceleration;
        }
    }

    //
    //  DESC: Update the control
    //
    update()
    {
        super.update();

        if( this.bangUp )
        {
            let elapsedTime = _utilities_highresolutiontimer__WEBPACK_IMPORTED_MODULE_1__.highResTimer.elapsedTime;

            // Ramp up from start to finish
            if( this.bangRange.bangType === EBT_RAMP_UP )
            {
                this.currentValue += this.velocity * elapsedTime;

                if( this.startUpTimer.expired() )
                {
                    this.velocity += this.acceleration * elapsedTime;
                    this.acceleration += this.impulse * elapsedTime;
                }
                else
                {
                    this.velocity += this.acceleration * elapsedTime;
                }
            }
            // Linear bang up from the start
            else if( this.bangRange.bangType === EBT_LINEAR )
            {
                this.currentValue += this.velocity;

                if( this.startUpTimer.expired() )
                    this.velocity += this.acceleration * elapsedTime;
            }
            // combination of ramp up and linear
            else if( this.bangRange.bangType === EBT_HYBRID )
            {
                this.currentValue += this.velocity;

                if( this.startUpTimer.expired() )
                {
                    if( this.terminalVelocity > this.acceleration )
                    {
                        this.velocity += this.acceleration * elapsedTime;
                        this.acceleration += this.impulse * elapsedTime;
                    }
                    else
                    {
                        this.velocity += this.acceleration * elapsedTime;
                    }
                }
                else
                {
                    this.velocity += this.acceleration * elapsedTime;
                }
            }

            // Only update the meter if the value is different
            if( this.lastValue != this.currentValue )
            {
                this.lastValue = this.currentValue;

                // check if the bang up has finished
                if( this.currentValue > this.targetValue )
                {
                    this.currentValue = this.targetValue;
                    this.bangUp = false;

                    // Prepare the stop script function if one exists
                    this.fontSprite.scriptComponent.prepare( 'stop', this.fontSprite );
                }

                // Display the value in the meter
                this.displayValue();
            }
        }
    }

    //
    //  DESC: Display the value in the meter
    //
    displayValue()
    {
        // Display the new value
        this.fontSprite.visualComponent.createFontString( Math.trunc(this.currentValue).toString() );

        // Get the font size
        let size = this.fontSprite.visualComponent.getFontSize();

        // Check if the font string size is greater then what is allowed
        if( (size.w > this.maxFontStrSize.w) || (size.h > this.maxFontStrSize.h) )
        {
            let difW = this.maxFontStrSize.w / size.w;
            let difH = this.maxFontStrSize.h / size.h;

            // Is the difference less then the last size change
            if( (difW < this.bangScaleAdjustment.w) || (difH < this.bangScaleAdjustment.h) )
            {
                this.bangScaleAdjustment.set( difW, difH );

                let scaleX = this.fontSprite.scale.x;
                let scaleY = this.fontSprite.scale.y;
                if( difW < difH )
                {
                    scaleX = difW;
                    
                    if( this.scaleType !== EST_AXIS )
                        scaleY = difW;
                }
                else
                {
                    scaleY = difH;
                    
                    if( this.scaleType !== EST_AXIS )
                        scaleX = difH;
                }

                this.fontSprite.setScaleXYZ( scaleX, scaleY );
            }
        }
    }

    //
    //  DESC: Clear the meter
    //
    clear()
    {
        this.lastValue = this.currentValue = this.targetValue = 0;
        this.bangUp = false;
        
        if( !this.fontSprite.scriptComponent.prepare( 'clear', this.fontSprite ) )
            this.fontSprite.visualComponent.createFontString( this.currentValue.toString() );
    }
    
    //
    //  DESC: Is the meter banging
    //
    isBanging()
    {
        return this.bangUp;
    }
}


/***/ }),
/* 140 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Timer": () => (/* binding */ Timer)
/* harmony export */ });

// 
//  FILE NAME: timer.js
//  DESC:      timer class
//



class Timer
{
    constructor( interval = 0, startExpired = false )
    {
        // Expired time
        this.expiredTime = false;

        // time interval
        this.timeInterval = interval;

        // Disabled flag
        this.disabled = false;

        // Disabled return value.
        // This value allows a disabled timer to act as expired or not
        this.disableValue = false;
        
        if( startExpired )
            this.setExpired();
        else
            this.reset();
    }
    
    //
    //  DESC: Reset the timer to start over
    //
    reset()
    {
        this.expiredTime = this.timeInterval + performance.now();
        this.disabled = false;
    }

    //
    //  DESC: Set the time to have expired
    //
    setExpired()
    {
        this.expiredTime = performance.now();
    }

    //
    //  DESC: Set the timer interval
    //
    set( interval )
    {
        this.timeInterval = interval;
        this.reset();
    }

    //
    //  DESC: Has the timer expired?
    //
    expired( resetOnExpire )
    {
        // Has the timer been disabled
        if( this.disabled )
            return this.disableValue;

        let result = false;

        if( performance.now() > this.expiredTime )
        {
            result = true;

            if( resetOnExpire )
                this.reset();
        }

        return result;
    }

    //
    //  DESC: Disable this timer
    //
    disable( disabled )
    {
        this.disabled = disabled;
    }

    //
    //  DESC: Set the value returned by Expired when the timer is disabled
    //
    setDisableValue( disableValue )
    {
        this.disableValue = disableValue;
    }
}


/***/ }),
/* 141 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UIProgressBar": () => (/* binding */ UIProgressBar)
/* harmony export */ });
/* harmony import */ var _uicontrol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(129);
/* harmony import */ var _sprite_sprite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(37);
/* harmony import */ var _common_size__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony import */ var _common_point__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(14);
/* harmony import */ var _objectdatamanager_objectdatamanager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(112);
/* harmony import */ var _system_device__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9);
/* harmony import */ var _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(132);
/* harmony import */ var _common_defs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(6);

// 
//  FILE NAME: uiprogressbar.js
//  DESC:      Class for user interface progress bar
//











class UIProgressBar extends _uicontrol__WEBPACK_IMPORTED_MODULE_0__.UIControl
{
    constructor( group )
    {
        super( group );
        
        this.type = _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_6__.ECT_PROGRESS_BAR;
        
        // stencil mask sprite
        this.stencilMaskSprite;

        // current value of progress bar
        this.curValue = 0;

        // Minimum value
        this.minValue = 0;

        // Max value of progress bar
        this.maxValue = 1;

        // Sprite index to apply stencil mask to
        this.spriteApplyIndex = -1;

        // Orentation
        this.orentation = _common_defs__WEBPACK_IMPORTED_MODULE_7__.EO_HORIZONTAL;
        
        // alignment of this progress bar
        this.alignment = _common_defs__WEBPACK_IMPORTED_MODULE_7__.EHA_HORZ_LEFT;

        // progress bar size
        this.progressBarSize = new _common_size__WEBPACK_IMPORTED_MODULE_2__.Size;

        // progress bar pos
        this.progressBarPos = new _common_point__WEBPACK_IMPORTED_MODULE_3__.Point;
        
        // progress bar scale
        this.progressBarScale = new _common_point__WEBPACK_IMPORTED_MODULE_3__.Point;
    }
    
    //
    //  DESC: Load the control info from XML node
    //
    loadFromNode( xmlNode )
    {
        super.loadFromNode( xmlNode );

        // See if a range of values was specified
        let rangeNode = xmlNode.getElementsByTagName( 'range' );
        if( rangeNode.length )
        {
            let attr = rangeNode[0].getAttribute( 'cur' );
            if( attr )
                this.curValue = Number( attr );

            attr = rangeNode[0].getAttribute( 'min' );
            if( attr )
                this.minValue = Number( attr );

            attr = rangeNode[0].getAttribute( 'max' );
            if( attr )
                this.maxValue = Number( attr );
        }

        let orentNode = xmlNode.getElementsByTagName( "orentation" );
        if( orentNode.length )
        {
            let attr = orentNode[0].getAttribute("type");
            if( attr === 'vert' )
                this.orentation = _common_defs__WEBPACK_IMPORTED_MODULE_7__.EO_VERTICAL;

            attr = orentNode[0].getAttribute("alignment");
            if( attr )
            {
                if( this.orentation === _common_defs__WEBPACK_IMPORTED_MODULE_7__.EO_HORIZONTAL )
                {
                    if( attr === 'right' )
                        this.alignment = _common_defs__WEBPACK_IMPORTED_MODULE_7__.EHA_HORZ_RIGHT;

                    else if( attr === 'center' )
                        this.alignment = _common_defs__WEBPACK_IMPORTED_MODULE_7__.EHA_HORZ_CENTER;
                }
                else
                {
                    if( attr === 'bottom' )
                        this.alignment = _common_defs__WEBPACK_IMPORTED_MODULE_7__.EVA_VERT_BOTTOM;

                    else if( attr === 'center' )
                        this.alignment = _common_defs__WEBPACK_IMPORTED_MODULE_7__.EVA_VERT_CENTER;
                }
            }
        }

        // Calculate the progress bar size and position
        this.setSizePos();
    }

    //
    //  DESC: Load the control specific info from XML node
    //
    loadControlFromNode( controlNode )
    {
        super.loadControlFromNode( controlNode );

        // Get the stencil mask node
        let stencilMaskNode = controlNode.getElementsByTagName( "stencilMask" );
        if( stencilMaskNode.length )
        {
            let stencilMaskSprite = stencilMaskNode[0].getAttribute( "objectName" );

            this.spriteApplyIndex = Number(stencilMaskNode[0].getAttribute( "spriteIndex" ));
            
            this.initSizePosScale( this.spriteApplyIndex, stencilMaskSprite );
        }
    }

    // 
    //  DESC: Set progress bar max
    //
    setProgressBarMax( max )
    {
        this.maxValue = max;
        this.setSizePos();
    }

    // 
    //  DESC: Init the progress bar size, pos and scale
    //
    initSizePosScale( spriteApplyIndex, stencilMaskSprite = null )
    {
        this.spriteApplyIndex = spriteApplyIndex;
        
        if( stencilMaskSprite )
        {
            this.stencilMaskSprite = new _sprite_sprite__WEBPACK_IMPORTED_MODULE_1__.Sprite( _objectdatamanager_objectdatamanager__WEBPACK_IMPORTED_MODULE_4__.objectDataManager.getData( this.group, stencilMaskSprite ) );
            
            // Get the size
            this.progressBarSize.copy( this.stencilMaskSprite.objData.size );

            // Get the initial position
            this.progressBarPos.copy( this.stencilMaskSprite.pos );

            // Get the initial scale
            this.progressBarScale.copy( this.stencilMaskSprite.scale );
        }
        else
        {
            // Get the size
            this.progressBarSize.copy( this.spriteAry[this.spriteApplyIndex].objData.size );

            // Get the initial position
            this.progressBarPos.copy( this.spriteAry[this.spriteApplyIndex].pos );

            // Get the initial scale
            this.progressBarScale.copy( this.spriteAry[this.spriteApplyIndex].scale );
        }
    }

    // 
    //  DESC: Set the current value
    //
    setCurrentValue( cur )
    {
        this.curValue = cur;
        
        this.setSizePos();
    }
    
    // 
    //  DESC: Inc the current value
    //
    incCurrentValue()
    {
        ++this.curValue;
        
        this.setSizePos();
    }

    //
    //  DESC: Transform the control
    //
    transform( object )
    {
        super.transform( object );

        if( this.stencilMaskSprite )
            this.stencilMaskSprite.transform( this );
    }
    
    // 
    //  DESC: Transform the collision
    //  NOTE: This object has no collision
    //
    transformCollision()
    {
    }

    //
    //  DESC: do the render
    //
    render( camera )
    {
        let gl = _system_device__WEBPACK_IMPORTED_MODULE_5__.device.gl;
        
        if( this.stencilMaskSprite )
        {
            for( let i  = 0; i < this.spriteAry.length; ++i )
            {
                if( i === this.spriteApplyIndex )
                {
                    // Disable rendering to the color buffer
                    // NOTE: Using gl.FALSE or gl.TRUE causes a problem with this function call
                    gl.colorMask( false, false, false, false );

                    // Disable rendering to the depth mask
                    gl.depthMask( false );

                    // Start using the stencil
                    gl.enable( gl.STENCIL_TEST );

                    gl.stencilFunc( gl.ALWAYS, 0x1, 0x1 );
                    gl.stencilOp( gl.REPLACE, gl.REPLACE, gl.REPLACE );
        

                    this.stencilMaskSprite.render( camera );
                    
                    
                    // Re-enable color
                    // NOTE: Using gl.FALSE or gl.TRUE causes a problem with this function call
                    gl.colorMask( true, true, true, true );

                    // Where a 1 was not rendered
                    gl.stencilFunc( gl.EQUAL, 0x1, 0x1 );

                    // Keep the pixel
                    gl.stencilOp( gl.KEEP, gl.KEEP, gl.KEEP );

                    // Enable rendering to the depth mask
                    gl.depthMask( true );


                    this.spriteAry[i].render( this.matrix );


                    // Finished using stencil
                    gl.disable( gl.STENCIL_TEST );
                }
                else
                    this.spriteAry[i].render( camera );
            }
        }
        else
        {
            super.render( camera );
        }
    }

    //
    //  DESC: Calculate the progress bar size and position
    //
    setSizePos()
    {
        let scaleX = this.progressBarScale.x;
        let scaleY = this.progressBarScale.y;
        let posX = this.progressBarPos.x;
        let posY = this.progressBarPos.y;

        // Calculate the new scale for the progress bar
        let scaler = (this.curValue - this.minValue) / (this.maxValue - this.minValue);

        if( this.orentation == _common_defs__WEBPACK_IMPORTED_MODULE_7__.EO_HORIZONTAL )
        {
            scaleX = this.progressBarScale.x * scaler;
            
            let offset = this.progressBarSize.w * scaler;

            if( this.alignment == _common_defs__WEBPACK_IMPORTED_MODULE_7__.EHA_HORZ_LEFT )
                posX -= (this.progressBarSize.w - offset) / 2;

            else if( this.alignment.horz == _common_defs__WEBPACK_IMPORTED_MODULE_7__.EHA_HORZ_RIGHT )
                posX += (this.progressBarSize.w - offset) / 2;
        }
        else
        {
            scaleY = this.progressBarScale.y * scaler;
            
            let offset = this.progressBarSize.h * scaler;

            if( this.alignment === _common_defs__WEBPACK_IMPORTED_MODULE_7__.EVA_VERT_TOP )
                posY += (this.progressBarSize.h - offset) / 2;

            else if( this.alignment === _common_defs__WEBPACK_IMPORTED_MODULE_7__.EVA_VERT_BOTTOM )
                posY -= (this.progressBarSize.h - offset) / 2;
        }

        if( this.stencilMaskSprite )
        {
            this.stencilMaskSprite.setScaleXYZ( scaleX, scaleY, 1 );
            this.stencilMaskSprite.setPosXYZ( posX, posY );
        }
        else
        {
            this.spriteAry[this.spriteApplyIndex].setScaleXYZ( scaleX, scaleY, 1 );
            this.spriteAry[this.spriteApplyIndex].setPosXYZ( posX, posY, 0 );
        }
    }
}


/***/ }),
/* 142 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MenuTree": () => (/* binding */ MenuTree)
/* harmony export */ });
/* harmony import */ var _managers_eventmanager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);
/* harmony import */ var _common_genericevent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(31);
/* harmony import */ var _gui_menudefs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(36);
// 
//  FILE NAME: menutree.js
//  DESC:      Class that hold a tree of menus
//






class MenuTree
{
    constructor( name, menuMap, rootMenu, defaultMenu, interfaceMenu = false )
    {
        // Name of the tree
        this.name = name;

        // Map of the menus
        this.menuMap = menuMap;

        // root menu
        this.rootMenu = menuMap.get( rootMenu );

        // default menu
        this.defaultMenu = menuMap.get( defaultMenu );

        // Is interface menu?
        this.interfaceMenu = interfaceMenu;

        // Name of menu we are transitioning to
        this.toMenu = '';

        // Array of the path taken through the menu
        this.menuPathAry = [];

        // menu tree state
        this.state = _gui_menudefs__WEBPACK_IMPORTED_MODULE_2__.EMTS_IDLE;
    }
    
    // 
    //  DESC: Init the tree for use
    //
    init()
    {
        this.menuPathAry = [];

        if( this.rootMenu !== undefined )
        {
            // If we have a root menu, add it to the path
            this.menuPathAry.push( this.rootMenu );

            this.rootMenu.activateMenu();
        }
    }
    
    // 
    //  DESC: Set the default menu
    //
    setDefaultMenu( menuStr )
    {
        let menu = this.menuMap.get( menuStr );
        if( menu !== undefined )
            this.defaultMenu = menu;
        else
            throw new Error( `Menu being set is missing (${menuStr})!` );
    }
    
    // 
    //  DESC: Set the root menu
    //
    setRootMenu( menuStr )
    {
        let menu = this.menuMap.get( menuStr );
        if( menu !== undefined )
            this.rootMenu = menu;
        else
            throw new Error( `Menu being set is missing (${menuStr})!` );
    }
    
    // 
    //  DESC: Is the default menu
    //
    isDefaultMenu( menuStr )
    {
        if( this.defaultMenu && this.defaultMenu.name === menuStr )
            return true
        
        return false;
    }
    
    // 
    //  DESC: Is the root menu
    //
    isRootMenu( menuStr )
    {
        if( this.rootMenu && this.rootMenu.name === menuStr )
            return true
        
        return false;
    }

    // 
    //  DESC: Update the menu tree
    //
    update()
    {
        if( this.menuPathAry.length )
            this.menuPathAry[this.menuPathAry.length-1].update();
    }
    
    // 
    //  DESC: Transform the menu tree
    //
    transform()
    {
        if( this.menuPathAry.length )
            this.menuPathAry[this.menuPathAry.length-1].transform();
    }
    
    // 
    //  DESC: do the render
    //
    render( camera )
    {
        if( this.menuPathAry.length )
            this.menuPathAry[this.menuPathAry.length-1].render( camera );
    }
    
    // 
    //  DESC: Is a menu active?
    //
    isActive()
    {
        return (this.menuPathAry.length > 0);

    }
    
    // 
    //  DESC: Does this tee have a root menu
    //
    hasRootMenu()
    {
        return (this.rootMenu != undefined);
    }
    
    // 
    //  DESC: Handle events
    //
    handleEvent( event )
    {
        // Trap only controller events to check for actions
        if( !this.interfaceMenu )
        {
            if( this.menuPathAry.length )
                this.menuPathAry[this.menuPathAry.length-1].handleEvent( event );

            if( event instanceof _common_genericevent__WEBPACK_IMPORTED_MODULE_1__.GenericEvent )
            {
                if( this.state === _gui_menudefs__WEBPACK_IMPORTED_MODULE_2__.EMTS_IDLE )
                {
                    if( event.type === _gui_menudefs__WEBPACK_IMPORTED_MODULE_2__.EGE_MENU_ESCAPE_ACTION )
                    {
                        this.onEscape( event );
                    }
                    else if( event.type === _gui_menudefs__WEBPACK_IMPORTED_MODULE_2__.EGE_MENU_TOGGLE_ACTION )
                    {
                        this.onToggle( event );
                    }
                    else if( event.type === _gui_menudefs__WEBPACK_IMPORTED_MODULE_2__.EGE_MENU_BACK_ACTION )
                    {
                        this.onBack( event );
                    }
                    else if( event.type === _gui_menudefs__WEBPACK_IMPORTED_MODULE_2__.EGE_MENU_TO_TREE )
                    {
                        this.onToTree( event );
                    }
                    else if( event.type === _gui_menudefs__WEBPACK_IMPORTED_MODULE_2__.EGE_MENU_TO_MENU )
                    {
                        this.onToMenu( event );
                    }
                }
                else if( event.type === _gui_menudefs__WEBPACK_IMPORTED_MODULE_2__.EGE_MENU_TRANS_IN )
                {
                    this.onTransIn( event );
                }
                else if( event.type === _gui_menudefs__WEBPACK_IMPORTED_MODULE_2__.EGE_MENU_TRANS_OUT )
                {
                    this.onTransOut( event );
                }
            }
        }
        else
        {
            // Don't process menu specific messages for an interface menu
            if( (event instanceof _common_genericevent__WEBPACK_IMPORTED_MODULE_1__.GenericEvent) && event.type <= _gui_menudefs__WEBPACK_IMPORTED_MODULE_2__.EGE_MENU_GAME_STATE_CHANGE )
                return;
                
            if( this.menuPathAry.length )
                this.menuPathAry[this.menuPathAry.length-1].handleEvent( event );
        }
    }
    
    // 
    //  DESC: Transition the menu
    //
    transitionMenu()
    {
        // If the path array is empty, transition to the default menu
        if( this.menuPathAry.length === 0 )
        {
            // Make sure the menu exists
            if( this.defaultMenu === undefined )
                throw new Error( 'Default menu does not exist!' );

            // Add the default menu to the path
            this.menuPathAry.push( this.defaultMenu );

            // Get the name of the menu we are transitioning to
            // This is also used as a flag to indicate moving up the menu tree
            this.toMenu = this.defaultMenu.name;

            // Set the state as "active" so that input messages are ignored
            this.state = _gui_menudefs__WEBPACK_IMPORTED_MODULE_2__.EMTS_ACTIVE;

            // Start the transition in
            _managers_eventmanager__WEBPACK_IMPORTED_MODULE_0__.eventManager.dispatchEvent( _gui_menudefs__WEBPACK_IMPORTED_MODULE_2__.EGE_MENU_TRANS_IN, _gui_menudefs__WEBPACK_IMPORTED_MODULE_2__.ETC_BEGIN );
        }
        else
        {
            // If this isn't the root menu, start the transition out
            if( this.menuPathAry[this.menuPathAry.length-1] != this.rootMenu )
            {
                // Set the state as "active" so that input messages are ignored
                this.state = _gui_menudefs__WEBPACK_IMPORTED_MODULE_2__.EMTS_ACTIVE;

                // Start the transition out
                _managers_eventmanager__WEBPACK_IMPORTED_MODULE_0__.eventManager.dispatchEvent( _gui_menudefs__WEBPACK_IMPORTED_MODULE_2__.EGE_MENU_TRANS_OUT, _gui_menudefs__WEBPACK_IMPORTED_MODULE_2__.ETC_BEGIN );
            }
        }
    }
    
    // 
    //  DESC: Handle OnEscape message
    //
    onEscape( event )
    {
        let nameStr = event.arg[0];
        if( this.menuPathAry.length || ((nameStr !== null) && (nameStr === this.name)))
        {
            this.transitionMenu();
        }
    }
    
    // 
    //  DESC: Handle OnToggle message
    //
    onToggle( event )
    {
        let nameStr = event.arg[0];
        if( this.menuPathAry.length || ((nameStr !== null) && (nameStr === this.name)))
        {
            // Toggle "on" only works when there is no root menu
            if( this.rootMenu === undefined )
            {
                this.transitionMenu();

                // For toggle, clear out the path array except for the current menu
                // The current menu will then be used for the transitions out
                if( this.menuPathAry.length > 1 )
                {
                    let curMenu = this.menuPathAry[this.menuPathAry.length-1];
                    this.menuPathAry = [];
                    this.menuPathAry.push( curMenu );
                }
            }
            else
            {
                if( this.menuPathAry.length > 1 )
                    this.transitionMenu();

                // For toggle, clear out the path array except for the current and root menu
                // The current menu will then be used for the transitions out
                if( this.menuPathAry.length > 2 )
                {
                    let curMenu = this.menuPathAry[this.menuPathAry.length-1];
                    this.menuPathAry = [];
                    this.menuPathAry.push( this.rootMenu );
                    this.menuPathAry.push( curMenu );
                }
            }
        }
    }
    
    // 
    //  DESC: Handle OnBack message
    //
    onBack( /*event*/ )
    {
        // Going back one require there to be a active menu that is not root
        if( this.menuPathAry.length && (this.menuPathAry[this.menuPathAry.length-1] != this.rootMenu) )
        {
            this.transitionMenu();
        }
    }
    
    // 
    //  DESC: Handle OnToTree message
    //
    onToTree( event )
    {
        let nameStr = event.arg[0];
        if( (nameStr !== null) && (nameStr === this.name) )
        {
            // Only works when there is no root menu
            if( this.rootMenu === undefined )
                this.transitionMenu();
        }
    }
    
    // 
    //  DESC: Handle OnToMenu message
    //
    onToMenu( event )
    {
        // Going to a menu require there to be a active menu
        // and the calling control is on a menu on this tree
        if( this.menuPathAry.length && 
            (this.menuPathAry[this.menuPathAry.length-1].getActiveControl() == event.arg[1]) )
        {
            // Set the state as "active" so that input messages are ignored
            this.state = _gui_menudefs__WEBPACK_IMPORTED_MODULE_2__.EMTS_ACTIVE;

            // Get the name of the menu we are transitioning to
            // This is also used as a flag to indicate moving deaper into the menu tree
            this.toMenu = event.arg[0];

            // Do a sanity check to make sure the menu exists
            if( this.menuMap.get(this.toMenu) === undefined )
                throw new Error( `Menu does not exist! (${this.toMenu}).` );

            // Start the transition out
            _managers_eventmanager__WEBPACK_IMPORTED_MODULE_0__.eventManager.dispatchEvent( _gui_menudefs__WEBPACK_IMPORTED_MODULE_2__.EGE_MENU_TRANS_OUT, _gui_menudefs__WEBPACK_IMPORTED_MODULE_2__.ETC_BEGIN );
        }
    }
    
    // 
    //  DESC: Handle OnTransOut message
    //
    onTransOut( event )
    {
        if( event.arg[0] === _gui_menudefs__WEBPACK_IMPORTED_MODULE_2__.ETC_END )
        {
            if( this.toMenu.length )
            {
                this.menuPathAry.push( this.menuMap.get(this.toMenu) );
                _managers_eventmanager__WEBPACK_IMPORTED_MODULE_0__.eventManager.dispatchEvent( _gui_menudefs__WEBPACK_IMPORTED_MODULE_2__.EGE_MENU_TRANS_IN, _gui_menudefs__WEBPACK_IMPORTED_MODULE_2__.ETC_BEGIN );
            }
            else if( this.menuPathAry.length && (this.menuPathAry[this.menuPathAry.length-1] !== this.rootMenu) )
            {
                // Pop it off the array because this menu is done
                let menu = this.menuPathAry.pop();
                
                // Do a full reset on all the controls
                menu.reset();

                if( this.menuPathAry.length )
                    _managers_eventmanager__WEBPACK_IMPORTED_MODULE_0__.eventManager.dispatchEvent( _gui_menudefs__WEBPACK_IMPORTED_MODULE_2__.EGE_MENU_TRANS_IN, _gui_menudefs__WEBPACK_IMPORTED_MODULE_2__.ETC_BEGIN );
            }

            // Normally, after one menu transitions out, the next menu transitions in
            // Only set the idle state if this transition out is final
            if( this.menuPathAry.length === 0 )
                this.state = _gui_menudefs__WEBPACK_IMPORTED_MODULE_2__.EMTS_IDLE;
        }
    }
    
    // 
    //  DESC: Handle OnTransIn message
    //
    onTransIn( event )
    {
        if( event.arg[0] === _gui_menudefs__WEBPACK_IMPORTED_MODULE_2__.ETC_END )
        {
            // m_toMenu is also used as a flag to indicate moving up the menu tree
            // When moving up the menu tree, activate the first control on the menu
            // When backing out of the menu tree, activate the last control used
            _managers_eventmanager__WEBPACK_IMPORTED_MODULE_0__.eventManager.dispatchEvent( _gui_menudefs__WEBPACK_IMPORTED_MODULE_2__.EGE_MENU_SET_ACTIVE_CONTROL, 
                (this.toMenu.length === 0) ? _gui_menudefs__WEBPACK_IMPORTED_MODULE_2__.EAC_LAST_ACTIVE_CONTROL : _gui_menudefs__WEBPACK_IMPORTED_MODULE_2__.EAC_FIRST_ACTIVE_CONTROL );

            // Set to idle to allow for input messages to come through
            this.state = _gui_menudefs__WEBPACK_IMPORTED_MODULE_2__.EMTS_IDLE;

            // Clear in the event we start backing out of the menu tree
            this.toMenu = '';
        }
    }
    
    // 
    //  DESC: Get the active menu
    //
    getActiveMenu()
    {
        if( this.menuPathAry.length === 0 )
            throw new Error( 'There is no active menu!' );

        return this.menuPathAry[this.menuPathAry.length-1];
    }
    
    // 
    //  DESC: Get the scroll param data
    //
    getScrollParam( msg )
    {
        if( this.menuPathAry.length === 0 )
            throw new Error( 'There is no active menu!' );

        return this.menuPathAry[this.menuPathAry.length-1].getScrollParam( msg );
    }
    
    // 
    //  DESC: Is a menu item active
    //
    isMenuItemActive()
    {
        if( this.isActive() )
        {
            if( this.getActiveMenu().getActiveControl() !== null )
                return false;
        }

        return false;
    }
    
}


/***/ }),
/* 143 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TestArenaState": () => (/* binding */ TestArenaState)
/* harmony export */ });
/* harmony import */ var _gamestate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(144);
/* harmony import */ var _library_managers_shadermanager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40);
/* harmony import */ var _library_script_scriptmanager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17);
/* harmony import */ var _library_objectdatamanager_objectdatamanager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(112);
/* harmony import */ var _library_managers_cameramanager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(10);
/* harmony import */ var _library_physics_physicsworldmanager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(54);
/* harmony import */ var _library_strategy_strategymanager__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(147);
/* harmony import */ var _library_strategy_strategyloader__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(148);
/* harmony import */ var _library_utilities_highresolutiontimer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(56);
/* harmony import */ var _library_script_scriptcomponent__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(16);
/* harmony import */ var _library_managers_spritesheetmanager__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(116);
/* harmony import */ var _library_utilities_assetholder__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(33);
/* harmony import */ var _library_utilities_genfunc__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(26);
/* harmony import */ var _scripts_spaceshipscripts__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(162);
/* harmony import */ var _statedefs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(146);
/* harmony import */ var raw_loader_data_objects_2d_objectDataList_dataListTable_lst__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(164);
/* harmony import */ var raw_loader_data_objects_strategy_strageyListTable_lst__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(165);
/* harmony import */ var raw_loader_data_objects_2d_physics_physicsListTable_lst__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(166);
/* harmony import */ var raw_loader_data_objects_camera_lst__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(167);
/* harmony import */ var _data_shaders_shader_json__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(168);
/* harmony import */ var raw_loader_data_objects_strategy_strategy_loader__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(169);

//
//  FILE NAME: testarenastate.js
//  DESC:      test arena state class
//






//import { eventManager } from '../../../library/managers/eventmanager';
//import { fontManager } from '../../../library/managers/fontmanager';

//import { actionManager } from '../../../library/managers/actionmanager';
//import { menuManager } from '../../../library/gui/menumanager';

//import { signalManager } from '../../../library/managers/signalmanager';
//import { soundManager } from '../../../library/sound/soundmanager';







//import { GenericEvent } from '../../../library/common/genericevent';

//import * as titleScreenState from '../state/titlescreenstate';
//import * as utilScripts from '../scripts/utilityscripts';
//import * as stateScripts from '../scripts/statescripts';
//import * as menuScripts from '../scripts/menuscripts';



// Load data from bundle as string

//import dataListTable3D from 'raw-loader!../../data/objects/3d/objectDataList/dataListTable.lst';

//import soundManagerListTable from 'raw-loader!../../data/sound/soundListTable.lst';

//import menuManagerListTable from 'raw-loader!../../data/objects/2d/menu/menuListTable.lst';
//import fontManagerListTable from 'raw-loader!../../data/textures/fonts/font.lst';


//import actionManagerJson from '../../data/settings/controllerMapping.json';
//import menuActionLst from 'raw-loader!../../data/objects/2d/menu/menu_action.list';


//const STARTUP_ASSET_COUNT = 80,
//      MIN_LOAD_TIME = 1500;

class TestArenaState extends _gamestate__WEBPACK_IMPORTED_MODULE_0__.GameState
{
    constructor( gameLoopCallback )
    {
        super( _statedefs__WEBPACK_IMPORTED_MODULE_14__.EGS_STARTUP, _statedefs__WEBPACK_IMPORTED_MODULE_14__.EGS_TITLE_SCREEN, gameLoopCallback );

        // Load the list tables
        _library_objectdatamanager_objectdatamanager__WEBPACK_IMPORTED_MODULE_3__.objectDataManager.loadListTableFromNode( _library_utilities_genfunc__WEBPACK_IMPORTED_MODULE_12__.stringLoadXML( raw_loader_data_objects_2d_objectDataList_dataListTable_lst__WEBPACK_IMPORTED_MODULE_15__.default ) );
        //objectDataManager.loadListTableFromNode( genFunc.stringLoadXML( dataListTable3D ) );
        _library_strategy_strategymanager__WEBPACK_IMPORTED_MODULE_6__.strategyManager.loadListTableFromNode( _library_utilities_genfunc__WEBPACK_IMPORTED_MODULE_12__.stringLoadXML( raw_loader_data_objects_strategy_strageyListTable_lst__WEBPACK_IMPORTED_MODULE_16__.default ) );
        //soundManager.loadListTableFromNode( genFunc.stringLoadXML( soundManagerListTable ) );
        _library_physics_physicsworldmanager__WEBPACK_IMPORTED_MODULE_5__.physicsWorldManager.loadListTableFromNode( _library_utilities_genfunc__WEBPACK_IMPORTED_MODULE_12__.stringLoadXML( raw_loader_data_objects_2d_physics_physicsListTable_lst__WEBPACK_IMPORTED_MODULE_17__.default ) );
        //menuManager.loadListTableFromNode( genFunc.stringLoadXML( menuManagerListTable ) );
        _library_managers_cameramanager__WEBPACK_IMPORTED_MODULE_4__.cameraManager.loadFromNode( _library_utilities_genfunc__WEBPACK_IMPORTED_MODULE_12__.stringLoadXML( raw_loader_data_objects_camera_lst__WEBPACK_IMPORTED_MODULE_18__.default ) );
        //actionManager.load( actionManagerJson );
        //menuManager.loadMenuActionFromNode( genFunc.stringLoadXML( menuActionLst ) );

        // Load the scripts
        _scripts_spaceshipscripts__WEBPACK_IMPORTED_MODULE_13__.loadScripts();
        //utilScripts.loadScripts();
        //stateScripts.loadScripts();
        //menuScripts.loadScripts();
                
        // Set the default camera
        // NOTE: Can only call this after Camera Manager has been loaded
        //menuManager.setDefaultCamera();

        // Create the script component and add a script
        //this.scriptComponent = new ScriptComponent;
        //this.scriptComponent.set( scriptManager.get('ScreenFade')( 0, 1, 500 ) );

        // Load assets for the test arena
        this.load();
    }

    //
    //  DESC: Load the assets
    //
    load()
    {
        let groupAry = ['(space_ship)','(main)'];

        // Set the timer to see how long the load takes
        _library_utilities_highresolutiontimer__WEBPACK_IMPORTED_MODULE_8__.highResTimer.timerStart();

        Promise.all([

            // Load the shaders
            _library_managers_shadermanager__WEBPACK_IMPORTED_MODULE_1__.shaderManager.loadFromObj( _data_shaders_shader_json__WEBPACK_IMPORTED_MODULE_19__ ),

            // Load the object data
            _library_objectdatamanager_objectdatamanager__WEBPACK_IMPORTED_MODULE_3__.objectDataManager.loadGroup( groupAry )

        ])
        // Create and load all the actor strategies.
        .then(() => _library_strategy_strategyloader__WEBPACK_IMPORTED_MODULE_7__.strategyLoader.load( _library_utilities_genfunc__WEBPACK_IMPORTED_MODULE_12__.stringLoadXML( raw_loader_data_objects_strategy_strategy_loader__WEBPACK_IMPORTED_MODULE_20__.default ) ))

        // Clean up the temporary files
        .then(() =>
        {
            _library_utilities_assetholder__WEBPACK_IMPORTED_MODULE_11__.assetHolder.deleteGroup( groupAry );
            _library_managers_spritesheetmanager__WEBPACK_IMPORTED_MODULE_10__.spriteSheetManager.deleteGroup( groupAry );
        })

        // Last thing to do is call the load complete function
        .then(() => this.loadComplete() );
    }

    //
    //  DESC: Load is complete. Start the game loop which will fade in the screen
    //
    loadComplete()
    {
        _library_strategy_strategymanager__WEBPACK_IMPORTED_MODULE_6__.strategyManager.activateStrategy('_space_ship_');
        _library_strategy_strategymanager__WEBPACK_IMPORTED_MODULE_6__.strategyManager.activateStrategy('_main_');

        // Reset the elapsed time before entering the render loop
        _library_utilities_highresolutiontimer__WEBPACK_IMPORTED_MODULE_8__.highResTimer.calcElapsedTime();

        // Start the game loop
        requestAnimationFrame( this.callback );
    }

    //
    //  DESC: handle events
    //
    handleEvent( event )
    {
        /*if( event instanceof GenericEvent )
        {
            if( event.type === stateDefs.ESE_FADE_IN_COMPLETE )
            {
                this.assetLoad();
            }
            else if( event.type === stateDefs.ESE_FADE_OUT_COMPLETE )
            {
                this.stateChange = true;
            }
            else if( event.type === stateDefs.ESE_ASSET_LOAD_COMPLETE )
            {
                let loadTime = highResTimer.timerStop();

                // If the load was too fast, do a timeout of the difference before fading out
                if( loadTime > MIN_LOAD_TIME )
                    this.scriptComponent.set( scriptManager.get('ScreenFade')( 1, 0, 500 ) );
                else
                    setTimeout( () => this.scriptComponent.set( scriptManager.get('ScreenFade')( 1, 0, 500 ) ), MIN_LOAD_TIME - loadTime );
                
                // Disconnect to the load signal
                signalManager.clear_loadComplete();

                console.log('StartUp State load complete!: ' + this.progressBar.curValue);
            }
        }*/
    }

    //
    //  DESC: Update objects that require them
    //
    update()
    {
        //this.scriptComponent.update();
        _library_strategy_strategymanager__WEBPACK_IMPORTED_MODULE_6__.strategyManager.update();
    }
    
    // 
    //  DESC: Transform the game objects
    //
    transform()
    {
        _library_strategy_strategymanager__WEBPACK_IMPORTED_MODULE_6__.strategyManager.transform();
    }

    //
    //  DESC: Render of game content
    //
    render()
    {
        _library_strategy_strategymanager__WEBPACK_IMPORTED_MODULE_6__.strategyManager.render();
    }

    //
    //  DESC: Clean up after the startup state
    //
    cleanUp()
    {
        // Only delete the strategy(s) used in this state. Don't use clear().
        //strategyManager.deleteStrategy( ['_startup_'] );

        // Free the state assets from the video memory
        //objectDataManager.freeGroup( ['(startup)'] );
    }
}


/***/ }),
/* 144 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GameState": () => (/* binding */ GameState)
/* harmony export */ });
/* harmony import */ var _statemessage__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(145);
/* harmony import */ var _statedefs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(146);

// 
//  FILE NAME: gamestate.js
//  DESC:      game state base class
//






class GameState
{
    constructor( gameState, nextState, callback )
    {
        this.stateChange = false;
        this.gameState = gameState;
        this.nextState = nextState;
        this.callback = callback;
        
        // Message to send to next state
        this.stateMessage = new _statemessage__WEBPACK_IMPORTED_MODULE_0__.StateMessage;
    }
    
    cleanUp()
    {
        // Empty function to be overwritten
    }
    
    handleEvent( event )
    {
        // Empty function to be overwritten
    }
    
    doStateChange()
    {
        return this.stateChange;
    }
    
    physics()
    {
        // Empty function to be overwritten
    }
    
    update()
    {
        // Empty function to be overwritten
    }
    
    transform()
    {
        // Empty function to be overwritten
    }
    
    render()
    {
        // Empty function to be overwritten
    }

    // 
    //  DESC: Get the load state enum
    //
    getGameState( gameStateStr )
    {
        if( gameStateStr === 'title_screen_state' )
            return _statedefs__WEBPACK_IMPORTED_MODULE_1__.EGS_TITLE_SCREEN;
        
        else if( gameStateStr === 'level_1_state' )
            return _statedefs__WEBPACK_IMPORTED_MODULE_1__.EGS_LEVEL_1;
        
        throw new Error( `State does not exist!. (${gameStateStr})` );
    }
    
    // 
    //  DESC: Get the load state str
    //
    getStateStr( gameState )
    {
        if( gameState === _statedefs__WEBPACK_IMPORTED_MODULE_1__.EGS_TITLE_SCREEN )
            return 'title_screen_state';
        
        else if( gameState === _statedefs__WEBPACK_IMPORTED_MODULE_1__.EGS_LEVEL_1 )
            return 'level_1_state';
        
        throw new Error( `State does not exist!. (${gameState})` );
    }
}


/***/ }),
/* 145 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StateMessage": () => (/* binding */ StateMessage)
/* harmony export */ });

// 
//  FILE NAME: statemessage.js
//  DESC:      This class is custom per game project
//



class StateMessage
{
    constructor()
    {
        this.loadState = 0;
        this.unloadState = 0;
    }
    
    setMsg( loadState, unloadState )
    {
        this.loadState = loadState;
        this.unloadState = unloadState;
    }
}


/***/ }),
/* 146 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EGS_NULL": () => (/* binding */ EGS_NULL),
/* harmony export */   "EGS_STARTUP": () => (/* binding */ EGS_STARTUP),
/* harmony export */   "EGS_TITLE_SCREEN": () => (/* binding */ EGS_TITLE_SCREEN),
/* harmony export */   "EGS_GAME_LOAD": () => (/* binding */ EGS_GAME_LOAD),
/* harmony export */   "EGS_LEVEL_1": () => (/* binding */ EGS_LEVEL_1),
/* harmony export */   "ESE_STATE_EVENTS": () => (/* binding */ ESE_STATE_EVENTS),
/* harmony export */   "ESE_FADE_IN_COMPLETE": () => (/* binding */ ESE_FADE_IN_COMPLETE),
/* harmony export */   "ESE_FADE_OUT_COMPLETE": () => (/* binding */ ESE_FADE_OUT_COMPLETE),
/* harmony export */   "ESE_ASSET_LOAD_COMPLETE": () => (/* binding */ ESE_ASSET_LOAD_COMPLETE)
/* harmony export */ });

// 
//  FILE NAME: statedefs.js
//  DESC:      state specific defines
//


     
// These states are custom per game project
// EGameState
const EGS_NULL         = 0,
             EGS_STARTUP      = 1,
             EGS_TITLE_SCREEN = 2,
             EGS_GAME_LOAD    = 3,
             EGS_LEVEL_1      = 4;
    
// EStateEvent
const ESE_STATE_EVENTS         = 1000,
             ESE_FADE_IN_COMPLETE     = 1001,
             ESE_FADE_OUT_COMPLETE    = 1002,
             ESE_ASSET_LOAD_COMPLETE  = 1003;


/***/ }),
/* 147 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "strategyManager": () => (/* binding */ strategyManager)
/* harmony export */ });
/* harmony import */ var _managers_managerbase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(25);

// 
//  FILE NAME: strategymanager.js
//  DESC:      Sprite strategy manager singleton
//





class StrategyManager extends _managers_managerbase__WEBPACK_IMPORTED_MODULE_0__.ManagerBase
{
    constructor()
    {
        super();
        
        // Map of unique strategy references
        this.strategyMap = new Map;
        
        // An array of active strategy references
        this.strategyAry = [];
    }
    
    //
    //  DESC: Add strategy which will load it's data from XML node
    //
    addStrategy( strategyId, strategy )
    {
        // Check for duplicate Id's
        if( this.strategyMap.has( strategyId ) )
            throw new Error( `Duplicate strategy id (${strategyId})!` );
        
        // Add the strategy to the map
        this.strategyMap.set( strategyId, strategy );
        
        // Load all the xml's
        // See if there is any files associated with the strategy id in the list table
        // NOTE: Will return an empty strategy if a file is not defined. Will do an 
        // object data search to create a node/sprite. Assumes simple node/sprite only
        return super.load( strategyId, false );
    }
    
    //
    //  DESC: Load strategy data from an xml node
    //
    loadFromNode( strategyId, node, filePath )
    {
        let strategy = this.strategyMap.get( strategyId );
        
        strategy.loadFromNode( node, filePath );
    }
    
    //
    //  DESC: activate strategy
    //
    activateStrategy( strategyId )
    {
        let strategy = this.strategyMap.get( strategyId );
        if( strategy )
        {
            let index = this.strategyAry.findIndex( (obj) => obj === strategy );
            if( index === -1 )
                this.strategyAry.push( strategy );
            else
                console.log( `Strategy is already active (${strategyId})!` );
        }
        else
            throw new Error( `Strategy id can't be found (${strategyId})!` );
        
        return strategy;
    }
    
    //
    //  DESC: deactivate strategy
    //
    deactivateStrategy( strategyId )
    {
        let strategy = this.strategyMap.get( strategyId );
        if( strategy )
        {
            let index = this.strategyAry.findIndex( (obj) => obj === strategy );
            if( index !== -1 )
                this.strategyAry.splice( index, 1 );
            else
                console.log( `Strategy is not active (${strategyId})!` );
        }
        else
            console.log( `Strategy id can't be found to deactivate (${strategyId})!` );
        
        return strategy;
    }
    
    //
    //  DESC: delete strategy
    //
    deleteStrategy( strategyGrp )
    {
        for( let i = 0; i < strategyGrp.length; ++i )
        {
            // First deactivate the strategy
            this.deactivateStrategy( strategyGrp[i] );

            // Cleanup and delete the strategy
            let strategy = this.strategyMap.get( strategyGrp[i] );
            if( strategy )
            {
                strategy.cleanUp();
                this.strategyMap.delete( strategyGrp[i] );
            }
            else
                console.log( `Strategy id can't be found to clean up (${strategyGrp[i]})!` );
        }
    }
    
    //
    //  DESC: Get a reference to the strategy
    //
    get( strategyId )
    {
        // Make sure the strategy we are looking for is available
        let strategy = this.strategyMap.get( strategyId );
        if( !strategy )
            throw new Error( `Sprite Manager strategy Id can't be found (${strategyId})!` );
        
        return strategy;
    }
    
    //
    //  DESC: Delete all the strategy
    //
    clear()
    {
        this.cleanUp();
        
        this.strategyMap.clear();
        this.strategyAry = [];
    }

    //
    //  DESC: Do some cleanup
    //
    cleanUp()
    {
        for( let each of this.strategyMap.values() )
            each.cleanUp();
    }

    //
    //  DESC: Update the strategy
    //
    update()
    {
        for( let i = 0; i < this.strategyAry.length; i++ )
            this.strategyAry[i].update();
    }

    //
    //  DESC: Transform the strategy
    //
    transform()
    {
        for( let i = 0; i < this.strategyAry.length; i++ )
            this.strategyAry[i].transform();
    }

    //
    //  DESC: Render the strategy
    //
    render()
    {
        for( let i = 0; i < this.strategyAry.length; i++ )
            this.strategyAry[i].render();
    }
}

var strategyManager = new StrategyManager;


/***/ }),
/* 148 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "strategyLoader": () => (/* binding */ strategyLoader)
/* harmony export */ });
/* harmony import */ var _strategy_strategymanager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(147);
/* harmony import */ var _strategy_strategy__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(149);
/* harmony import */ var _sprite_sprite__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(37);

// 
//  FILE NAME: strategyloader.js
//  DESC:      Helper class for loading strategies
//







class Strategyloader
{
    constructor()
    {
    }

    // 
    //  DESC: Load from the XML node
    //        NOTE: The loading of strategies has to be broken up because
    //              they load their own XML that describes what is defined
    //              in the strategy.
    //
    load( xmlNode )
    {
        let promiseAry = [];
        let strategyNode = xmlNode.getElementsByTagName( 'strategy' );

        // Have the load manager create the strategy
        for( let i = 0; i < strategyNode.length; ++i )
        {
            let strategyName = strategyNode[i].getAttribute( 'name' );
            if( !strategyName )
                throw new Error( `Strategy name not defined.` );

            promiseAry.push( _strategy_strategymanager__WEBPACK_IMPORTED_MODULE_0__.strategyManager.addStrategy( strategyName, new _strategy_strategy__WEBPACK_IMPORTED_MODULE_1__.Strategy ) );
        }

        // Preload the strategies
        return Promise.all( promiseAry )
            .then(() => this.loadStartegy( xmlNode ));
    }
    
    // 
    //  DESC: Load the strategies
    //        NOTE: The loading of strategies has to be broken up because
    //              they load their own XML that describes what is defined
    //              in the strategy.
    //
    loadStartegy( xmlNode )
    {
        let strategyNode = xmlNode.getElementsByTagName( 'strategy' );

        for( let i = 0; i < strategyNode.length; ++i )
        {
            let strategyName = strategyNode[i].getAttribute( 'name' );

            // Try to get the strategy
            let strategy = _strategy_strategymanager__WEBPACK_IMPORTED_MODULE_0__.strategyManager.get( strategyName );
            if( !strategy )
                throw new Error( `Strategy name not defined (${strategyName}).` );

            // Apply a camera if one is defined
            let cameraId = strategyNode[i].getAttribute( 'camera' );
            if( cameraId )
                strategy.setCamera( cameraId );
            
            // Populate the strategies with their objects
            this.populateStartegy( strategyNode[i], strategy );
        }
    }
    
    // 
    //  DESC: Populate the strategies with their objects
    //
    populateStartegy( xmlNode, strategy )
    {
        let defaultName = xmlNode.getAttribute( 'defaultName' );
        let defaultGroup = xmlNode.getAttribute( 'defaultGroup' );

        let xmlNodeLst = xmlNode.children;

        for( let i = 0; i < xmlNodeLst.length; ++i )
        {
            if( xmlNodeLst[i].nodeName === 'node' )
            {
                // Get the name of the strategy node
                let name = xmlNodeLst[i].getAttribute( 'name' );
                if( !name )
                    name = defaultName

                // See if a group has been specified
                let group = xmlNodeLst[i].getAttribute( 'group' );
                if( !group )
                    group = defaultGroup

                // Get the instance name if one is provided.
                // Nodes with instance names are stored in a map so that a reference can be returned
                let instance = xmlNodeLst[i].getAttribute( 'instance' );

                // Creating a node is automaticly active unless defined as false. Default true even if not specified
                let active = xmlNodeLst[i].getAttribute( 'active' );
                let headNode = strategy.create( name, instance, (!active || active === 'true'), group );

                for( let j = 0; j < xmlNodeLst[i].children.length; ++j )
                {
                    let xmlChildNode = xmlNodeLst[i].children[j];

                    // If the head node specified an object or sprite to init
                    if( xmlChildNode.nodeName === 'object' || xmlChildNode.nodeName === 'sprite' )
                    {
                        this.init( xmlChildNode, headNode.get() );
                    }

                    // If the head node specified a child node to init
                    else if( xmlChildNode.nodeName === 'node' )
                    {
                        // Get the name of the child node
                        let childName = xmlChildNode.getAttribute( 'name' );
                        if( childName )
                        {
                            let childNode = headNode.allNodeMap.get( childName );
                            if( childNode )
                            {
                                this.init( xmlChildNode.firstElementChild, childNode.get() );
                            }
                            else
                            {
                                console.log(`Strategy Loader Warning: Child node defined for ${name} but can not be found.`);
                            }
                        }
                        else
                        {
                            console.log(`Strategy Loader Warning: Child node defined for ${name} but child node name not defined. Can't initialize.`);
                        }
                    }
                }
            }
        }
    }

    // 
    //  DESC: Init the object with the xmlNode data
    //
    init( xmlNode, object )
    {
        // Set any transforms
        if( object instanceof _sprite_sprite__WEBPACK_IMPORTED_MODULE_2__.Sprite )
            object.reload( xmlNode );
        else
            object.loadTransFromNode( xmlNode );

        // See if there are any scripts that need to be prepared to run
        let scriptList = xmlNode.getElementsByTagName( 'script' );
        for( let i = 0; i < scriptList.length; ++i )
        {
            let attr = scriptList[i].getAttribute( 'prepare' );
            if( attr )
                object.scriptComponent.prepare( attr, object );
        }   
    }
}

var strategyLoader = new Strategyloader;


/***/ }),
/* 149 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Strategy": () => (/* binding */ Strategy)
/* harmony export */ });
/* harmony import */ var _common_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);
/* harmony import */ var _node_nodedatalist__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(150);
/* harmony import */ var _managers_cameramanager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10);
/* harmony import */ var _objectdatamanager_objectdatamanager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(112);
/* harmony import */ var _node_nodefactory__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(153);
/* harmony import */ var _common_defs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(6);
/* harmony import */ var _utilities_genfunc__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(26);

//
//  FILE NAME: strategy.js
//  DESC:      Basic strategy class
//











class Strategy extends _common_object__WEBPACK_IMPORTED_MODULE_0__.Object
{
    constructor()
    {
        super();

        // Camera
        this.camera = _managers_cameramanager__WEBPACK_IMPORTED_MODULE_2__.cameraManager.getDefault();

        // Map of the node data
        this.dataMap = new Map;

        // Active Array of nodes
        this.nodeAry = [];

        // Map of nodes with instance names
        this.nodeMap = new Map;

        // Array of nodes to be added to the active vector
        this.activateAry = [];
        
        // Array of nodess to be removed to the active vector
        this.deactivateAry = [];
        
        // Set of indexes to delete
        this.deleteAry = [];

        // Clear all array
        this.clearAllAry = [];

        // Clear all nodes flag
        this.clearAllNodesFlag = false;
    }

    //
    //  DESC: Load the node data from xml
    //
    loadFromNode( xmlNode, filePath )
    {
        let defaultGroup = '';
        let defaultObjName = '';
        let defaultId = _common_defs__WEBPACK_IMPORTED_MODULE_5__.DEFAULT_ID;

        let attr = xmlNode.getAttribute( 'defaultGroup' );
        if( attr !== null )
            defaultGroup = attr;

        attr = xmlNode.getAttribute( 'defaultObjectName' );
        if( attr !== null )
            defaultObjName = attr;

        attr = xmlNode.getAttribute( 'defaultId' );
        if( attr !== null )
            defaultId = Number(attr);

        attr = xmlNode.getAttribute( 'defaultCamera' );
        if( attr !== null )
            this.setCamera( attr )

        for( let i = 0; i < xmlNode.children.length; ++i )
        {
            // There must be a name associated with this node data
            let nodeName = xmlNode.children[i].getAttribute( 'name' );
            if( !nodeName )
                throw new Error( `Strategy missing node name! (${filePath})` );

            // Allocate the node data list and add it to the map
            this.dataMap.set( nodeName, new _node_nodedatalist__WEBPACK_IMPORTED_MODULE_1__.NodeDataList( xmlNode.children[i], defaultGroup, defaultObjName, defaultId ) );
        }
    }

    //
    //  DESC: Clear out all nodes
    //
    clear()
    {
        for( let i = 0; i < this.nodeAry.length; i++ )
            this.deleteAry.push( this.nodeAry[i] );
    }

    //
    //  DESC: Do some cleanup
    //
    cleanUp()
    {
        // See if any nodes in the map are not part of the node array and clean
        for( let node of this.nodeMap.values() )
        {
            let index = this.nodeAry.findIndex( (obj) => obj === node );
            if( index === -1 )
                node.cleanUp();
        }

        for( let i = 0; i < this.nodeAry.length; i++ )
            this.nodeAry[i].cleanUp();
    }

    //
    //  DESC: Get the sprite data container by name
    //
    getData( name, group = '' )
    {
        // If the data can't be found, this could be a simple one-off sprite node 
        // which can be generated from the group and object data name
        let data = this.dataMap.get( name );
        if( !data )
        {
            // If we can't find the data and the group param is empty, see if we can find the group 
            // in the Object Data Manager as a last attemp. 
            if( !group )
            {
                group = _objectdatamanager_objectdatamanager__WEBPACK_IMPORTED_MODULE_3__.objectDataManager.findGroup( name );
                if( group )
                    console.log( `Simple Strategy node sprite auto generated from group search (${group}, ${name})!` );
            }
            else
                console.log( `Simple Strategy node sprite auto generated from group and object name (${group}, ${name})!` );

            // If we found group that has an object of the same name, create the data and pass it along
            if( group )
            {
                this.loadFromNode( 
                    _utilities_genfunc__WEBPACK_IMPORTED_MODULE_6__.stringLoadXML(`<strategy defaultGroup="${group}"><node name="${name}"><sprite/></node></strategy>`).getElementsByTagName( 'strategy' )[0],
                    'Dynamic generation');
                data = this.dataMap.get( name );
            }
            else
                throw new Error( `Error finding node data (${name})!` );
        }

        return data;
    }

    //
    //  DESC: create the sprite node
    //
    create( dataName, instanceName = null, makeActive = true, group = '' )
    {
        // Get the data for this data name
        let nodeAry = this.getData( dataName, group ).dataAry;

        // Build the node list
        let headNode = null;
        for( let i = 0; i < nodeAry.length; i++ )
        {
            let node = _node_nodefactory__WEBPACK_IMPORTED_MODULE_4__.create( nodeAry[i] );

            if( headNode === null )
                headNode = node;

            else if( !headNode.addNode( node, nodeAry[i].nodeName ) )
                throw new Error( `Parent node not found or node does not support adding children (${nodeAry[i].nodeName}, ${node.parentId})!` );
        }

        // Add the node to the array for adding to the active list
        if( !instanceName || makeActive )
            this.activateAry.push( headNode );

        // If there is an instance name with this node, add it to the map
        if( instanceName )
        {
            // Check for duplicate names
            if( this.nodeMap.has( instanceName ) )
                throw new Error( `Duplicate node instance name (${instanceName})!` );

            this.nodeMap.set( instanceName, headNode );
        }

        return headNode;
    }

    //
    //  DESC: activate node
    //
    activateCount()
    {
        return this.nodeAry.length;
    }

    //
    //  DESC: Count of awake nodes
    //
    awakeCount()
    {
        let result = 0;

        for( let i = 0; i < this.nodeAry.length; i++ )
        {
            let sprite = this.nodeAry[i].get();
            if( sprite.isPhysicsActive() )
                if( sprite.isPhysicsAwake() )
                    result += 1;
        }

        return result;
    }

    //
    //  DESC: activate node
    //
    isPhysicsAwake()
    {
        for( let i = 0; i < this.nodeAry.length; i++ )
        {
            let sprite = this.nodeAry[i].get();
            if( sprite.isPhysicsActive() )
                if( sprite.isPhysicsAwake() )
                    return true;
        }

        return false;
    }
    
    //
    //  DESC: activate node
    //
    activateNode( instanceName )
    {
        let node = this.nodeMap.get( instanceName );
        if( node )
        {
            let index = this.nodeAry.findIndex( (obj) => obj === node );
            if( index !== -1 )
                console.log( `Node is already active (${instanceName})!` );
            else
                this.activateAry.push( node );
        }
        else
            throw new Error( `Node can't be found (%s) (${instanceName})!` );
        
        return node;
    }
    
    //
    //  DESC: deactivate node
    //
    deactivateNode( instanceName )
    {
        let node = this.nodeMap.get( instanceName );
        if( node )
        {
            let index = this.nodeAry.findIndex( (obj) => obj === node );
            if( index !== -1 )
                this.deactivateAry.push( this.nodeAry[index] );
            else
                console.log( `Node is not active (${instanceName})!` );
        }
        else
            console.log( `Node can't be found (%s) (${instanceName})!` );
    }

    //
    //  DESC: deactivate all the nodes
    //
    deactivateAll()
    {
        for( let [ key, node ] of this.nodeMap.entries() )
        {
            let index = this.nodeAry.findIndex( (obj) => obj === node );
            if( index !== -1 )
                this.deactivateAry.push( this.nodeAry[index] );
            else
                console.log( `Node is not active (${key})!` );
        }
    }

    //
    //  DESC: destroy the node
    //
    destroy( node )
    {
        this.deleteAry.push( node );
    }

    //
    //  DESC: Get the node by id
    //
    get( id )
    {
        let node = null;
    
        if( typeof id === 'string' )
        {
            node = this.nodeMap.get( id );
            if( !node )
                throw new Error( `Node instance name can't be found (${id})!` );
        }
        else
        {
            let index = this.nodeAry.findIndex( (node) => node.getId() === id );
            if( index !== -1 )
                node = this.nodeAry[index];
            else
                throw new Error( `Node index can't be found (${id})!` );
        }

        return node;
    }

    //
    //  DESC: Update the sprites
    //
    update()
    {
        for( let i = 0; i < this.nodeAry.length; i++ )
            this.nodeAry[i].update();

        // Remove nodes from the active list
        this.removeFromActiveList();
        
        // Remove deleted nodes from the active list and map
        this.deleteFromActiveList();

        // Add created nodes to the active list
        this.addToActiveList();
    }

    //
    //  DESC: Transform the sprite
    //
    transform()
    {
        super.transform();

        for( let i = 0; i < this.nodeAry.length; i++ )
            this.nodeAry[i].transform( this );
    }

    //
    //  DESC: Render the sprites
    //
    render()
    {
        for( let i = 0; i < this.nodeAry.length; i++ )
            this.nodeAry[i].render( this.camera );
    }

    //
    //  DESC: Add created nodes to the active list
    //
    addToActiveList()
    {
        if( this.activateAry.length )
        {
            for( let i = 0; i < this.activateAry.length; i++ )
            {
                this.activateAry[i].update();
                this.nodeAry.push( this.activateAry[i] );
            }

            this.activateAry = [];
        }
    }

    //
    //  DESC: Remove deleted nodes from the active list and map
    //
    removeFromActiveList()
    {
        if( this.deactivateAry.length )
        {
            for( let i = 0; i < this.deactivateAry.length; i++ )
            {
                let node = this.deactivateAry[i];

                let index = this.nodeAry.findIndex( (obj) => obj === node );
                if( index !== -1 )
                    this.nodeAry.splice( index, 1 );
                else
                    throw new Error( `Node id can't be found to remove from active list!` );
            }

            this.deactivateAry = [];
        }
    }
    
    //
    //  DESC: Remove deleted nodes from the active list and map
    //
    deleteFromActiveList()
    {
        if( this.deleteAry.length )
        {
            for( let i = 0; i < this.deleteAry.length; i++ )
            {
                let node = this.deleteAry[i];

                let index = this.nodeAry.findIndex( (obj) => obj === node );
                if( index !== -1 )
                {
                    // Clean up if font or physics sprite
                    this.nodeAry[index].cleanUp();
                    this.nodeAry.splice( index, 1 );
                }
                else
                    throw new Error( `Node can't be found to delete!` );
                
                // If this same node is in the map, delete it here too.
                for( let [ key, obj ] of this.nodeMap.entries() )
                {
                    if( obj === node )
                    {
                        this.nodeMap.delete(key);
                        break;
                    }
                }
            }

            this.deleteAry = [];
        }
    }

    //
    //  DESC: Set all the ids to the default id
    //
    setAllToDefaultId()
    {
        for( let i = 0; i < this.nodeAry.length; i++ )
            this.nodeAry[i].setId( _common_defs__WEBPACK_IMPORTED_MODULE_5__.DEFAULT_ID );
    }

    // 
    //  DESC: Set the camera
    //
    setCamera( cameraId )
    {
        this.camera = _managers_cameramanager__WEBPACK_IMPORTED_MODULE_2__.cameraManager.get( cameraId );
    }
}


/***/ }),
/* 150 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NodeDataList": () => (/* binding */ NodeDataList)
/* harmony export */ });
/* harmony import */ var _nodedata__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(151);
/* harmony import */ var _common_defs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);

//
//  FILE NAME: nodedatalist.js
//  DESC:      Based on how the XML is written, creates a node
//             list so that the Parent/child nodes can be created
//






class NodeDataList
{
    constructor(
        node,
        defGroup = '',
        defObjName = '',
        userId = _common_defs__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_ID )
    {
        // Array of the node data
        this.dataAry = [];
        
        let defaultGroup = defGroup;
        let defaultObjName = defObjName;
        let nodeName = '';
        
        let attr = node.getAttribute( 'defaultGroup' );
        if( attr )
            defaultGroup = attr;
        
        attr = node.getAttribute( 'defaultObjectName' );
        if( attr )
            defaultObjName = attr;
        
        attr = node.getAttribute( 'defaultId' );
        if( attr )
            userId = Number(attr);
        
        // Get the sprite's unique id number
        attr = node.getAttribute( "id" );
        if( attr )
            userId = Number(attr);
        
        attr = node.getAttribute( 'name' );
        if( attr )
            nodeName = attr;
        
        this.idCounter = _common_defs__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_ID;
        
        let nodeData = new _nodedata__WEBPACK_IMPORTED_MODULE_0__.NodeData( node, nodeName, this.idCounter++, _common_defs__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_ID, defaultGroup, defaultObjName, userId );
        this.dataAry.push( nodeData );
        
        // Call the recursive function to load the children
        this.loadNode( node, nodeData, defaultGroup, defaultObjName, userId );
    }
    
    // 
    //  DESC: Load the node data recursively
    //
    loadNode( node, nodeData, defaultGroup, defaultObjName, userId )
    {
        for( let i = 0; i < node.children.length; ++i )
        {
            if( node.children[i].nodeName == 'node' )
            {
                let nodeName = '';
                let attr = node.children[i].getAttribute( 'name' );
                if( attr )
                    nodeName = attr;

                let childNodeData = new _nodedata__WEBPACK_IMPORTED_MODULE_0__.NodeData( node.children[i], nodeName, this.idCounter++, nodeData.nodeId, defaultGroup, defaultObjName, userId );
                this.dataAry.push( childNodeData );

                // Try to recursively load more children
                this.loadNode( node.children[i], childNodeData, defaultGroup, defaultObjName, userId );
            }
        }
    }
}


/***/ }),
/* 151 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NodeData": () => (/* binding */ NodeData)
/* harmony export */ });
/* harmony import */ var _sprite_spritedata__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(152);
/* harmony import */ var _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(132);
/* harmony import */ var _common_defs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6);

//
//  FILE NAME: nodedata.js
//  DESC:      Node data class
//







class NodeData extends _sprite_spritedata__WEBPACK_IMPORTED_MODULE_0__.SpriteData
{
    constructor(
        xmlNode,
        nodeName,
        nodeId = _common_defs__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_ID,
        parentNodeId = _common_defs__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_ID,
        defGroup = '',
        defObjName = '',
        userId = _common_defs__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_ID )
    {
        super( xmlNode.firstElementChild, nodeName, defGroup, defObjName );

        // node name
        this.nodeName = nodeName;

        // User Id
        this.userId = userId;

        // Node Id
        this.nodeId = nodeId;

        // Parent Id
        this.parentNodeId = parentNodeId;

        // Node type
        this.nodeType = _common_defs__WEBPACK_IMPORTED_MODULE_2__.ENT_NULL;

        // Is this a node with children nodes?
        this.hasChildrenNodes = false;
        for( let i = 0; i < xmlNode.children.length; ++i )
            if( xmlNode.children[i].nodeName == 'node' )
                this.hasChildrenNodes = true;

        for( let i = 0; i < xmlNode.children.length; ++i )
        {
            if( xmlNode.children[i].nodeName == 'object' )
            {
                this.nodeType = _common_defs__WEBPACK_IMPORTED_MODULE_2__.ENT_OBJECT;
                break;
            }
            else if( xmlNode.children[i].nodeName == 'sprite' )
            {
                this.nodeType = _common_defs__WEBPACK_IMPORTED_MODULE_2__.ENT_SPRITE;
                break;
            }
            else if( xmlNode.children[i].nodeName == 'uiProgressBar' )
            {
                this.nodeType = _common_defs__WEBPACK_IMPORTED_MODULE_2__.ENT_UI_CONTROL;
                this.uiControlType = _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_1__.ECT_PROGRESS_BAR;
                break;
            }
            else if( xmlNode.children[i].nodeName == 'uiMeter' )
            {
                this.nodeType = _common_defs__WEBPACK_IMPORTED_MODULE_2__.ENT_UI_CONTROL;
                this.uiControlType = _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_1__.ECT_METER;
                break;
            }
        }

        // Throw an error if a node type is not found
        if( this.nodeType === _common_defs__WEBPACK_IMPORTED_MODULE_2__.ENT_NULL )
            throw new Error( `Node type not defined (${xmlNode.baseURI}).` );
    }
}


/***/ }),
/* 152 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SpriteData": () => (/* binding */ SpriteData)
/* harmony export */ });

// 
//  FILE NAME: spritedata.js
//  DESC:      Sprite data class
//



class SpriteData
{
    constructor( xmlNode, nodeName, defGroup, defObjName )
    {
        // XML node
        this.xmlNode = xmlNode;
        
        // Group Name
        this.group = defGroup;
        
        // Object name
        this.objectName = defObjName;

        // Sprite is visible by default
        this.visible = true;

        // Get the object data name
        // Init with the node name in the event the node and the object data names are the same and a default object name was not defined
        if( !this.objectName )
            this.objectName = nodeName;
        
        // Get the group this sprite belongs to
        let attr = xmlNode.getAttribute( 'group' );
        if( attr )
            this.group = attr;
        
        // Get the object data name
        attr = xmlNode.getAttribute( 'objectName' );
        if( attr)
            this.objectName = attr;
        else if( !defObjName )
            console.log(`Node name used for object data look-up (${this.group}, ${this.objectName})`);
    }
}


/***/ }),
/* 153 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "create": () => (/* binding */ create)
/* harmony export */ });
/* harmony import */ var _objectdatamanager_objectdatamanager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(112);
/* harmony import */ var _gui_uiprogressbar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(141);
/* harmony import */ var _gui_uimeter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(139);
/* harmony import */ var _node_spritenode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(154);
/* harmony import */ var _node_spriteleafnode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(158);
/* harmony import */ var _node_uicontrolnode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(159);
/* harmony import */ var _node_uicontrolleafnode__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(160);
/* harmony import */ var _node_objectnode__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(161);
/* harmony import */ var _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(132);
/* harmony import */ var _common_defs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(6);

// 
//  FILE NAME: nodefactory.js
//  DESC:      Class factory for node creation
//














// 
//  DESC: Load files
//
function create( nodeData )
{
    let node = null;
    
    if( nodeData.nodeType === _common_defs__WEBPACK_IMPORTED_MODULE_9__.ENT_SPRITE )
    {
        if( nodeData.hasChildrenNodes )
            node = new _node_spritenode__WEBPACK_IMPORTED_MODULE_3__.SpriteNode( _objectdatamanager_objectdatamanager__WEBPACK_IMPORTED_MODULE_0__.objectDataManager.getData( nodeData.group, nodeData.objectName ), nodeData );

        // Single node sprite that doesn't support children. Low overhead for when you only need one sprite
        else
            node = new _node_spriteleafnode__WEBPACK_IMPORTED_MODULE_4__.SpriteLeafNode( _objectdatamanager_objectdatamanager__WEBPACK_IMPORTED_MODULE_0__.objectDataManager.getData( nodeData.group, nodeData.objectName ), nodeData );
        
        LoadSprite( node, nodeData );
    }
    else if( nodeData.nodeType === _common_defs__WEBPACK_IMPORTED_MODULE_9__.ENT_OBJECT )
    {
        // Object node is automatically a multilist node because an object node without children is pretty useless
        node = new _node_objectnode__WEBPACK_IMPORTED_MODULE_7__.ObjectNode( nodeData );
        
        node.object.loadTransFromNode( nodeData.xmlNode );
    }
    else if( nodeData.nodeType === _common_defs__WEBPACK_IMPORTED_MODULE_9__.ENT_UI_CONTROL )
    {
        node = CreateUIControlNode( nodeData );
    }
    else
        throw new Error( `Node type not defined (${nodeData.nodeName}).` );
    
    return node;
}

// 
//  DESC: Load the sprite data
//
function LoadSprite( node, nodeData )
{
    // Load from sprite data
    node.sprite.load( nodeData.xmlNode );

    // Mainly for font sprites
    node.sprite.init();

    // Init the physics
    node.sprite.initPhysics();
}

// 
//  DESC: Create the UI Control node
//
function CreateUIControlNode( nodeData )
{
    let control = null;
    
    if( nodeData.uiControlType == _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_8__.ECT_PROGRESS_BAR )
        control = new _gui_uiprogressbar__WEBPACK_IMPORTED_MODULE_1__.UIProgressBar( nodeData.group );
    
    else if( nodeData.uiControlType == _gui_uicontroldefs__WEBPACK_IMPORTED_MODULE_8__.ECT_METER )
        control = new _gui_uimeter__WEBPACK_IMPORTED_MODULE_2__.UIMeter( nodeData.group );
    
    else
        throw new Error( `Node control type not defined (${nodeData.nodeName}).` );
    
    control.loadFromNode( nodeData.xmlNode );
    control.init();

    if( nodeData.hasChildrenNodes )
        return new _node_uicontrolnode__WEBPACK_IMPORTED_MODULE_5__.UIControlNode( control, nodeData );
    else
        return new _node_uicontrolleafnode__WEBPACK_IMPORTED_MODULE_6__.UIControlLeafNode( control, nodeData );
}


/***/ }),
/* 154 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SpriteNode": () => (/* binding */ SpriteNode)
/* harmony export */ });
/* harmony import */ var _rendernode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(155);
/* harmony import */ var _sprite_sprite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(37);
/* harmony import */ var _common_defs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6);

// 
//  FILE NAME: spritenode.js
//  DESC:      Sprite node that allows for children
//







class SpriteNode extends _rendernode__WEBPACK_IMPORTED_MODULE_0__.RenderNode
{
    constructor( objectData, nodeData )
    {
        super( nodeData.nodeId, nodeData.parentNodeId );
        
        this.name = nodeData.nodeName;
        this.sprite = new _sprite_sprite__WEBPACK_IMPORTED_MODULE_1__.Sprite( objectData, this );
        this.type = _common_defs__WEBPACK_IMPORTED_MODULE_2__.ENT_SPRITE;
        this.userId = nodeData.userId;
    }

    // 
    //  DESC: Handle events
    //
    handleEvent( event )
    {
        this.sprite.handleEvent( event );
    }
    
    // 
    //  DESC: Update the sprite
    //
    update()
    {
        this.sprite.update();
        this.sprite.physicsUpdate();
        
        // Call the parent but it has to be last
        super.update();
    }
    
    //
    //  DESC: Transform the sprite
    //
    transform( object )
    {
        if( object )
            this.sprite.transform( object );
        else
            this.sprite.transform();
        
        // Call the parent but it has to be last
        super.transform();
    }
    
    //
    //  DESC: Render the sprite
    //
    render( camera )
    {
        this.sprite.render( camera );
        
        // Call the parent but it has to be last
        super.render( camera );
    }
    
    // 
    //  DESC: Get the sprite
    //
    get()
    {
        return this.sprite;
    }
    
    // 
    //  DESC: Clean up any sprites
    //
    cleanUp()
    {
        this.sprite.cleanUp();
    }
}


/***/ }),
/* 155 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RenderNode": () => (/* binding */ RenderNode)
/* harmony export */ });
/* harmony import */ var _node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(156);
/* harmony import */ var _common_defs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);

// 
//  FILE NAME: rendernode.js
//  DESC:      Node multi link list class
//






class RenderNode extends _node__WEBPACK_IMPORTED_MODULE_0__.Node
{
    constructor( id = _common_defs__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_ID, parentId = _common_defs__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_ID )
    {
        super( id, parentId )
    }
    
    // 
    //  DESC: Do some cleanup
    //
    cleanUp()
    {
        this.cleanUpRecursive( this );
    }
    
    // 
    //  DESC: Recursive function to clean up nodes
    //
    cleanUpRecursive( node )
    {
        if( node !== null )
        {
            node.index = 0;
            let nextNode;

            do
            {
                // get the next node
                nextNode = node.next();

                if( nextNode !== null )
                {
                    // Clean up the children
                    nextNode.cleanUp();

                    // Call a recursive function again
                    this.updateRecursive( nextNode );
                }
            }
            while( nextNode !== null );
        }
    }
    
    // 
    //  DESC: Update the nodes
    //
    update()
    {
        this.updateRecursive( this );
    }
    
    // 
    //  DESC: Recursive function to update nodes
    //
    updateRecursive( node )
    {
        if( node !== null )
        {
            node.index = 0;
            let nextNode;

            do
            {
                // get the next node
                nextNode = node.next();

                if( nextNode !== null )
                {
                    // Update the children
                    nextNode.update();

                    // Call a recursive function again
                    this.updateRecursive( nextNode );
                }
            }
            while( nextNode !== null );
        }
    }

    // 
    //  DESC: Transform the nodes
    //
    transform()
    {
        this.transformRecursive( this );
    }
    
    // 
    //  DESC: Recursive function to transform nodes
    //
    transformRecursive( node )
    {
        if( node !== null )
        {
            node.index = 0;
            let nextNode;

            do
            {
                // get the next node
                nextNode = node.next();

                if( nextNode != null )
                {
                    let nextObj = nextNode.get();
                    let obj = node.get();

                    // Transform the child node
                    nextObj.transform( obj );

                    // Call a recursive function again
                    this.transformRecursive( nextNode );
                }
            }
            while( nextNode !== null );
        }
    }
    
    //
    //  DESC: Render the sprite
    //
    render( camera )
    {
        this.renderRecursive( this, camera );
    }
    
    //
    //  DESC: Render the sprite
    //
    renderRecursive( node, camera )
    {
        if( node !== null )
        {
            node.index = 0;
            let nextNode;

            do
            {
                // get the next node
                nextNode = node.next();

                if( nextNode != null )
                {
                    nextNode.render( camera );

                    // Call a recursive function again
                    this.renderRecursive( nextNode, camera );
                }
            }
            while( nextNode !== null );
        }
    }
}


/***/ }),
/* 156 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Node": () => (/* binding */ Node)
/* harmony export */ });
/* harmony import */ var _inode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(157);

// 
//  FILE NAME: node.js
//  DESC:      Node class
//





class Node extends _inode__WEBPACK_IMPORTED_MODULE_0__.iNode
{
    constructor( id, parentId )
    {
        super( id, parentId );
        
        // Child node array
        this.nodeAry = [];
        
        // Child node index
        this.index = 0;
    }
    
    // 
    //  DESC: Get the next node
    //
    next()
    {
        let result = null;
        
        if( this.index < this.nodeAry.length )
        {
            result = this.nodeAry[this.index];
            this.index++;
        }
        
        return result;
    }
    
    // 
    //  DESC: Add a node
    //
    addNode( node )
    {
        // Call a recursive function to find the parent node
        let parentNode = this.findParent( node );

        // Add the node
        if( parentNode != null )
            parentNode.pushNode( node );
        else
            return false;

        return true;
    }
    
    // 
    //  DESC: Push back node into array
    //
    pushNode( node )
    {
        this.nodeAry.push( node );
    }
    
    // 
    //  DESC: Find the parent
    //
    findParent( searchNode )
    {
        let result = null;

        if( searchNode != null )
        {
            if( this.nodeId == searchNode.getParentId() )
            {
                result = this;
            }
            else
            {
                this.index = 0;
                let nextNode;

                do
                {
                    // get the next node
                    nextNode = this.next();

                    if( nextNode != null )
                    {
                        // Call a recursive function to find the parent node
                        result = nextNode.findParent( searchNode );
                    }
                }
                while( nextNode !== null && result === null );
            }
        }

        return result;
    }

    // 
    //  DESC: Find the child
    //
    findChild( childName )
    {
        let result = null;

        if( childName == this.name )
        {
            result = this;
        }
        else
        {
            this.index = 0;
            let nextNode;

            do
            {
                // get the next node
                nextNode = this.next();

                if( nextNode != null )
                {
                    // Call a recursive function to find the parent node
                    result = nextNode.findChild( childName );
                }
            }
            while( nextNode !== null && result === null );
        }

        return result;
    }
}


/***/ }),
/* 157 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "iNode": () => (/* binding */ iNode)
/* harmony export */ });
/* harmony import */ var _common_defs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);

// 
//  FILE NAME: inode.js
//  DESC:      Node class
//





class iNode
{
    constructor( nodeId, parentId )
    {
        // Node type
        this.type = _common_defs__WEBPACK_IMPORTED_MODULE_0__.ENT_NULL;

        // user id
        this.userId = _common_defs__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_ID;

        // node id
        this.nodeId = nodeId;

        // parent node id
        this.parentId = parentId;

        // Node name
        this.name = '';
    }
    
    // 
    //  DESC: Get the node id
    //
    getId()
    {
        return this.userId;
    }

    // 
    //  DESC: Set the id
    //
    setId( id )
    {
        this.userId = id;
    }
    
    // 
    //  DESC: Get the parent id
    //
    getParentId()
    {
        return this.parentId;
    }
    
    // 
    //  DESC: Get the next node
    //
    next()
    {
        return null;
    }
    
    // 
    //  DESC: Find the parent
    //
    findParent()
    {
        return null;
    }

    // 
    //  DESC: Find the child
    //
    /*findChild()
    {
        return null;
    }*/
    
    // 
    //  DESC: Get the object
    //
    get()
    {
        return null;
    }

    // 
    //  DESC: Handle events
    //
    handleEvent()
    {
        // Empty by design
    }

    // 
    //  DESC: Update the nodes
    //
    update()
    {
        // Empty by design
    }

    //
    //  DESC: Transform the object
    //
    transform()
    {
        // Empty by design
    }

    //
    //  DESC: Render the sprite
    //
    render()
    {
        // Empty by design
    }
    
    // 
    //  DESC: Clean up any sprites
    //
    cleanUp()
    {
        // Empty by design
    }
}


/***/ }),
/* 158 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SpriteLeafNode": () => (/* binding */ SpriteLeafNode)
/* harmony export */ });
/* harmony import */ var _inode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(157);
/* harmony import */ var _sprite_sprite__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(37);
/* harmony import */ var _common_defs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6);

// 
//  FILE NAME: spriteleafnode.js
//  DESC:      Sprite node class for handling a sprite with
//             no children to keep the overhead low
//







class SpriteLeafNode extends _inode__WEBPACK_IMPORTED_MODULE_0__.iNode
{
    constructor( objectData, nodeData )
    {
        super( nodeData.nodeId, nodeData.parentNodeId );
        
        this.name = nodeData.nodeName;
        this.sprite = new _sprite_sprite__WEBPACK_IMPORTED_MODULE_1__.Sprite( objectData, this );
        this.type = _common_defs__WEBPACK_IMPORTED_MODULE_2__.ENT_SPRITE;
        this.userId = nodeData.userId;
    }

    // 
    //  DESC: Handle events
    //
    handleEvent( event )
    {
        this.sprite.handleEvent( event );
    }
    
    // 
    //  DESC: Update the sprite
    //
    update()
    {
        this.sprite.update();
        this.sprite.physicsUpdate();
    }
    
    //
    //  DESC: Transform the sprite
    //
    transform( object = null )
    {
        if( object )
            this.sprite.transform( object );
        else
            this.sprite.transform();
    }
    
    //
    //  DESC: Render the sprite
    //
    render( camera )
    {
        this.sprite.render( camera );
    }
    
    // 
    //  DESC: Get the sprite
    //
    get()
    {
        return this.sprite;
    }
    
    // 
    //  DESC: Clean up any sprites
    //
    cleanUp()
    {
        this.sprite.cleanUp();
    }
}


/***/ }),
/* 159 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UIControlNode": () => (/* binding */ UIControlNode)
/* harmony export */ });
/* harmony import */ var _rendernode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(155);
/* harmony import */ var _common_defs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);

// 
//  FILE NAME: uicontrolnode.js
//  DESC:      UI Control node that allows for children
//






class UIControlNode extends _rendernode__WEBPACK_IMPORTED_MODULE_0__.RenderNode
{
    constructor( uiControl, nodeData )
    {
        super(nodeData.nodeId, nodeData.parentNodeId);
        
        this.name = nodeData.nodeName;
        this.uiControl = uiControl;
        this.userId = nodeData.userId;
        this.type = _common_defs__WEBPACK_IMPORTED_MODULE_1__.ENT_UI_CONTROL;
    }
    
    // 
    //  DESC: Update the control
    //
    update()
    {
        this.uiControl.update();

        // Call the parent but it has to be last
        super.update();
    }
    
    //
    //  DESC: Transform the control
    //
    transform( object = null )
    {
        if( object )
            this.uiControl.transform( object );
        else
            this.uiControl.transform();
        
        // Call the parent but it has to be last
        super.transform();
    }
    
    //
    //  DESC: Render the control
    //
    render( camera )
    {
        this.uiControl.render( camera );

        // Call the parent but it has to be last
        super.render( camera );
    }
    
    // 
    //  DESC: Get the control
    //
    get()
    {
        return this.uiControl;
    }
    
    // 
    //  DESC: Get the node id
    //
    getId()
    {
        return _common_defs__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_ID;
    }
    
    // 
    //  DESC: Clean up any control
    //
    cleanUp()
    {
        this.uiControl.cleanUp();
    }
}


/***/ }),
/* 160 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UIControlLeafNode": () => (/* binding */ UIControlLeafNode)
/* harmony export */ });
/* harmony import */ var _inode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(157);
/* harmony import */ var _common_defs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);

// 
//  FILE NAME: uicontrolnode.js
//  DESC:      UI Control node class for rendering a ui control
//






class UIControlLeafNode extends _inode__WEBPACK_IMPORTED_MODULE_0__.iNode
{
    constructor( uiControl, nodeData )
    {
        super(nodeData.nodeId, nodeData.parentNodeId);
        
        this.name = nodeData.nodeName;
        this.uiControl = uiControl;
        this.userId = nodeData.userId;
        this.type = _common_defs__WEBPACK_IMPORTED_MODULE_1__.ENT_UI_CONTROL;
    }
    
    // 
    //  DESC: Update the control
    //
    update()
    {
        this.uiControl.update();
    }
    
    //
    //  DESC: Transform the control
    //
    transform( object = null )
    {
        if( object )
            this.uiControl.transform( object );
        else
            this.uiControl.transform();
    }
    
    //
    //  DESC: Render the control
    //
    render( camera )
    {
        this.uiControl.render( camera );
    }
    
    // 
    //  DESC: Get the control
    //
    get()
    {
        return this.uiControl;
    }
    
    // 
    //  DESC: Get the node id
    //
    getId()
    {
        return _common_defs__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_ID;
    }
    
    // 
    //  DESC: Clean up any control
    //
    cleanUp()
    {
        this.uiControl.cleanUp();
    }
}


/***/ }),
/* 161 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ObjectNode": () => (/* binding */ ObjectNode)
/* harmony export */ });
/* harmony import */ var _common_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(13);
/* harmony import */ var _rendernode__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(155);
/* harmony import */ var _common_defs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6);

// 
//  FILE NAME: objectnode.js
//  DESC:      Object node that allows for children
//







class ObjectNode extends _rendernode__WEBPACK_IMPORTED_MODULE_1__.RenderNode
{
    constructor( nodeData )
    {
        super( nodeData.nodeId, nodeData.parentNodeId );
        
        this.name = nodeData.nodeName;
        this.object = new _common_object__WEBPACK_IMPORTED_MODULE_0__.Object();
        this.type = _common_defs__WEBPACK_IMPORTED_MODULE_2__.ENT_OBJECT;
        this.userId = nodeData.userId;
    }
    
    // 
    //  DESC: Update the object
    //
    update()
    {
        // Call the parent but it has to be last
        super.update();
    }
    
    //
    //  DESC: Transform the object
    //
    transform( object )
    {
        if( object )
            this.object.transform( object );
        else
            this.object.transform();
        
        // Call the parent but it has to be last
        super.transform();
    }
    
    // 
    //  DESC: Get the object
    //
    get()
    {
        return this.object;
    }
    
    // 
    //  DESC: Get the node id
    //
    getId()
    {
        return this.object.id;
    }

    // 
    //  DESC: Set the id
    //
    setId( id )
    {
        this.object.id = id;
    }
}

/***/ }),
/* 162 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "loadScripts": () => (/* binding */ loadScripts)
/* harmony export */ });
/* harmony import */ var _library_managers_eventmanager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(30);
/* harmony import */ var _library_utilities_settings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _library_script_scriptmanager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17);
/* harmony import */ var _library_common_defs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6);
/* harmony import */ var _utilityscripts__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(163);

//
//  FILE NAME: statescripts.js
//  DESC:      script for the state
//









//
//  DESC: Script for fading in the menu
//
class PlayerShip_FireTailAnim
{
    constructor( sprite )
    {
        this.animate = new _utilityscripts__WEBPACK_IMPORTED_MODULE_4__.PlayAnim( sprite );
        this.animate.init( 24, true );
    }
    
    // 
    //  DESC: Execute this script object
    //
    execute()
    {
        return this.animate.execute();
    }
}

class PlayerShip_RotateGun
{
    constructor( sprite )
    {
        this.sprite = sprite;
        this.iter = this.iteration();
    }

    // 
    //  DESC: Iterate the logic
    //
    * iteration()
    {
        do
        {
            let ratio = 1 / _library_utilities_settings__WEBPACK_IMPORTED_MODULE_1__.settings.orthoAspectRatio.h;
            let halfSize = _library_utilities_settings__WEBPACK_IMPORTED_MODULE_1__.settings.size_half;

            let spritePos = this.sprite.transPos;
            let mousePos = _library_managers_eventmanager__WEBPACK_IMPORTED_MODULE_0__.eventManager.mouseAbsolutePos;

            let gunRotation = Math.atan2( (ratio * (halfSize.w - mousePos.x)) + spritePos.x, (ratio * (halfSize.h - mousePos.y)) - spritePos.y ) + _library_common_defs__WEBPACK_IMPORTED_MODULE_3__.M_PI_2;
            this.sprite.setRotXYZ( 0, 0, gunRotation, false );

            yield;
        }
        while( true );
    }
    
    // 
    //  DESC: Execute this script object
    //
    execute()
    {
        return this.iter.next().done;
    }
}

// 
//  DESC: Load XML files
//
function loadScripts()
{
    _library_script_scriptmanager__WEBPACK_IMPORTED_MODULE_2__.scriptManager.set( 'PlayerShip_FireTailAnim',
        ( sprite ) => { return new PlayerShip_FireTailAnim( sprite ); } );

    _library_script_scriptmanager__WEBPACK_IMPORTED_MODULE_2__.scriptManager.set( 'PlayerShip_RotateGun',
        ( sprite ) => { return new PlayerShip_RotateGun( sprite ); } );
}


/***/ }),
/* 163 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Hold": () => (/* binding */ Hold),
/* harmony export */   "PlayAnim": () => (/* binding */ PlayAnim),
/* harmony export */   "FrameExecute": () => (/* binding */ FrameExecute),
/* harmony export */   "FadeTo": () => (/* binding */ FadeTo),
/* harmony export */   "ColorTo": () => (/* binding */ ColorTo),
/* harmony export */   "loadScripts": () => (/* binding */ loadScripts)
/* harmony export */ });
/* harmony import */ var _library_utilities_highresolutiontimer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(56);
/* harmony import */ var _library_managers_shadermanager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(40);
/* harmony import */ var _library_script_scriptmanager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17);
/* harmony import */ var _library_managers_eventmanager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(30);
/* harmony import */ var _library_common_color__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(20);
/* harmony import */ var _state_statedefs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(146);

//
//  FILE NAME: utilityscripts.js
//  DESC:      script for fading the screen
//










//
//  DESC: Script for holding for time duration
//
class Hold
{
    constructor()
    {
        this.time = 0;
        this.iter = null;
    }
    
    // 
    //  DESC: Init the script for use
    //
    init( time )
    {
        this.time = time;
        this.iter = this.iteration();
    }

    // 
    //  DESC: Iterate the logic
    //
    * iteration()
    {
        do
        {
            this.time -= _library_utilities_highresolutiontimer__WEBPACK_IMPORTED_MODULE_0__.highResTimer.elapsedTime;

            if( this.time < 0 )
                break;

            yield;
        }
        while( true );
    }
    
    // 
    //  DESC: Execute the iteration
    //
    execute()
    {
        return this.iter.next().done;
    }
}


//
//  DESC: Script for playing the frames of an animation
//
class PlayAnim
{
    constructor( sprite )
    {
        this.sprite = sprite;
        
        this.frameCount = this.sprite.getFrameCount();
        this.time = 0;
        this.fps = 0;
        this.counter = 0;
        this.loop = false;
        this.iter = null;
    }
    
    // 
    //  DESC: Init the script for use
    //
    init( fps, loop = false )
    {
        this.fps = fps;
        this.time = 1000.0 / this.fps;
        this.loop = loop;
        this.counter = 0;
        this.iter = this.iteration();
    }

    // 
    //  DESC: Iterate the logic
    //
    * iteration()
    {
        do
        {
            this.time -= _library_utilities_highresolutiontimer__WEBPACK_IMPORTED_MODULE_0__.highResTimer.elapsedTime;

            if( this.time < 0 )
            {
                this.time = 1000.0 / this.fps;
                this.counter++;
                
                if( this.counter < this.frameCount )
                {
                    this.sprite.setFrame( this.counter );
                }
                else
                {
                    if( this.loop )
                    {
                        this.counter = 0;
                        this.sprite.setFrame( this.counter );
                    }
                    else
                        break;
                }
            }

            yield;
        }
        while(true)
    }
    
    // 
    //  DESC: Execute the iteration
    //
    execute()
    {
        return this.iter.next().done;
    }
}

//
//  DESC: Execute an action at a specific frame rate
//
class FrameExecute
{
    constructor()
    {
        this.time = 0;
        this.duration = 0;
        this.durationTime = 0;
        this.fps = 0;
        this.iter = null;
        this.callback = null;
    }
    
    // 
    //  DESC: Init the script for use
    //
    init( fps, callback, duration = 0 )
    {
        this.fps = fps;
        this.time = 1000.0 / this.fps;
        this.duration = duration;
        if( duration > 0 )
            this.durationTime = 1000.0 / duration;
        this.callback = callback;
        this.iter = this.iteration();
    }

    // 
    //  DESC: Iterate the logic
    //
    * iteration()
    {
        do
        {
            this.time -= _library_utilities_highresolutiontimer__WEBPACK_IMPORTED_MODULE_0__.highResTimer.elapsedTime;

            if( this.time < 0 )
            {
                this.time = 1000.0 / this.fps;
                this.callback();
            }

            // Do we specify a count
            if( this.duration > 0 )
            {
                this.durationTime -= _library_utilities_highresolutiontimer__WEBPACK_IMPORTED_MODULE_0__.highResTimer.elapsedTime;
                if( this.durationTime < 0 )
                    break;
            }

            yield;
        }
        while( true );
    }
    
    // 
    //  DESC: Execute the iteration
    //
    execute()
    {
        return this.iter.next().done;
    }
}


//
//  DESC: Script for fading in the menu
//
class FadeTo
{
    constructor()
    {
        this.value = 0;
        this.final = 0;
        this.time = 0;
        this.inc = 0;
        this.iter = null;
    }

    // 
    //  DESC: Init the script for use
    //
    init( start, final, time )
    {
        this.value = start;
        this.final = final;
        this.time = time;
        this.inc = (final - start) / time;
        this.iter = this.iteration();
    }

    // 
    //  DESC: Iterate the logic
    //
    * iteration()
    {
        do
        {
            this.time -= _library_utilities_highresolutiontimer__WEBPACK_IMPORTED_MODULE_0__.highResTimer.elapsedTime;

            if( this.time < 0 )
            {
                this.value = this.final;
                break;
            }

            this.value += (this.inc * _library_utilities_highresolutiontimer__WEBPACK_IMPORTED_MODULE_0__.highResTimer.elapsedTime);
                
            yield;
        }
        while( true );
    }

    // 
    //  DESC: Execute the iteration
    //
    execute()
    {
        return this.iter.next().done;
    }
}

//
//  DESC: Color to the final color in time
//
class ColorTo
{
    constructor()
    {
        this.value = new _library_common_color__WEBPACK_IMPORTED_MODULE_4__.Color;
        this.inc = new _library_common_color__WEBPACK_IMPORTED_MODULE_4__.Color;
        this.final = null;
        this.time = 0;
        this.iter = null;
    }
    
    // 
    //  DESC: Init the script for use
    //
    init( start, final, time )
    {
        this.time = time;
        this.final = final;
        this.value.copy( start );
        
        for( let i = 0; i < 4; ++i )
            this.inc.data[i] = (this.final.data[i] - this.value.data[i]) / this.time;

        this.iter = this.iteration();
    }

    // 
    //  DESC: Iterate the logic
    //
    * iteration()
    {
        do
        {
            this.time -= _library_utilities_highresolutiontimer__WEBPACK_IMPORTED_MODULE_0__.highResTimer.elapsedTime;

            if( this.time < 0 )
            {
                this.value.copy( this.final );
                break;
            }

            for( let i = 0; i < 4; ++i )
                this.value.data[i] += this.inc.data[i] * _library_utilities_highresolutiontimer__WEBPACK_IMPORTED_MODULE_0__.highResTimer.elapsedTime;
                
            yield;
        }
        while( true );
    }
    
    // 
    //  DESC: Execute the iteration
    //
    execute()
    {
        return this.iter.next().done;
    }
}

//
//  DESC: Script for fading the screen
//
class ScreenFade
{
    constructor( current, final, time )
    {
        this.fadeTo = new FadeTo();
        this.fadeTo.init( current, final, time );
        this.iter = this.iteration();
    }

    // 
    //  DESC: Iterate the logic
    //
    * iteration()
    {
        do
        {
            if( this.fadeTo.execute() )
            {
                _library_managers_shadermanager__WEBPACK_IMPORTED_MODULE_1__.shaderManager.setAllShaderValue4fv( 'additive', [this.fadeTo.value, this.fadeTo.value, this.fadeTo.value, 1] );

                if( this.fadeTo.inc > 0 )
                    _library_managers_eventmanager__WEBPACK_IMPORTED_MODULE_3__.eventManager.dispatchEvent( _state_statedefs__WEBPACK_IMPORTED_MODULE_5__.ESE_FADE_IN_COMPLETE );
                else
                    _library_managers_eventmanager__WEBPACK_IMPORTED_MODULE_3__.eventManager.dispatchEvent( _state_statedefs__WEBPACK_IMPORTED_MODULE_5__.ESE_FADE_OUT_COMPLETE );

                break;
            }

            _library_managers_shadermanager__WEBPACK_IMPORTED_MODULE_1__.shaderManager.setAllShaderValue4fv( 'additive', [this.fadeTo.value, this.fadeTo.value, this.fadeTo.value, 1] );

            yield;
        }
        while( true );
    }
    
    // 
    //  DESC: Execute the iteration
    //
    execute()
    {
        return this.iter.next().done;
    }
}

// 
//  DESC: Load the scripts in this file
//
function loadScripts()
{
    _library_script_scriptmanager__WEBPACK_IMPORTED_MODULE_2__.scriptManager.set( 'ScreenFade',
        ( current, final, time ) => { return new ScreenFade( current, final, time ); } );
}


/***/ }),
/* 164 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("<?xml version=\"1.0\"?>\r\n<listTable>\r\n    \r\n    <groupList groupName=\"(main)\">\r\n        <file path=\"data/objects/2d/objectDataList/mainData.lst\"/>\r\n    </groupList>\r\n\r\n    <groupList groupName=\"(space_ship)\">\r\n        <file path=\"data/objects/2d/objectDataList/spaceShipData.lst\"/>\r\n    </groupList>\r\n  \r\n</listTable>\r\n");

/***/ }),
/* 165 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("<?xml version=\"1.0\"?>\r\n<listTable>\r\n    \r\n    <groupList groupName=\"_space_ship_\">\r\n        <file path=\"data/objects/strategy/spaceShip.strategy\"/>\r\n    </groupList>\r\n\r\n    <groupList groupName=\"_main_\">\r\n        <file path=\"data/objects/strategy/main.strategy\"/>\r\n    </groupList>\r\n  \r\n</listTable>\r\n");

/***/ }),
/* 166 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("<?xml version=\"1.0\"?>\r\n<listTable>\r\n\r\n  <groupList groupName=\"(game)\">\r\n    <file path=\"data/objects/2d/physics/gamePhysics.cfg\"/>\r\n  </groupList>\r\n  \r\n</listTable>\r\n");

/***/ }),
/* 167 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("<?xml version=\"1.0\"?>\r\n<cameraLst>\r\n    \r\n    <default projectType=\"orthographic\" minZDist=\"5\" maxZDist=\"1000\" view_angle=\"45.0\"/>\r\n\r\n    <camera id=\"cubeCamera\" projectType=\"perspective\" minZDist=\"5\" maxZDist=\"1000\" view_angle=\"45.0\">\r\n        <position x=\"0\" y=\"0\" z=\"20\"/>\r\n        <rotation x=\"10\" y=\"0\" z=\"0\"/>\r\n    </camera>\r\n  \r\n</cameraLst>\r\n");

/***/ }),
/* 168 */
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"shader_2d":{"vert":{"file":"data/shaders/shader_v100.vert","dataType":[{"name":"in_position","location":0},{"name":"in_uv","location":1},{"name":"cameraViewProjMatrix"}]},"frag":{"file":"data/shaders/shader_v100.frag","dataType":[{"name":"text0"},{"name":"color"},{"name":"additive"}]}},"shader_2d_spriteSheet":{"vert":{"file":"data/shaders/shader_spriteSheet_v100.vert","dataType":[{"name":"in_position","location":0},{"name":"in_uv","location":1},{"name":"cameraViewProjMatrix"},{"name":"glyphRect"}]},"frag":{"file":"data/shaders/shader_v100.frag","dataType":[{"name":"text0"},{"name":"color"},{"name":"additive"}]}},"shader_solid_2d":{"vert":{"file":"data/shaders/shader_solid_v100.vert","dataType":[{"name":"in_position","location":0},{"name":"cameraViewProjMatrix"}]},"frag":{"file":"data/shaders/shader_soild_v100.frag","dataType":[{"name":"color"},{"name":"additive"}]}},"shader_3d":{"vert":{"file":"data/shaders/shader_mesh_v100.vert","dataType":[{"name":"in_position","location":0},{"name":"in_normal","location":1},{"name":"in_uv","location":2},{"name":"cameraViewProjMatrix"},{"name":"normalMatrix"}]},"frag":{"file":"data/shaders/shader_mesh_v100.frag","dataType":[{"name":"text0"},{"name":"color"},{"name":"additive"}]}},"shader_3d_no_txt":{"vert":{"file":"data/shaders/shader_mesh_no_txt_v100.vert","dataType":[{"name":"in_position","location":0},{"name":"in_normal","location":1},{"name":"cameraViewProjMatrix"},{"name":"normalMatrix"}]},"frag":{"file":"data/shaders/shader_mesh_no_txt_v100.frag","dataType":[{"name":"color"},{"name":"additive"}]}}}');

/***/ }),
/* 169 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("<?xml version=\"1.0\"?>\r\n<loader>\r\n\r\n    <strategy name=\"_main_\">\r\n        <node name=\"multiListTestNode\"/>\r\n        <node name=\"waffles\"/>\r\n    </strategy>\r\n    \r\n    <strategy name=\"_space_ship_\">\r\n        <node name=\"player_ship\">\r\n            <object>\r\n                <position x=\"-500\" y=\"-300\" z=\"0\"/>\r\n            </object>\r\n        </node>\r\n    </strategy>\r\n  \r\n</loader>\r\n");

/***/ }),
/* 170 */
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"display":{"resolution":{"width":1280,"height":720},"default":{"width":1920,"height":1080}},"device":{"projection":{"projectType":"orthographic","minZDist":5,"maxZDist":1000,"viewAngle":45},"depthStencilBuffer":{"enableDepthBuffer":"false","createStencilBuffer":"true","clearStencilBuffer":"true","stencilBufferBitSize":1},"targetBuffer":{"clear":"true"},"gamepad":{"allow":"true","stickDeadZone":0.3}},"game":{"name":"Game Template","id":"gametemplate"}}');

/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _game_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);

// 
//  FILE NAME: main.js
//  DESC:      main function
//





// Create the game
var game = new _game_js__WEBPACK_IMPORTED_MODULE_0__.Game;
game.init();

})();

/******/ })()
;